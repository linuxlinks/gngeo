
;@ Dave's Cyclone 68000 Emulator v0.086 - Assembler Output

;@ (c) Copyright 2003 Dave, All rights reserved.
;@ some code (c) Copyright 2005-2006 notaz, All rights reserved.
;@ Cyclone 68000 is free for non-commercial use.

;@ For commercial use, separate licencing terms must be obtained.

  .global CycloneInit
  .global CycloneRun
  .global CycloneSetSr
  .global CycloneGetSr
  .global CycloneVer
CycloneVer: .long 0x0086

;@ --------------------------- Framework --------------------------
CycloneRun:
  stmdb sp!,{r4-r11,lr}
  mov r7,r0          ;@ r7 = Pointer to Cpu Context
                     ;@ r0-3 = Temporary registers
  ldrb r9,[r7,#0x46] ;@ r9 = Flags (NZCV)
  ldr r6,=JumpTab    ;@ r6 = Opcode Jump table
  ldr r5,[r7,#0x5c]  ;@ r5 = Cycles
  ldr r4,[r7,#0x40]  ;@ r4 = Current PC + Memory Base
                     ;@ r8 = Current Opcode
  mov r9,r9,lsl #28  ;@ r9 = Flags 0xf0000000, cpsr format
                     ;@ r10 = Source value / Memory Base

;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts0
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts0:

;@ Check if our processor is in stopped state
  ldr r0,[r7,#0x58]
  tst r0,r0 ;@ stopped?
  movne r0,#0
  strne r0,[r7,#0x5C]  ;@ eat all cycles
  ldmneia sp!,{r4-r11,pc} ;@ we are stopped, do nothing!

;@ Check if interrupt used up all the cycles:
  subs r5,r5,#0
  blt CycloneEndNoBack

  ldrh r8,[r4],#2 ;@ Fetch first opcode
  ldr pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  .ltorg

;@ We come back here after execution
CycloneEnd:
  sub r4,r4,#2
CycloneEndNoBack:
  mov r9,r9,lsr #28
  str r4,[r7,#0x40]  ;@ Save Current PC + Memory Base
  str r5,[r7,#0x5c]  ;@ Save Cycles
  strb r9,[r7,#0x46] ;@ Save Flags (NZCV)
  ldmia sp!,{r4-r11,pc}

;@ uncompress jump table
CycloneInit:
  ldr r12,=JumpTab
  add r0,r12,#0xe000*4 ;@ ctrl code pointer
  ldr r1,[r0,#-4]
  tst r1,r1
  movne pc,lr ;@ already uncompressed
  add r3,r12,#0xa000*4 ;@ handler table pointer, r12=dest
unc_loop:
  ldrh r1,[r0],#2
  and r2,r1,#0xf
  bic r1,r1,#0xf
  ldr r1,[r3,r1,lsr #2] ;@ r1=handler
  cmp r2,#0xf
  addeq r2,r2,#1 ;@ 0xf is really 0x10
  tst r2,r2
  ldreqh r2,[r0],#2 ;@ counter is in next word
  tst r2,r2
  beq unc_finish ;@ done decompressing
  tst r1,r1
  addeq r12,r12,r2,lsl #2 ;@ 0 handler means we should skip those bytes
  beq unc_loop
unc_loop_in:
  subs r2,r2,#1
  str r1,[r12],#4
  bgt unc_loop_in
  b unc_loop
unc_finish:
  ldr r12,=JumpTab
  ;@ set a-line and f-line handlers
  add r0,r12,#0xa000*4
  ldr r1,[r0,#4] ;@ a-line handler
  ldr r3,[r0,#8] ;@ f-line handler
  mov r2,#0x1000
unc_fill3:
  subs r2,r2,#1
  str r1,[r0],#4
  bgt unc_fill3
  add r0,r12,#0xf000*4
  mov r2,#0x1000
unc_fill4:
  subs r2,r2,#1
  str r3,[r0],#4
  bgt unc_fill4
  bx lr
  .ltorg

CycloneSetSr:
  mov r2,r1,lsr #8
  ldrb r3,[r0,#0x44] ;@ get SR high
  eor r3,r3,r2
  tst r3,#0x20
  and r2,r2,#0xa7 ;@ only nonzero bits
  strb r2,[r0,#0x44] ;@ set SR high
  bne setsr_noswap
  ldr r2,[r0,#0x3C] ;@ Get A7
  ldr r3,[r0,#0x48] ;@ Get OSP
  str r3,[r0,#0x3C]
  str r2,[r0,#0x48]
setsr_noswap:
  mov r2,r1,lsr #3
  strb r2,[r0,#0x45] ;@ the X flag
  bic r2,r1,#0xf3
  tst r1,#1
  orrne r2,r2,#2
  tst r1,#2
  orrne r2,r2,#1
  strb r2,[r0,#0x46] ;@ flags
  bx lr

CycloneGetSr:
  ldrb r1,[r0,#0x46] ;@ flags
  bic r2,r1,#0xf3
  tst r1,#1
  orrne r2,r2,#2
  tst r1,#2
  orrne r2,r2,#1
  ldrb r1,[r0,#0x45] ;@ the X flag
  tst r1,#2
  orrne r2,r2,#0x10
  ldrb r1,[r0,#0x44] ;@ the SR high
  orr r0,r2,r1,lsl #8
  bx lr

;@ DoInterrupt - r0=IRQ number
DoInterrupt:
  stmdb sp!,{lr} ;@ Push ARM return address
;@ Get IRQ Vector address:
  mov r0,r0,asl #2
  add r11,r0,#0x60
;@ swap OSP <-> A7?
  ldrb r0,[r7,#0x44] ;@ Get SR high
  tst r0,#0x20
  bne no_sp_swap1
;@ swap OSP and A7:
  ldr r0,[r7,#0x3C] ;@ Get A7
  ldr r1,[r7,#0x48] ;@ Get OSP
  str r1,[r7,#0x3C]
  str r0,[r7,#0x48]
no_sp_swap1:
  ldr r10,[r7,#0x60] ;@ Get Memory base
  mov r1,r4,lsl #8
  sub r1,r1,r10,lsl #8 ;@ r1 = Old PC
  mov r1,r1,asr #8 ;@ push sign extended
;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Push SR:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  ldr r0,[r7,#0x3c]
  sub r0,r0,#2 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  mov r0,r11
;@ Read IRQ Vector:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  tst r0,r0 ;@ uninitialized int vector?
  moveq r0,#0x3c
  moveq lr,pc
  ldreq pc,[r7,#0x70] ;@ Call read32(r0) handler
  add r0,r0,r10 ;@ r0 = Memory Base + New PC
  mov lr,pc
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrb r0,[r7,#0x47] ;@ IRQ
  orr r1,r0,#0x20 ;@ Supervisor mode + IRQ number
  strb r1,[r7,#0x44] ;@ Put SR high
;@ Clear stopped states:
  mov r1,#0
  str r1,[r7,#0x58]
  sub r5,r5,#44 ;@ Subtract cycles

  ldr r11,[r7,#0x8c] ;@ IrqCallback
  tst r11,r11
  movne lr,pc
  movne pc,r11 ;@ call IrqCallback if it is defined
  ldmia sp!,{pc} ;@ Return

Exception:

  stmdb sp!,{lr} ;@ Preserve ARM return address
  ;@ Cause an Exception - Vector address in r0
  mov r11,r0
;@ swap OSP <-> A7?
  ldrb r0,[r7,#0x44] ;@ Get SR high
  tst r0,#0x20
  bne no_sp_swap0
;@ swap OSP and A7:
  ldr r0,[r7,#0x3C] ;@ Get A7
  ldr r1,[r7,#0x48] ;@ Get OSP
  str r1,[r7,#0x3C]
  str r0,[r7,#0x48]
no_sp_swap0:
  ldr r10,[r7,#0x60] ;@ Get Memory base
  mov r1,r4,lsl #8
  sub r1,r1,r10,lsl #8 ;@ r1 = Old PC
  mov r1,r1,asr #8 ;@ push sign extended
;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Push SR:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  ldr r0,[r7,#0x3c]
  sub r0,r0,#2 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  mov r0,r11
;@ Read IRQ Vector:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  add r0,r0,r10 ;@ r0 = Memory Base + New PC
  mov lr,pc
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrb r0,[r7,#0x44] ;@ Get SR high
  bic r0,r0,#0xd8 ;@ clear trace and unused flags
  orr r0,r0,#0x20 ;@ set supervisor mode
  strb r0,[r7,#0x44]
  ldmia sp!,{pc} ;@ Return

;@ ---------------------------- Opcodes ---------------------------
Op____: ;@ Called if an opcode is not recognised
  sub r4,r4,#2
  str r4,[r7,#0x40] ;@ Save PC
  mov r1,r9,lsr #28
  strb r1,[r7,#0x46] ;@ Save Flags (NZCV)
  str r5,[r7,#0x5c] ;@ Save Cycles
  ldr r11,[r7,#0x94] ;@ UnrecognizedCallback
  tst r11,r11
  movne lr,pc
  movne pc,r11 ;@ call UnrecognizedCallback if it is defined
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrb r9,[r7,#0x46] ;@ r9 = Load Flags (NZCV)
  mov r9,r9,lsl #28
  ldr r4,[r7,#0x40] ;@ Load PC
  tst r0,r0
  moveq r0,#0x10
  bleq Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op__al: ;@ Unrecognised a-line opcode
  sub r4,r4,#2
  str r4,[r7,#0x40] ;@ Save PC
  mov r1,r9,lsr #28
  strb r1,[r7,#0x46] ;@ Save Flags (NZCV)
  str r5,[r7,#0x5c] ;@ Save Cycles
  ldr r11,[r7,#0x94] ;@ UnrecognizedCallback
  tst r11,r11
  movne lr,pc
  movne pc,r11 ;@ call UnrecognizedCallback if it is defined
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrb r9,[r7,#0x46] ;@ r9 = Load Flags (NZCV)
  mov r9,r9,lsl #28
  ldr r4,[r7,#0x40] ;@ Load PC
  tst r0,r0
  moveq r0,#0x28
  bleq Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op__fl: ;@ Unrecognised f-line opcode
  sub r4,r4,#2
  str r4,[r7,#0x40] ;@ Save PC
  mov r1,r9,lsr #28
  strb r1,[r7,#0x46] ;@ Save Flags (NZCV)
  str r5,[r7,#0x5c] ;@ Save Cycles
  ldr r11,[r7,#0x94] ;@ UnrecognizedCallback
  tst r11,r11
  movne lr,pc
  movne pc,r11 ;@ call UnrecognizedCallback if it is defined
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrb r9,[r7,#0x46] ;@ r9 = Load Flags (NZCV)
  mov r9,r9,lsl #28
  ldr r4,[r7,#0x40] ;@ Load PC
  tst r0,r0
  moveq r0,#0x2c
  bleq Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0000] ori.b #$33, d0 uses Op0000 ----------
Op0000:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldrb r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0010] ori.b #$33, (a0) uses Op0010 ----------
Op0010:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0018] ori.b #$33, (a0)+ uses Op0018 ----------
Op0018:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [001f] ori.b #$33, (a7)+ uses Op001f ----------
Op001f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0020] ori.b #$33, -(a0) uses Op0020 ----------
Op0020:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0027] ori.b #$33, -(a7) uses Op0027 ----------
Op0027:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0028] ori.b #$33, ($3333,a0) uses Op0028 ----------
Op0028:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0030] ori.b #$33, ($33,a0,d3.w*2) uses Op0030 ----------
Op0030:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0038] ori.b #$33, $3333.w uses Op0038 ----------
Op0038:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0039] ori.b #$33, $33333333.l uses Op0039 ----------
Op0039:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [003c] ori.b #$33, ccr uses Op003c ----------
Op003c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r10:
  mov r10,r0,asl #0

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  orr r0,r1,r10
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0040] ori.w #$3333, d0 uses Op0040 ----------
Op0040:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsh r0,[r7,r11]
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0050] ori.w #$3333, (a0) uses Op0050 ----------
Op0050:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0058] ori.w #$3333, (a0)+ uses Op0058 ----------
Op0058:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [005f] ori.w #$3333, (a7)+ uses Op005f ----------
Op005f:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0060] ori.w #$3333, -(a0) uses Op0060 ----------
Op0060:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0067] ori.w #$3333, -(a7) uses Op0067 ----------
Op0067:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0068] ori.w #$3333, ($3333,a0) uses Op0068 ----------
Op0068:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0070] ori.w #$3333, ($33,a0,d3.w*2) uses Op0070 ----------
Op0070:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0078] ori.w #$3333, $3333.w uses Op0078 ----------
Op0078:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0079] ori.w #$3333, $33333333.l uses Op0079 ----------
Op0079:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [007c] ori.w #$3333, sr uses Op007c ----------
Op007c:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode007c ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r10:
  mov r10,r0,asl #0

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  orr r0,r1,r10
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap007c
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap007c:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts7c
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts7c:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode007c:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0080] ori.l #$33333333, d0 uses Op0080 ----------
Op0080:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0090] ori.l #$33333333, (a0) uses Op0090 ----------
Op0090:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0098] ori.l #$33333333, (a0)+ uses Op0098 ----------
Op0098:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [009f] ori.l #$33333333, (a7)+ uses Op009f ----------
Op009f:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00a0] ori.l #$33333333, -(a0) uses Op00a0 ----------
Op00a0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00a7] ori.l #$33333333, -(a7) uses Op00a7 ----------
Op00a7:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00a8] ori.l #$33333333, ($3333,a0) uses Op00a8 ----------
Op00a8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00b0] ori.l #$33333333, ($33,a0,d3.w*2) uses Op00b0 ----------
Op00b0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00b8] ori.l #$33333333, $3333.w uses Op00b8 ----------
Op00b8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00b9] ori.l #$33333333, $33333333.l uses Op00b9 ----------
Op00b9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0100] btst d0, d0 uses Op0100 ----------
Op0100:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#31 ;@ reg - do mod 32

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0108] movep.w ($3333,a0), d0 uses Op0108 ----------
Op0108:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

  add r10,r10,#2
;@ EaRead : Read '($3333,a0)' (address in r10) into r1:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r0,r11,r1,lsr #8 ;@ second byte
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaWrite: r0 into register[r11]:
  mov r0,r0,asr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0110] btst d0, (a0) uses Op0110 ----------
Op0110:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0118] btst d0, (a0)+ uses Op0118 ----------
Op0118:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [011f] btst d0, (a7)+ uses Op011f ----------
Op011f:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0120] btst d0, -(a0) uses Op0120 ----------
Op0120:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0127] btst d0, -(a7) uses Op0127 ----------
Op0127:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0128] btst d0, ($3333,a0) uses Op0128 ----------
Op0128:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0130] btst d0, ($33,a0,d3.w*2) uses Op0130 ----------
Op0130:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0138] btst d0, $3333.w uses Op0138 ----------
Op0138:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0139] btst d0, $33333333.l uses Op0139 ----------
Op0139:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [013a] btst d0, ($3333,pc); =3335 uses Op013a ----------
Op013a:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r11,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [013b] btst d0, ($33,pc,d3.w*2); =35 uses Op013b ----------
Op013b:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r11,r2,r0,asr #8 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [013c] btst d0, #$33 uses Op013c ----------
Op013c:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '#$33' into r11:
  ldrsb r11,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r11) into r0:
  mov r0,r11,asl #0

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0140] bchg d0, d0 uses Op0140 ----------
Op0140:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#31 ;@ reg - do mod 32

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0148] movep.l ($3333,a0), d0 uses Op0148 ----------
Op0148:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

  add r10,r10,#2
;@ EaRead : Read '($3333,a0)' (address in r10) into r1:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r11,r11,r1,lsr #8 ;@ second byte
  add r10,r10,#2
;@ EaRead : Read '($3333,a0)' (address in r10) into r1:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r11,r11,r1,lsr #16 ;@ third byte
  add r10,r10,#2
;@ EaRead : Read '($3333,a0)' (address in r10) into r1:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r0,r11,r1,lsr #24 ;@ fourth byte
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0150] bchg d0, (a0) uses Op0150 ----------
Op0150:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0158] bchg d0, (a0)+ uses Op0158 ----------
Op0158:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [015f] bchg d0, (a7)+ uses Op015f ----------
Op015f:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0160] bchg d0, -(a0) uses Op0160 ----------
Op0160:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0167] bchg d0, -(a7) uses Op0167 ----------
Op0167:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0168] bchg d0, ($3333,a0) uses Op0168 ----------
Op0168:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0170] bchg d0, ($33,a0,d3.w*2) uses Op0170 ----------
Op0170:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0178] bchg d0, $3333.w uses Op0178 ----------
Op0178:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0179] bchg d0, $33333333.l uses Op0179 ----------
Op0179:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0180] bclr d0, d0 uses Op0180 ----------
Op0180:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#31 ;@ reg - do mod 32

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0188] movep.w d0, ($3333,a0) uses Op0188 ----------
Op0188:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r11:
  ldrsh r11,[r7,r11]

;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
  mov r1,r11,lsr #8 ;@ first or third byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  add r10,r10,#2
  and r1,r11,#0xff
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0190] bclr d0, (a0) uses Op0190 ----------
Op0190:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0198] bclr d0, (a0)+ uses Op0198 ----------
Op0198:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [019f] bclr d0, (a7)+ uses Op019f ----------
Op019f:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01a0] bclr d0, -(a0) uses Op01a0 ----------
Op01a0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01a7] bclr d0, -(a7) uses Op01a7 ----------
Op01a7:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01a8] bclr d0, ($3333,a0) uses Op01a8 ----------
Op01a8:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01b0] bclr d0, ($33,a0,d3.w*2) uses Op01b0 ----------
Op01b0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01b8] bclr d0, $3333.w uses Op01b8 ----------
Op01b8:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01b9] bclr d0, $33333333.l uses Op01b9 ----------
Op01b9:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01c0] bset d0, d0 uses Op01c0 ----------
Op01c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#31 ;@ reg - do mod 32

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01c8] movep.l d0, ($3333,a0) uses Op01c8 ----------
Op01c8:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
  mov r1,r11,lsr #24 ;@ first byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  add r10,r10,#2
  mov r1,r11,lsr #16 ;@ second byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  add r10,r10,#2
  mov r1,r11,lsr #8 ;@ first or third byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  add r10,r10,#2
  and r1,r11,#0xff
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01d0] bset d0, (a0) uses Op01d0 ----------
Op01d0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01d8] bset d0, (a0)+ uses Op01d8 ----------
Op01d8:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01df] bset d0, (a7)+ uses Op01df ----------
Op01df:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01e0] bset d0, -(a0) uses Op01e0 ----------
Op01e0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01e7] bset d0, -(a7) uses Op01e7 ----------
Op01e7:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01e8] bset d0, ($3333,a0) uses Op01e8 ----------
Op01e8:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01f0] bset d0, ($33,a0,d3.w*2) uses Op01f0 ----------
Op01f0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01f8] bset d0, $3333.w uses Op01f8 ----------
Op01f8:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01f9] bset d0, $33333333.l uses Op01f9 ----------
Op01f9:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  and r10,r0,#7  ;@ mem - do mod 8

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0200] andi.b #$33, d0 uses Op0200 ----------
Op0200:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldrb r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0210] andi.b #$33, (a0) uses Op0210 ----------
Op0210:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0218] andi.b #$33, (a0)+ uses Op0218 ----------
Op0218:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [021f] andi.b #$33, (a7)+ uses Op021f ----------
Op021f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0220] andi.b #$33, -(a0) uses Op0220 ----------
Op0220:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0227] andi.b #$33, -(a7) uses Op0227 ----------
Op0227:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0228] andi.b #$33, ($3333,a0) uses Op0228 ----------
Op0228:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0230] andi.b #$33, ($33,a0,d3.w*2) uses Op0230 ----------
Op0230:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0238] andi.b #$33, $3333.w uses Op0238 ----------
Op0238:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0239] andi.b #$33, $33333333.l uses Op0239 ----------
Op0239:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [023c] andi.b #$33, ccr uses Op023c ----------
Op023c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r10:
  mov r10,r0,asl #0

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  and r0,r1,r10
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0240] andi.w #$3333, d0 uses Op0240 ----------
Op0240:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsh r0,[r7,r11]
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0250] andi.w #$3333, (a0) uses Op0250 ----------
Op0250:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0258] andi.w #$3333, (a0)+ uses Op0258 ----------
Op0258:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [025f] andi.w #$3333, (a7)+ uses Op025f ----------
Op025f:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0260] andi.w #$3333, -(a0) uses Op0260 ----------
Op0260:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0267] andi.w #$3333, -(a7) uses Op0267 ----------
Op0267:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0268] andi.w #$3333, ($3333,a0) uses Op0268 ----------
Op0268:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0270] andi.w #$3333, ($33,a0,d3.w*2) uses Op0270 ----------
Op0270:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0278] andi.w #$3333, $3333.w uses Op0278 ----------
Op0278:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0279] andi.w #$3333, $33333333.l uses Op0279 ----------
Op0279:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [027c] andi.w #$3333, sr uses Op027c ----------
Op027c:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode027c ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r10:
  mov r10,r0,asl #0

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  and r0,r1,r10
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap027c
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap027c:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts27c
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts27c:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode027c:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0280] andi.l #$33333333, d0 uses Op0280 ----------
Op0280:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0290] andi.l #$33333333, (a0) uses Op0290 ----------
Op0290:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0298] andi.l #$33333333, (a0)+ uses Op0298 ----------
Op0298:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [029f] andi.l #$33333333, (a7)+ uses Op029f ----------
Op029f:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02a0] andi.l #$33333333, -(a0) uses Op02a0 ----------
Op02a0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02a7] andi.l #$33333333, -(a7) uses Op02a7 ----------
Op02a7:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02a8] andi.l #$33333333, ($3333,a0) uses Op02a8 ----------
Op02a8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02b0] andi.l #$33333333, ($33,a0,d3.w*2) uses Op02b0 ----------
Op02b0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02b8] andi.l #$33333333, $3333.w uses Op02b8 ----------
Op02b8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02b9] andi.l #$33333333, $33333333.l uses Op02b9 ----------
Op02b9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0400] subi.b #$33, d0 uses Op0400 ----------
Op0400:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldrb r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0410] subi.b #$33, (a0) uses Op0410 ----------
Op0410:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0418] subi.b #$33, (a0)+ uses Op0418 ----------
Op0418:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [041f] subi.b #$33, (a7)+ uses Op041f ----------
Op041f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0420] subi.b #$33, -(a0) uses Op0420 ----------
Op0420:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0427] subi.b #$33, -(a7) uses Op0427 ----------
Op0427:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0428] subi.b #$33, ($3333,a0) uses Op0428 ----------
Op0428:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0430] subi.b #$33, ($33,a0,d3.w*2) uses Op0430 ----------
Op0430:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0438] subi.b #$33, $3333.w uses Op0438 ----------
Op0438:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0439] subi.b #$33, $33333333.l uses Op0439 ----------
Op0439:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0440] subi.w #$3333, d0 uses Op0440 ----------
Op0440:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsh r0,[r7,r11]
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0450] subi.w #$3333, (a0) uses Op0450 ----------
Op0450:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0458] subi.w #$3333, (a0)+ uses Op0458 ----------
Op0458:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [045f] subi.w #$3333, (a7)+ uses Op045f ----------
Op045f:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0460] subi.w #$3333, -(a0) uses Op0460 ----------
Op0460:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0467] subi.w #$3333, -(a7) uses Op0467 ----------
Op0467:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0468] subi.w #$3333, ($3333,a0) uses Op0468 ----------
Op0468:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0470] subi.w #$3333, ($33,a0,d3.w*2) uses Op0470 ----------
Op0470:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0478] subi.w #$3333, $3333.w uses Op0478 ----------
Op0478:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0479] subi.w #$3333, $33333333.l uses Op0479 ----------
Op0479:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0480] subi.l #$33333333, d0 uses Op0480 ----------
Op0480:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0490] subi.l #$33333333, (a0) uses Op0490 ----------
Op0490:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0498] subi.l #$33333333, (a0)+ uses Op0498 ----------
Op0498:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [049f] subi.l #$33333333, (a7)+ uses Op049f ----------
Op049f:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04a0] subi.l #$33333333, -(a0) uses Op04a0 ----------
Op04a0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04a7] subi.l #$33333333, -(a7) uses Op04a7 ----------
Op04a7:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04a8] subi.l #$33333333, ($3333,a0) uses Op04a8 ----------
Op04a8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04b0] subi.l #$33333333, ($33,a0,d3.w*2) uses Op04b0 ----------
Op04b0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04b8] subi.l #$33333333, $3333.w uses Op04b8 ----------
Op04b8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04b9] subi.l #$33333333, $33333333.l uses Op04b9 ----------
Op04b9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0600] addi.b #$33, d0 uses Op0600 ----------
Op0600:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldrb r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0610] addi.b #$33, (a0) uses Op0610 ----------
Op0610:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0618] addi.b #$33, (a0)+ uses Op0618 ----------
Op0618:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [061f] addi.b #$33, (a7)+ uses Op061f ----------
Op061f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0620] addi.b #$33, -(a0) uses Op0620 ----------
Op0620:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0627] addi.b #$33, -(a7) uses Op0627 ----------
Op0627:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0628] addi.b #$33, ($3333,a0) uses Op0628 ----------
Op0628:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0630] addi.b #$33, ($33,a0,d3.w*2) uses Op0630 ----------
Op0630:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0638] addi.b #$33, $3333.w uses Op0638 ----------
Op0638:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0639] addi.b #$33, $33333333.l uses Op0639 ----------
Op0639:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0640] addi.w #$3333, d0 uses Op0640 ----------
Op0640:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsh r0,[r7,r11]
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0650] addi.w #$3333, (a0) uses Op0650 ----------
Op0650:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0658] addi.w #$3333, (a0)+ uses Op0658 ----------
Op0658:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [065f] addi.w #$3333, (a7)+ uses Op065f ----------
Op065f:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0660] addi.w #$3333, -(a0) uses Op0660 ----------
Op0660:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0667] addi.w #$3333, -(a7) uses Op0667 ----------
Op0667:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0668] addi.w #$3333, ($3333,a0) uses Op0668 ----------
Op0668:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0670] addi.w #$3333, ($33,a0,d3.w*2) uses Op0670 ----------
Op0670:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0678] addi.w #$3333, $3333.w uses Op0678 ----------
Op0678:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0679] addi.w #$3333, $33333333.l uses Op0679 ----------
Op0679:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0680] addi.l #$33333333, d0 uses Op0680 ----------
Op0680:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0690] addi.l #$33333333, (a0) uses Op0690 ----------
Op0690:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0698] addi.l #$33333333, (a0)+ uses Op0698 ----------
Op0698:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [069f] addi.l #$33333333, (a7)+ uses Op069f ----------
Op069f:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06a0] addi.l #$33333333, -(a0) uses Op06a0 ----------
Op06a0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06a7] addi.l #$33333333, -(a7) uses Op06a7 ----------
Op06a7:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06a8] addi.l #$33333333, ($3333,a0) uses Op06a8 ----------
Op06a8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06b0] addi.l #$33333333, ($33,a0,d3.w*2) uses Op06b0 ----------
Op06b0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06b8] addi.l #$33333333, $3333.w uses Op06b8 ----------
Op06b8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06b9] addi.l #$33333333, $33333333.l uses Op06b9 ----------
Op06b9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0800] btst #$33, d0 uses Op0800 ----------
Op0800:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0810] btst #$33, (a0) uses Op0810 ----------
Op0810:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0818] btst #$33, (a0)+ uses Op0818 ----------
Op0818:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [081f] btst #$33, (a7)+ uses Op081f ----------
Op081f:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0820] btst #$33, -(a0) uses Op0820 ----------
Op0820:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0827] btst #$33, -(a7) uses Op0827 ----------
Op0827:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0828] btst #$33, ($3333,a0) uses Op0828 ----------
Op0828:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0830] btst #$33, ($33,a0,d3.w*2) uses Op0830 ----------
Op0830:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0838] btst #$33, $3333.w uses Op0838 ----------
Op0838:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0839] btst #$33, $33333333.l uses Op0839 ----------
Op0839:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [083a] btst #$33, ($3333,pc); =3337 uses Op083a ----------
Op083a:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r11,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [083b] btst #$33, ($33,pc,d3.w*2); =37 uses Op083b ----------
Op083b:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r11,r2,r0,asr #8 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0840] bchg #$33, d0 uses Op0840 ----------
Op0840:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0850] bchg #$33, (a0) uses Op0850 ----------
Op0850:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0858] bchg #$33, (a0)+ uses Op0858 ----------
Op0858:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [085f] bchg #$33, (a7)+ uses Op085f ----------
Op085f:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0860] bchg #$33, -(a0) uses Op0860 ----------
Op0860:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0867] bchg #$33, -(a7) uses Op0867 ----------
Op0867:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0868] bchg #$33, ($3333,a0) uses Op0868 ----------
Op0868:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0870] bchg #$33, ($33,a0,d3.w*2) uses Op0870 ----------
Op0870:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0878] bchg #$33, $3333.w uses Op0878 ----------
Op0878:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0879] bchg #$33, $33333333.l uses Op0879 ----------
Op0879:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0880] bclr #$33, d0 uses Op0880 ----------
Op0880:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0890] bclr #$33, (a0) uses Op0890 ----------
Op0890:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0898] bclr #$33, (a0)+ uses Op0898 ----------
Op0898:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [089f] bclr #$33, (a7)+ uses Op089f ----------
Op089f:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08a0] bclr #$33, -(a0) uses Op08a0 ----------
Op08a0:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08a7] bclr #$33, -(a7) uses Op08a7 ----------
Op08a7:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08a8] bclr #$33, ($3333,a0) uses Op08a8 ----------
Op08a8:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08b0] bclr #$33, ($33,a0,d3.w*2) uses Op08b0 ----------
Op08b0:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08b8] bclr #$33, $3333.w uses Op08b8 ----------
Op08b8:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08b9] bclr #$33, $33333333.l uses Op08b9 ----------
Op08b9:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08c0] bset #$33, d0 uses Op08c0 ----------
Op08c0:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08d0] bset #$33, (a0) uses Op08d0 ----------
Op08d0:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08d8] bset #$33, (a0)+ uses Op08d8 ----------
Op08d8:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08df] bset #$33, (a7)+ uses Op08df ----------
Op08df:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08e0] bset #$33, -(a0) uses Op08e0 ----------
Op08e0:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08e7] bset #$33, -(a7) uses Op08e7 ----------
Op08e7:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08e8] bset #$33, ($3333,a0) uses Op08e8 ----------
Op08e8:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08f0] bset #$33, ($33,a0,d3.w*2) uses Op08f0 ----------
Op08f0:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08f8] bset #$33, $3333.w uses Op08f8 ----------
Op08f8:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08f9] bset #$33, $33333333.l uses Op08f9 ----------
Op08f9:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a00] eori.b #$33, d0 uses Op0a00 ----------
Op0a00:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldrb r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a10] eori.b #$33, (a0) uses Op0a10 ----------
Op0a10:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a18] eori.b #$33, (a0)+ uses Op0a18 ----------
Op0a18:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a1f] eori.b #$33, (a7)+ uses Op0a1f ----------
Op0a1f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a20] eori.b #$33, -(a0) uses Op0a20 ----------
Op0a20:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a27] eori.b #$33, -(a7) uses Op0a27 ----------
Op0a27:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a28] eori.b #$33, ($3333,a0) uses Op0a28 ----------
Op0a28:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a30] eori.b #$33, ($33,a0,d3.w*2) uses Op0a30 ----------
Op0a30:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a38] eori.b #$33, $3333.w uses Op0a38 ----------
Op0a38:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a39] eori.b #$33, $33333333.l uses Op0a39 ----------
Op0a39:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a3c] eori.b #$33, ccr uses Op0a3c ----------
Op0a3c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r10:
  mov r10,r0,asl #0

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  eor r0,r1,r10
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a40] eori.w #$3333, d0 uses Op0a40 ----------
Op0a40:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsh r0,[r7,r11]
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a50] eori.w #$3333, (a0) uses Op0a50 ----------
Op0a50:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a58] eori.w #$3333, (a0)+ uses Op0a58 ----------
Op0a58:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a5f] eori.w #$3333, (a7)+ uses Op0a5f ----------
Op0a5f:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a60] eori.w #$3333, -(a0) uses Op0a60 ----------
Op0a60:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a67] eori.w #$3333, -(a7) uses Op0a67 ----------
Op0a67:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a68] eori.w #$3333, ($3333,a0) uses Op0a68 ----------
Op0a68:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a70] eori.w #$3333, ($33,a0,d3.w*2) uses Op0a70 ----------
Op0a70:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a78] eori.w #$3333, $3333.w uses Op0a78 ----------
Op0a78:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a79] eori.w #$3333, $33333333.l uses Op0a79 ----------
Op0a79:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a7c] eori.w #$3333, sr uses Op0a7c ----------
Op0a7c:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode0a7c ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r10:
  mov r10,r0,asl #0

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  eor r0,r1,r10
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap0a7c
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap0a7c:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoIntsa7c
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoIntsa7c:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode0a7c:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a80] eori.l #$33333333, d0 uses Op0a80 ----------
Op0a80:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a90] eori.l #$33333333, (a0) uses Op0a90 ----------
Op0a90:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a98] eori.l #$33333333, (a0)+ uses Op0a98 ----------
Op0a98:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a9f] eori.l #$33333333, (a7)+ uses Op0a9f ----------
Op0a9f:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0aa0] eori.l #$33333333, -(a0) uses Op0aa0 ----------
Op0aa0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0aa7] eori.l #$33333333, -(a7) uses Op0aa7 ----------
Op0aa7:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0aa8] eori.l #$33333333, ($3333,a0) uses Op0aa8 ----------
Op0aa8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ab0] eori.l #$33333333, ($33,a0,d3.w*2) uses Op0ab0 ----------
Op0ab0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ab8] eori.l #$33333333, $3333.w uses Op0ab8 ----------
Op0ab8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ab9] eori.l #$33333333, $33333333.l uses Op0ab9 ----------
Op0ab9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c00] cmpi.b #$33, d0 uses Op0c00 ----------
Op0c00:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldrb r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c10] cmpi.b #$33, (a0) uses Op0c10 ----------
Op0c10:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c18] cmpi.b #$33, (a0)+ uses Op0c18 ----------
Op0c18:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c1f] cmpi.b #$33, (a7)+ uses Op0c1f ----------
Op0c1f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c20] cmpi.b #$33, -(a0) uses Op0c20 ----------
Op0c20:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c27] cmpi.b #$33, -(a7) uses Op0c27 ----------
Op0c27:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c28] cmpi.b #$33, ($3333,a0) uses Op0c28 ----------
Op0c28:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c30] cmpi.b #$33, ($33,a0,d3.w*2) uses Op0c30 ----------
Op0c30:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c38] cmpi.b #$33, $3333.w uses Op0c38 ----------
Op0c38:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c39] cmpi.b #$33, $33333333.l uses Op0c39 ----------
Op0c39:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c40] cmpi.w #$3333, d0 uses Op0c40 ----------
Op0c40:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsh r0,[r7,r11]
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c50] cmpi.w #$3333, (a0) uses Op0c50 ----------
Op0c50:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c58] cmpi.w #$3333, (a0)+ uses Op0c58 ----------
Op0c58:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c5f] cmpi.w #$3333, (a7)+ uses Op0c5f ----------
Op0c5f:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c60] cmpi.w #$3333, -(a0) uses Op0c60 ----------
Op0c60:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c67] cmpi.w #$3333, -(a7) uses Op0c67 ----------
Op0c67:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c68] cmpi.w #$3333, ($3333,a0) uses Op0c68 ----------
Op0c68:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c70] cmpi.w #$3333, ($33,a0,d3.w*2) uses Op0c70 ----------
Op0c70:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c78] cmpi.w #$3333, $3333.w uses Op0c78 ----------
Op0c78:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c79] cmpi.w #$3333, $33333333.l uses Op0c79 ----------
Op0c79:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c80] cmpi.l #$33333333, d0 uses Op0c80 ----------
Op0c80:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c90] cmpi.l #$33333333, (a0) uses Op0c90 ----------
Op0c90:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c98] cmpi.l #$33333333, (a0)+ uses Op0c98 ----------
Op0c98:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c9f] cmpi.l #$33333333, (a7)+ uses Op0c9f ----------
Op0c9f:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ca0] cmpi.l #$33333333, -(a0) uses Op0ca0 ----------
Op0ca0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ca7] cmpi.l #$33333333, -(a7) uses Op0ca7 ----------
Op0ca7:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ca8] cmpi.l #$33333333, ($3333,a0) uses Op0ca8 ----------
Op0ca8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cb0] cmpi.l #$33333333, ($33,a0,d3.w*2) uses Op0cb0 ----------
Op0cb0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cb8] cmpi.l #$33333333, $3333.w uses Op0cb8 ----------
Op0cb8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cb9] cmpi.l #$33333333, $33333333.l uses Op0cb9 ----------
Op0cb9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1000] move.b d0, d0 uses Op1000 ----------
Op1000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1010] move.b (a0), d0 uses Op1010 ----------
Op1010:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1018] move.b (a0)+, d0 uses Op1018 ----------
Op1018:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [101f] move.b (a7)+, d0 uses Op101f ----------
Op101f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1020] move.b -(a0), d0 uses Op1020 ----------
Op1020:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1027] move.b -(a7), d0 uses Op1027 ----------
Op1027:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1028] move.b ($3333,a0), d0 uses Op1028 ----------
Op1028:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1030] move.b ($33,a0,d3.w*2), d0 uses Op1030 ----------
Op1030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1038] move.b $3333.w, d0 uses Op1038 ----------
Op1038:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1039] move.b $33333333.l, d0 uses Op1039 ----------
Op1039:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [103a] move.b ($3333,pc), d0; =3335 uses Op103a ----------
Op103a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [103b] move.b ($33,pc,d3.w*2), d0; =35 uses Op103b ----------
Op103b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [103c] move.b #$33, d0 uses Op103c ----------
Op103c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1080] move.b d0, (a0) uses Op1080 ----------
Op1080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1090] move.b (a0), (a0) uses Op1090 ----------
Op1090:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1098] move.b (a0)+, (a0) uses Op1098 ----------
Op1098:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [109f] move.b (a7)+, (a0) uses Op109f ----------
Op109f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10a0] move.b -(a0), (a0) uses Op10a0 ----------
Op10a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10a7] move.b -(a7), (a0) uses Op10a7 ----------
Op10a7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10a8] move.b ($3333,a0), (a0) uses Op10a8 ----------
Op10a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10b0] move.b ($33,a0,d3.w*2), (a0) uses Op10b0 ----------
Op10b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10b8] move.b $3333.w, (a0) uses Op10b8 ----------
Op10b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10b9] move.b $33333333.l, (a0) uses Op10b9 ----------
Op10b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10ba] move.b ($3333,pc), (a0); =3335 uses Op10ba ----------
Op10ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10bb] move.b ($33,pc,d3.w*2), (a0); =35 uses Op10bb ----------
Op10bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10bc] move.b #$33, (a0) uses Op10bc ----------
Op10bc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10c0] move.b d0, (a0)+ uses Op10c0 ----------
Op10c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10d0] move.b (a0), (a0)+ uses Op10d0 ----------
Op10d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10d8] move.b (a0)+, (a0)+ uses Op10d8 ----------
Op10d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10df] move.b (a7)+, (a0)+ uses Op10df ----------
Op10df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10e0] move.b -(a0), (a0)+ uses Op10e0 ----------
Op10e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10e7] move.b -(a7), (a0)+ uses Op10e7 ----------
Op10e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10e8] move.b ($3333,a0), (a0)+ uses Op10e8 ----------
Op10e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10f0] move.b ($33,a0,d3.w*2), (a0)+ uses Op10f0 ----------
Op10f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10f8] move.b $3333.w, (a0)+ uses Op10f8 ----------
Op10f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10f9] move.b $33333333.l, (a0)+ uses Op10f9 ----------
Op10f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10fa] move.b ($3333,pc), (a0)+; =3335 uses Op10fa ----------
Op10fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10fb] move.b ($33,pc,d3.w*2), (a0)+; =35 uses Op10fb ----------
Op10fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10fc] move.b #$33, (a0)+ uses Op10fc ----------
Op10fc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1100] move.b d0, -(a0) uses Op1100 ----------
Op1100:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1110] move.b (a0), -(a0) uses Op1110 ----------
Op1110:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1118] move.b (a0)+, -(a0) uses Op1118 ----------
Op1118:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [111f] move.b (a7)+, -(a0) uses Op111f ----------
Op111f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1120] move.b -(a0), -(a0) uses Op1120 ----------
Op1120:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1127] move.b -(a7), -(a0) uses Op1127 ----------
Op1127:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1128] move.b ($3333,a0), -(a0) uses Op1128 ----------
Op1128:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1130] move.b ($33,a0,d3.w*2), -(a0) uses Op1130 ----------
Op1130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1138] move.b $3333.w, -(a0) uses Op1138 ----------
Op1138:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1139] move.b $33333333.l, -(a0) uses Op1139 ----------
Op1139:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [113a] move.b ($3333,pc), -(a0); =3335 uses Op113a ----------
Op113a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [113b] move.b ($33,pc,d3.w*2), -(a0); =35 uses Op113b ----------
Op113b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [113c] move.b #$33, -(a0) uses Op113c ----------
Op113c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1140] move.b d0, ($3333,a0) uses Op1140 ----------
Op1140:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1150] move.b (a0), ($3333,a0) uses Op1150 ----------
Op1150:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1158] move.b (a0)+, ($3333,a0) uses Op1158 ----------
Op1158:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [115f] move.b (a7)+, ($3333,a0) uses Op115f ----------
Op115f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1160] move.b -(a0), ($3333,a0) uses Op1160 ----------
Op1160:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1167] move.b -(a7), ($3333,a0) uses Op1167 ----------
Op1167:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1168] move.b ($3333,a0), ($3333,a0) uses Op1168 ----------
Op1168:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1170] move.b ($33,a0,d3.w*2), ($3333,a0) uses Op1170 ----------
Op1170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1178] move.b $3333.w, ($3333,a0) uses Op1178 ----------
Op1178:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1179] move.b $33333333.l, ($3333,a0) uses Op1179 ----------
Op1179:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [117a] move.b ($3333,pc), ($3333,a0); =3335 uses Op117a ----------
Op117a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [117b] move.b ($33,pc,d3.w*2), ($3333,a0); =35 uses Op117b ----------
Op117b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [117c] move.b #$33, ($3333,a0) uses Op117c ----------
Op117c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1180] move.b d0, ($33,a0,d3.w*2) uses Op1180 ----------
Op1180:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1190] move.b (a0), ($33,a0,d3.w*2) uses Op1190 ----------
Op1190:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1198] move.b (a0)+, ($33,a0,d3.w*2) uses Op1198 ----------
Op1198:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [119f] move.b (a7)+, ($33,a0,d3.w*2) uses Op119f ----------
Op119f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11a0] move.b -(a0), ($33,a0,d3.w*2) uses Op11a0 ----------
Op11a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11a7] move.b -(a7), ($33,a0,d3.w*2) uses Op11a7 ----------
Op11a7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11a8] move.b ($3333,a0), ($33,a0,d3.w*2) uses Op11a8 ----------
Op11a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11b0] move.b ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op11b0 ----------
Op11b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11b8] move.b $3333.w, ($33,a0,d3.w*2) uses Op11b8 ----------
Op11b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11b9] move.b $33333333.l, ($33,a0,d3.w*2) uses Op11b9 ----------
Op11b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11ba] move.b ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op11ba ----------
Op11ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11bb] move.b ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op11bb ----------
Op11bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11bc] move.b #$33, ($33,a0,d3.w*2) uses Op11bc ----------
Op11bc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11c0] move.b d0, $3333.w uses Op11c0 ----------
Op11c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11d0] move.b (a0), $3333.w uses Op11d0 ----------
Op11d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11d8] move.b (a0)+, $3333.w uses Op11d8 ----------
Op11d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11df] move.b (a7)+, $3333.w uses Op11df ----------
Op11df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11e0] move.b -(a0), $3333.w uses Op11e0 ----------
Op11e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11e7] move.b -(a7), $3333.w uses Op11e7 ----------
Op11e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11e8] move.b ($3333,a0), $3333.w uses Op11e8 ----------
Op11e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11f0] move.b ($33,a0,d3.w*2), $3333.w uses Op11f0 ----------
Op11f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11f8] move.b $3333.w, $3333.w uses Op11f8 ----------
Op11f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11f9] move.b $33333333.l, $3333.w uses Op11f9 ----------
Op11f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11fa] move.b ($3333,pc), $3333.w; =3335 uses Op11fa ----------
Op11fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11fb] move.b ($33,pc,d3.w*2), $3333.w; =35 uses Op11fb ----------
Op11fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11fc] move.b #$33, $3333.w uses Op11fc ----------
Op11fc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13c0] move.b d0, $33333333.l uses Op13c0 ----------
Op13c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13d0] move.b (a0), $33333333.l uses Op13d0 ----------
Op13d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13d8] move.b (a0)+, $33333333.l uses Op13d8 ----------
Op13d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13df] move.b (a7)+, $33333333.l uses Op13df ----------
Op13df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13e0] move.b -(a0), $33333333.l uses Op13e0 ----------
Op13e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13e7] move.b -(a7), $33333333.l uses Op13e7 ----------
Op13e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13e8] move.b ($3333,a0), $33333333.l uses Op13e8 ----------
Op13e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13f0] move.b ($33,a0,d3.w*2), $33333333.l uses Op13f0 ----------
Op13f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13f8] move.b $3333.w, $33333333.l uses Op13f8 ----------
Op13f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13f9] move.b $33333333.l, $33333333.l uses Op13f9 ----------
Op13f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13fa] move.b ($3333,pc), $33333333.l; =3335 uses Op13fa ----------
Op13fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13fb] move.b ($33,pc,d3.w*2), $33333333.l; =35 uses Op13fb ----------
Op13fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13fc] move.b #$33, $33333333.l uses Op13fc ----------
Op13fc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ec0] move.b d0, (a7)+ uses Op1ec0 ----------
Op1ec0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ed0] move.b (a0), (a7)+ uses Op1ed0 ----------
Op1ed0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ed8] move.b (a0)+, (a7)+ uses Op1ed8 ----------
Op1ed8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1edf] move.b (a7)+, (a7)+ uses Op1edf ----------
Op1edf:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ee0] move.b -(a0), (a7)+ uses Op1ee0 ----------
Op1ee0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ee7] move.b -(a7), (a7)+ uses Op1ee7 ----------
Op1ee7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ee8] move.b ($3333,a0), (a7)+ uses Op1ee8 ----------
Op1ee8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ef0] move.b ($33,a0,d3.w*2), (a7)+ uses Op1ef0 ----------
Op1ef0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ef8] move.b $3333.w, (a7)+ uses Op1ef8 ----------
Op1ef8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ef9] move.b $33333333.l, (a7)+ uses Op1ef9 ----------
Op1ef9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1efa] move.b ($3333,pc), (a7)+; =3335 uses Op1efa ----------
Op1efa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1efb] move.b ($33,pc,d3.w*2), (a7)+; =35 uses Op1efb ----------
Op1efb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1efc] move.b #$33, (a7)+ uses Op1efc ----------
Op1efc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f00] move.b d0, -(a7) uses Op1f00 ----------
Op1f00:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f10] move.b (a0), -(a7) uses Op1f10 ----------
Op1f10:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f18] move.b (a0)+, -(a7) uses Op1f18 ----------
Op1f18:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f1f] move.b (a7)+, -(a7) uses Op1f1f ----------
Op1f1f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f20] move.b -(a0), -(a7) uses Op1f20 ----------
Op1f20:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f27] move.b -(a7), -(a7) uses Op1f27 ----------
Op1f27:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f28] move.b ($3333,a0), -(a7) uses Op1f28 ----------
Op1f28:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f30] move.b ($33,a0,d3.w*2), -(a7) uses Op1f30 ----------
Op1f30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f38] move.b $3333.w, -(a7) uses Op1f38 ----------
Op1f38:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f39] move.b $33333333.l, -(a7) uses Op1f39 ----------
Op1f39:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f3a] move.b ($3333,pc), -(a7); =3335 uses Op1f3a ----------
Op1f3a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f3b] move.b ($33,pc,d3.w*2), -(a7); =35 uses Op1f3b ----------
Op1f3b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f3c] move.b #$33, -(a7) uses Op1f3c ----------
Op1f3c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2000] move.l d0, d0 uses Op2000 ----------
Op2000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2010] move.l (a0), d0 uses Op2010 ----------
Op2010:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2018] move.l (a0)+, d0 uses Op2018 ----------
Op2018:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [201f] move.l (a7)+, d0 uses Op201f ----------
Op201f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2020] move.l -(a0), d0 uses Op2020 ----------
Op2020:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2027] move.l -(a7), d0 uses Op2027 ----------
Op2027:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2028] move.l ($3333,a0), d0 uses Op2028 ----------
Op2028:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2030] move.l ($33,a0,d3.w*2), d0 uses Op2030 ----------
Op2030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2038] move.l $3333.w, d0 uses Op2038 ----------
Op2038:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2039] move.l $33333333.l, d0 uses Op2039 ----------
Op2039:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [203a] move.l ($3333,pc), d0; =3335 uses Op203a ----------
Op203a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [203b] move.l ($33,pc,d3.w*2), d0; =35 uses Op203b ----------
Op203b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [203c] move.l #$33333333, d0 uses Op203c ----------
Op203c:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2040] movea.l d0, a0 uses Op2040 ----------
Op2040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2050] movea.l (a0), a0 uses Op2050 ----------
Op2050:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2058] movea.l (a0)+, a0 uses Op2058 ----------
Op2058:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [205f] movea.l (a7)+, a0 uses Op205f ----------
Op205f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2060] movea.l -(a0), a0 uses Op2060 ----------
Op2060:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2067] movea.l -(a7), a0 uses Op2067 ----------
Op2067:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2068] movea.l ($3333,a0), a0 uses Op2068 ----------
Op2068:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2070] movea.l ($33,a0,d3.w*2), a0 uses Op2070 ----------
Op2070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2078] movea.l $3333.w, a0 uses Op2078 ----------
Op2078:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2079] movea.l $33333333.l, a0 uses Op2079 ----------
Op2079:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [207a] movea.l ($3333,pc), a0; =3335 uses Op207a ----------
Op207a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [207b] movea.l ($33,pc,d3.w*2), a0; =35 uses Op207b ----------
Op207b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [207c] movea.l #$33333333, a0 uses Op207c ----------
Op207c:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r1:
  mov r1,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2080] move.l d0, (a0) uses Op2080 ----------
Op2080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2090] move.l (a0), (a0) uses Op2090 ----------
Op2090:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2098] move.l (a0)+, (a0) uses Op2098 ----------
Op2098:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [209f] move.l (a7)+, (a0) uses Op209f ----------
Op209f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20a0] move.l -(a0), (a0) uses Op20a0 ----------
Op20a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20a7] move.l -(a7), (a0) uses Op20a7 ----------
Op20a7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20a8] move.l ($3333,a0), (a0) uses Op20a8 ----------
Op20a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20b0] move.l ($33,a0,d3.w*2), (a0) uses Op20b0 ----------
Op20b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20b8] move.l $3333.w, (a0) uses Op20b8 ----------
Op20b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20b9] move.l $33333333.l, (a0) uses Op20b9 ----------
Op20b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20ba] move.l ($3333,pc), (a0); =3335 uses Op20ba ----------
Op20ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20bb] move.l ($33,pc,d3.w*2), (a0); =35 uses Op20bb ----------
Op20bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20bc] move.l #$33333333, (a0) uses Op20bc ----------
Op20bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20c0] move.l d0, (a0)+ uses Op20c0 ----------
Op20c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20d0] move.l (a0), (a0)+ uses Op20d0 ----------
Op20d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20d8] move.l (a0)+, (a0)+ uses Op20d8 ----------
Op20d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20df] move.l (a7)+, (a0)+ uses Op20df ----------
Op20df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20e0] move.l -(a0), (a0)+ uses Op20e0 ----------
Op20e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20e7] move.l -(a7), (a0)+ uses Op20e7 ----------
Op20e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20e8] move.l ($3333,a0), (a0)+ uses Op20e8 ----------
Op20e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20f0] move.l ($33,a0,d3.w*2), (a0)+ uses Op20f0 ----------
Op20f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20f8] move.l $3333.w, (a0)+ uses Op20f8 ----------
Op20f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20f9] move.l $33333333.l, (a0)+ uses Op20f9 ----------
Op20f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20fa] move.l ($3333,pc), (a0)+; =3335 uses Op20fa ----------
Op20fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20fb] move.l ($33,pc,d3.w*2), (a0)+; =35 uses Op20fb ----------
Op20fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20fc] move.l #$33333333, (a0)+ uses Op20fc ----------
Op20fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2100] move.l d0, -(a0) uses Op2100 ----------
Op2100:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2110] move.l (a0), -(a0) uses Op2110 ----------
Op2110:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2118] move.l (a0)+, -(a0) uses Op2118 ----------
Op2118:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [211f] move.l (a7)+, -(a0) uses Op211f ----------
Op211f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2120] move.l -(a0), -(a0) uses Op2120 ----------
Op2120:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2127] move.l -(a7), -(a0) uses Op2127 ----------
Op2127:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2128] move.l ($3333,a0), -(a0) uses Op2128 ----------
Op2128:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2130] move.l ($33,a0,d3.w*2), -(a0) uses Op2130 ----------
Op2130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2138] move.l $3333.w, -(a0) uses Op2138 ----------
Op2138:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2139] move.l $33333333.l, -(a0) uses Op2139 ----------
Op2139:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [213a] move.l ($3333,pc), -(a0); =3335 uses Op213a ----------
Op213a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [213b] move.l ($33,pc,d3.w*2), -(a0); =35 uses Op213b ----------
Op213b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [213c] move.l #$33333333, -(a0) uses Op213c ----------
Op213c:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2140] move.l d0, ($3333,a0) uses Op2140 ----------
Op2140:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2150] move.l (a0), ($3333,a0) uses Op2150 ----------
Op2150:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2158] move.l (a0)+, ($3333,a0) uses Op2158 ----------
Op2158:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [215f] move.l (a7)+, ($3333,a0) uses Op215f ----------
Op215f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2160] move.l -(a0), ($3333,a0) uses Op2160 ----------
Op2160:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2167] move.l -(a7), ($3333,a0) uses Op2167 ----------
Op2167:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2168] move.l ($3333,a0), ($3333,a0) uses Op2168 ----------
Op2168:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2170] move.l ($33,a0,d3.w*2), ($3333,a0) uses Op2170 ----------
Op2170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2178] move.l $3333.w, ($3333,a0) uses Op2178 ----------
Op2178:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2179] move.l $33333333.l, ($3333,a0) uses Op2179 ----------
Op2179:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [217a] move.l ($3333,pc), ($3333,a0); =3335 uses Op217a ----------
Op217a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [217b] move.l ($33,pc,d3.w*2), ($3333,a0); =35 uses Op217b ----------
Op217b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [217c] move.l #$33333333, ($3333,a0) uses Op217c ----------
Op217c:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2180] move.l d0, ($33,a0,d3.w*2) uses Op2180 ----------
Op2180:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2190] move.l (a0), ($33,a0,d3.w*2) uses Op2190 ----------
Op2190:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2198] move.l (a0)+, ($33,a0,d3.w*2) uses Op2198 ----------
Op2198:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [219f] move.l (a7)+, ($33,a0,d3.w*2) uses Op219f ----------
Op219f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21a0] move.l -(a0), ($33,a0,d3.w*2) uses Op21a0 ----------
Op21a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21a7] move.l -(a7), ($33,a0,d3.w*2) uses Op21a7 ----------
Op21a7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21a8] move.l ($3333,a0), ($33,a0,d3.w*2) uses Op21a8 ----------
Op21a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21b0] move.l ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op21b0 ----------
Op21b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21b8] move.l $3333.w, ($33,a0,d3.w*2) uses Op21b8 ----------
Op21b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21b9] move.l $33333333.l, ($33,a0,d3.w*2) uses Op21b9 ----------
Op21b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21ba] move.l ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op21ba ----------
Op21ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21bb] move.l ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op21bb ----------
Op21bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21bc] move.l #$33333333, ($33,a0,d3.w*2) uses Op21bc ----------
Op21bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21c0] move.l d0, $3333.w uses Op21c0 ----------
Op21c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21d0] move.l (a0), $3333.w uses Op21d0 ----------
Op21d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21d8] move.l (a0)+, $3333.w uses Op21d8 ----------
Op21d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21df] move.l (a7)+, $3333.w uses Op21df ----------
Op21df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21e0] move.l -(a0), $3333.w uses Op21e0 ----------
Op21e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21e7] move.l -(a7), $3333.w uses Op21e7 ----------
Op21e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21e8] move.l ($3333,a0), $3333.w uses Op21e8 ----------
Op21e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21f0] move.l ($33,a0,d3.w*2), $3333.w uses Op21f0 ----------
Op21f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21f8] move.l $3333.w, $3333.w uses Op21f8 ----------
Op21f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21f9] move.l $33333333.l, $3333.w uses Op21f9 ----------
Op21f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21fa] move.l ($3333,pc), $3333.w; =3335 uses Op21fa ----------
Op21fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21fb] move.l ($33,pc,d3.w*2), $3333.w; =35 uses Op21fb ----------
Op21fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21fc] move.l #$33333333, $3333.w uses Op21fc ----------
Op21fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23c0] move.l d0, $33333333.l uses Op23c0 ----------
Op23c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23d0] move.l (a0), $33333333.l uses Op23d0 ----------
Op23d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23d8] move.l (a0)+, $33333333.l uses Op23d8 ----------
Op23d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23df] move.l (a7)+, $33333333.l uses Op23df ----------
Op23df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23e0] move.l -(a0), $33333333.l uses Op23e0 ----------
Op23e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23e7] move.l -(a7), $33333333.l uses Op23e7 ----------
Op23e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23e8] move.l ($3333,a0), $33333333.l uses Op23e8 ----------
Op23e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23f0] move.l ($33,a0,d3.w*2), $33333333.l uses Op23f0 ----------
Op23f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23f8] move.l $3333.w, $33333333.l uses Op23f8 ----------
Op23f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23f9] move.l $33333333.l, $33333333.l uses Op23f9 ----------
Op23f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23fa] move.l ($3333,pc), $33333333.l; =3335 uses Op23fa ----------
Op23fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23fb] move.l ($33,pc,d3.w*2), $33333333.l; =35 uses Op23fb ----------
Op23fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23fc] move.l #$33333333, $33333333.l uses Op23fc ----------
Op23fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ec0] move.l d0, (a7)+ uses Op2ec0 ----------
Op2ec0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ed0] move.l (a0), (a7)+ uses Op2ed0 ----------
Op2ed0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ed8] move.l (a0)+, (a7)+ uses Op2ed8 ----------
Op2ed8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2edf] move.l (a7)+, (a7)+ uses Op2edf ----------
Op2edf:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ee0] move.l -(a0), (a7)+ uses Op2ee0 ----------
Op2ee0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ee7] move.l -(a7), (a7)+ uses Op2ee7 ----------
Op2ee7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ee8] move.l ($3333,a0), (a7)+ uses Op2ee8 ----------
Op2ee8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ef0] move.l ($33,a0,d3.w*2), (a7)+ uses Op2ef0 ----------
Op2ef0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ef8] move.l $3333.w, (a7)+ uses Op2ef8 ----------
Op2ef8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ef9] move.l $33333333.l, (a7)+ uses Op2ef9 ----------
Op2ef9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2efa] move.l ($3333,pc), (a7)+; =3335 uses Op2efa ----------
Op2efa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2efb] move.l ($33,pc,d3.w*2), (a7)+; =35 uses Op2efb ----------
Op2efb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2efc] move.l #$33333333, (a7)+ uses Op2efc ----------
Op2efc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f00] move.l d0, -(a7) uses Op2f00 ----------
Op2f00:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f10] move.l (a0), -(a7) uses Op2f10 ----------
Op2f10:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f18] move.l (a0)+, -(a7) uses Op2f18 ----------
Op2f18:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f1f] move.l (a7)+, -(a7) uses Op2f1f ----------
Op2f1f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f20] move.l -(a0), -(a7) uses Op2f20 ----------
Op2f20:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f27] move.l -(a7), -(a7) uses Op2f27 ----------
Op2f27:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f28] move.l ($3333,a0), -(a7) uses Op2f28 ----------
Op2f28:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f30] move.l ($33,a0,d3.w*2), -(a7) uses Op2f30 ----------
Op2f30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f38] move.l $3333.w, -(a7) uses Op2f38 ----------
Op2f38:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f39] move.l $33333333.l, -(a7) uses Op2f39 ----------
Op2f39:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f3a] move.l ($3333,pc), -(a7); =3335 uses Op2f3a ----------
Op2f3a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f3b] move.l ($33,pc,d3.w*2), -(a7); =35 uses Op2f3b ----------
Op2f3b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f3c] move.l #$33333333, -(a7) uses Op2f3c ----------
Op2f3c:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
  mov r10,r0
  mov r11,r1
  add r0,r0,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r11,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3000] move.w d0, d0 uses Op3000 ----------
Op3000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3010] move.w (a0), d0 uses Op3010 ----------
Op3010:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3018] move.w (a0)+, d0 uses Op3018 ----------
Op3018:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [301f] move.w (a7)+, d0 uses Op301f ----------
Op301f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3020] move.w -(a0), d0 uses Op3020 ----------
Op3020:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3027] move.w -(a7), d0 uses Op3027 ----------
Op3027:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3028] move.w ($3333,a0), d0 uses Op3028 ----------
Op3028:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3030] move.w ($33,a0,d3.w*2), d0 uses Op3030 ----------
Op3030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3038] move.w $3333.w, d0 uses Op3038 ----------
Op3038:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3039] move.w $33333333.l, d0 uses Op3039 ----------
Op3039:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [303a] move.w ($3333,pc), d0; =3335 uses Op303a ----------
Op303a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [303b] move.w ($33,pc,d3.w*2), d0; =35 uses Op303b ----------
Op303b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [303c] move.w #$3333, d0 uses Op303c ----------
Op303c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3040] movea.w d0, a0 uses Op3040 ----------
Op3040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3050] movea.w (a0), a0 uses Op3050 ----------
Op3050:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3058] movea.w (a0)+, a0 uses Op3058 ----------
Op3058:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [305f] movea.w (a7)+, a0 uses Op305f ----------
Op305f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3060] movea.w -(a0), a0 uses Op3060 ----------
Op3060:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3067] movea.w -(a7), a0 uses Op3067 ----------
Op3067:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3068] movea.w ($3333,a0), a0 uses Op3068 ----------
Op3068:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3070] movea.w ($33,a0,d3.w*2), a0 uses Op3070 ----------
Op3070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3078] movea.w $3333.w, a0 uses Op3078 ----------
Op3078:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3079] movea.w $33333333.l, a0 uses Op3079 ----------
Op3079:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [307a] movea.w ($3333,pc), a0; =3335 uses Op307a ----------
Op307a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [307b] movea.w ($33,pc,d3.w*2), a0; =35 uses Op307b ----------
Op307b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [307c] movea.w #$3333, a0 uses Op307c ----------
Op307c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r1:
  mov r1,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3080] move.w d0, (a0) uses Op3080 ----------
Op3080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3090] move.w (a0), (a0) uses Op3090 ----------
Op3090:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3098] move.w (a0)+, (a0) uses Op3098 ----------
Op3098:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [309f] move.w (a7)+, (a0) uses Op309f ----------
Op309f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30a0] move.w -(a0), (a0) uses Op30a0 ----------
Op30a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30a7] move.w -(a7), (a0) uses Op30a7 ----------
Op30a7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30a8] move.w ($3333,a0), (a0) uses Op30a8 ----------
Op30a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30b0] move.w ($33,a0,d3.w*2), (a0) uses Op30b0 ----------
Op30b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30b8] move.w $3333.w, (a0) uses Op30b8 ----------
Op30b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30b9] move.w $33333333.l, (a0) uses Op30b9 ----------
Op30b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30ba] move.w ($3333,pc), (a0); =3335 uses Op30ba ----------
Op30ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30bb] move.w ($33,pc,d3.w*2), (a0); =35 uses Op30bb ----------
Op30bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30bc] move.w #$3333, (a0) uses Op30bc ----------
Op30bc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30c0] move.w d0, (a0)+ uses Op30c0 ----------
Op30c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30d0] move.w (a0), (a0)+ uses Op30d0 ----------
Op30d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30d8] move.w (a0)+, (a0)+ uses Op30d8 ----------
Op30d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30df] move.w (a7)+, (a0)+ uses Op30df ----------
Op30df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30e0] move.w -(a0), (a0)+ uses Op30e0 ----------
Op30e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30e7] move.w -(a7), (a0)+ uses Op30e7 ----------
Op30e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30e8] move.w ($3333,a0), (a0)+ uses Op30e8 ----------
Op30e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30f0] move.w ($33,a0,d3.w*2), (a0)+ uses Op30f0 ----------
Op30f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30f8] move.w $3333.w, (a0)+ uses Op30f8 ----------
Op30f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30f9] move.w $33333333.l, (a0)+ uses Op30f9 ----------
Op30f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30fa] move.w ($3333,pc), (a0)+; =3335 uses Op30fa ----------
Op30fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30fb] move.w ($33,pc,d3.w*2), (a0)+; =35 uses Op30fb ----------
Op30fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30fc] move.w #$3333, (a0)+ uses Op30fc ----------
Op30fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3100] move.w d0, -(a0) uses Op3100 ----------
Op3100:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3110] move.w (a0), -(a0) uses Op3110 ----------
Op3110:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3118] move.w (a0)+, -(a0) uses Op3118 ----------
Op3118:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [311f] move.w (a7)+, -(a0) uses Op311f ----------
Op311f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3120] move.w -(a0), -(a0) uses Op3120 ----------
Op3120:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3127] move.w -(a7), -(a0) uses Op3127 ----------
Op3127:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3128] move.w ($3333,a0), -(a0) uses Op3128 ----------
Op3128:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3130] move.w ($33,a0,d3.w*2), -(a0) uses Op3130 ----------
Op3130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3138] move.w $3333.w, -(a0) uses Op3138 ----------
Op3138:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3139] move.w $33333333.l, -(a0) uses Op3139 ----------
Op3139:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [313a] move.w ($3333,pc), -(a0); =3335 uses Op313a ----------
Op313a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [313b] move.w ($33,pc,d3.w*2), -(a0); =35 uses Op313b ----------
Op313b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [313c] move.w #$3333, -(a0) uses Op313c ----------
Op313c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3140] move.w d0, ($3333,a0) uses Op3140 ----------
Op3140:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3150] move.w (a0), ($3333,a0) uses Op3150 ----------
Op3150:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3158] move.w (a0)+, ($3333,a0) uses Op3158 ----------
Op3158:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [315f] move.w (a7)+, ($3333,a0) uses Op315f ----------
Op315f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3160] move.w -(a0), ($3333,a0) uses Op3160 ----------
Op3160:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3167] move.w -(a7), ($3333,a0) uses Op3167 ----------
Op3167:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3168] move.w ($3333,a0), ($3333,a0) uses Op3168 ----------
Op3168:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3170] move.w ($33,a0,d3.w*2), ($3333,a0) uses Op3170 ----------
Op3170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3178] move.w $3333.w, ($3333,a0) uses Op3178 ----------
Op3178:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3179] move.w $33333333.l, ($3333,a0) uses Op3179 ----------
Op3179:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [317a] move.w ($3333,pc), ($3333,a0); =3335 uses Op317a ----------
Op317a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [317b] move.w ($33,pc,d3.w*2), ($3333,a0); =35 uses Op317b ----------
Op317b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [317c] move.w #$3333, ($3333,a0) uses Op317c ----------
Op317c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3180] move.w d0, ($33,a0,d3.w*2) uses Op3180 ----------
Op3180:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3190] move.w (a0), ($33,a0,d3.w*2) uses Op3190 ----------
Op3190:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3198] move.w (a0)+, ($33,a0,d3.w*2) uses Op3198 ----------
Op3198:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [319f] move.w (a7)+, ($33,a0,d3.w*2) uses Op319f ----------
Op319f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31a0] move.w -(a0), ($33,a0,d3.w*2) uses Op31a0 ----------
Op31a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31a7] move.w -(a7), ($33,a0,d3.w*2) uses Op31a7 ----------
Op31a7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31a8] move.w ($3333,a0), ($33,a0,d3.w*2) uses Op31a8 ----------
Op31a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31b0] move.w ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op31b0 ----------
Op31b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31b8] move.w $3333.w, ($33,a0,d3.w*2) uses Op31b8 ----------
Op31b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31b9] move.w $33333333.l, ($33,a0,d3.w*2) uses Op31b9 ----------
Op31b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31ba] move.w ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op31ba ----------
Op31ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31bb] move.w ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op31bb ----------
Op31bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31bc] move.w #$3333, ($33,a0,d3.w*2) uses Op31bc ----------
Op31bc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31c0] move.w d0, $3333.w uses Op31c0 ----------
Op31c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31d0] move.w (a0), $3333.w uses Op31d0 ----------
Op31d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31d8] move.w (a0)+, $3333.w uses Op31d8 ----------
Op31d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31df] move.w (a7)+, $3333.w uses Op31df ----------
Op31df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31e0] move.w -(a0), $3333.w uses Op31e0 ----------
Op31e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31e7] move.w -(a7), $3333.w uses Op31e7 ----------
Op31e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31e8] move.w ($3333,a0), $3333.w uses Op31e8 ----------
Op31e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31f0] move.w ($33,a0,d3.w*2), $3333.w uses Op31f0 ----------
Op31f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31f8] move.w $3333.w, $3333.w uses Op31f8 ----------
Op31f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31f9] move.w $33333333.l, $3333.w uses Op31f9 ----------
Op31f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31fa] move.w ($3333,pc), $3333.w; =3335 uses Op31fa ----------
Op31fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31fb] move.w ($33,pc,d3.w*2), $3333.w; =35 uses Op31fb ----------
Op31fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31fc] move.w #$3333, $3333.w uses Op31fc ----------
Op31fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33c0] move.w d0, $33333333.l uses Op33c0 ----------
Op33c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33d0] move.w (a0), $33333333.l uses Op33d0 ----------
Op33d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33d8] move.w (a0)+, $33333333.l uses Op33d8 ----------
Op33d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33df] move.w (a7)+, $33333333.l uses Op33df ----------
Op33df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33e0] move.w -(a0), $33333333.l uses Op33e0 ----------
Op33e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33e7] move.w -(a7), $33333333.l uses Op33e7 ----------
Op33e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33e8] move.w ($3333,a0), $33333333.l uses Op33e8 ----------
Op33e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33f0] move.w ($33,a0,d3.w*2), $33333333.l uses Op33f0 ----------
Op33f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33f8] move.w $3333.w, $33333333.l uses Op33f8 ----------
Op33f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33f9] move.w $33333333.l, $33333333.l uses Op33f9 ----------
Op33f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33fa] move.w ($3333,pc), $33333333.l; =3335 uses Op33fa ----------
Op33fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33fb] move.w ($33,pc,d3.w*2), $33333333.l; =35 uses Op33fb ----------
Op33fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33fc] move.w #$3333, $33333333.l uses Op33fc ----------
Op33fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ec0] move.w d0, (a7)+ uses Op3ec0 ----------
Op3ec0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ed0] move.w (a0), (a7)+ uses Op3ed0 ----------
Op3ed0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ed8] move.w (a0)+, (a7)+ uses Op3ed8 ----------
Op3ed8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3edf] move.w (a7)+, (a7)+ uses Op3edf ----------
Op3edf:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ee0] move.w -(a0), (a7)+ uses Op3ee0 ----------
Op3ee0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ee7] move.w -(a7), (a7)+ uses Op3ee7 ----------
Op3ee7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ee8] move.w ($3333,a0), (a7)+ uses Op3ee8 ----------
Op3ee8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ef0] move.w ($33,a0,d3.w*2), (a7)+ uses Op3ef0 ----------
Op3ef0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ef8] move.w $3333.w, (a7)+ uses Op3ef8 ----------
Op3ef8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ef9] move.w $33333333.l, (a7)+ uses Op3ef9 ----------
Op3ef9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3efa] move.w ($3333,pc), (a7)+; =3335 uses Op3efa ----------
Op3efa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3efb] move.w ($33,pc,d3.w*2), (a7)+; =35 uses Op3efb ----------
Op3efb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3efc] move.w #$3333, (a7)+ uses Op3efc ----------
Op3efc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f00] move.w d0, -(a7) uses Op3f00 ----------
Op3f00:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f10] move.w (a0), -(a7) uses Op3f10 ----------
Op3f10:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f18] move.w (a0)+, -(a7) uses Op3f18 ----------
Op3f18:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f1f] move.w (a7)+, -(a7) uses Op3f1f ----------
Op3f1f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f20] move.w -(a0), -(a7) uses Op3f20 ----------
Op3f20:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f27] move.w -(a7), -(a7) uses Op3f27 ----------
Op3f27:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f28] move.w ($3333,a0), -(a7) uses Op3f28 ----------
Op3f28:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f30] move.w ($33,a0,d3.w*2), -(a7) uses Op3f30 ----------
Op3f30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f38] move.w $3333.w, -(a7) uses Op3f38 ----------
Op3f38:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f39] move.w $33333333.l, -(a7) uses Op3f39 ----------
Op3f39:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f3a] move.w ($3333,pc), -(a7); =3335 uses Op3f3a ----------
Op3f3a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f3b] move.w ($33,pc,d3.w*2), -(a7); =35 uses Op3f3b ----------
Op3f3b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f3c] move.w #$3333, -(a7) uses Op3f3c ----------
Op3f3c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r1:
  mov r1,r0,asl #0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4000] negx.b d0 uses Op4000 ----------
Op4000:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4010] negx.b (a0) uses Op4010 ----------
Op4010:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4018] negx.b (a0)+ uses Op4018 ----------
Op4018:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [401f] negx.b (a7)+ uses Op401f ----------
Op401f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4020] negx.b -(a0) uses Op4020 ----------
Op4020:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4027] negx.b -(a7) uses Op4027 ----------
Op4027:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4028] negx.b ($3333,a0) uses Op4028 ----------
Op4028:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4030] negx.b ($33,a0,d3.w*2) uses Op4030 ----------
Op4030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4038] negx.b $3333.w uses Op4038 ----------
Op4038:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4039] negx.b $33333333.l uses Op4039 ----------
Op4039:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4040] negx.w d0 uses Op4040 ----------
Op4040:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4050] negx.w (a0) uses Op4050 ----------
Op4050:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4058] negx.w (a0)+ uses Op4058 ----------
Op4058:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [405f] negx.w (a7)+ uses Op405f ----------
Op405f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4060] negx.w -(a0) uses Op4060 ----------
Op4060:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4067] negx.w -(a7) uses Op4067 ----------
Op4067:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4068] negx.w ($3333,a0) uses Op4068 ----------
Op4068:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4070] negx.w ($33,a0,d3.w*2) uses Op4070 ----------
Op4070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4078] negx.w $3333.w uses Op4078 ----------
Op4078:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4079] negx.w $33333333.l uses Op4079 ----------
Op4079:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,lsl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4080] negx.l d0 uses Op4080 ----------
Op4080:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4090] negx.l (a0) uses Op4090 ----------
Op4090:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4098] negx.l (a0)+ uses Op4098 ----------
Op4098:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [409f] negx.l (a7)+ uses Op409f ----------
Op409f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40a0] negx.l -(a0) uses Op40a0 ----------
Op40a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40a7] negx.l -(a7) uses Op40a7 ----------
Op40a7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40a8] negx.l ($3333,a0) uses Op40a8 ----------
Op40a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40b0] negx.l ($33,a0,d3.w*2) uses Op40b0 ----------
Op40b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40b8] negx.l $3333.w uses Op40b8 ----------
Op40b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40b9] negx.l $33333333.l uses Op40b9 ----------
Op40b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40c0] move sr, d0 uses Op40c0 ----------
Op40c0:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40d0] move sr, (a0) uses Op40d0 ----------
Op40d0:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40d8] move sr, (a0)+ uses Op40d8 ----------
Op40d8:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40df] move sr, (a7)+ uses Op40df ----------
Op40df:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40e0] move sr, -(a0) uses Op40e0 ----------
Op40e0:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40e7] move sr, -(a7) uses Op40e7 ----------
Op40e7:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40e8] move sr, ($3333,a0) uses Op40e8 ----------
Op40e8:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40f0] move sr, ($33,a0,d3.w*2) uses Op40f0 ----------
Op40f0:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40f8] move sr, $3333.w uses Op40f8 ----------
Op40f8:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40f9] move sr, $33333333.l uses Op40f9 ----------
Op40f9:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4180]  uses Op4180 ----------
Op4180:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap4180
;@ Do arithmetic:
  cmp r1,r0
  bicgt r9,r9,#0x80000000 ;@ N
  bgt chktrap4180
;@ old N remains
  bic r9,r9,#0x80000000 ;@ N
  orr r9,r9,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap4180: ;@ CHK exception:
  mov r0,#0x18
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#50 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4190]  uses Op4190 ----------
Op4190:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap4190
;@ Do arithmetic:
  cmp r1,r0
  bicgt r9,r9,#0x80000000 ;@ N
  bgt chktrap4190
;@ old N remains
  bic r9,r9,#0x80000000 ;@ N
  orr r9,r9,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap4190: ;@ CHK exception:
  mov r0,#0x18
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4198]  uses Op4198 ----------
Op4198:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap4198
;@ Do arithmetic:
  cmp r1,r0
  bicgt r9,r9,#0x80000000 ;@ N
  bgt chktrap4198
;@ old N remains
  bic r9,r9,#0x80000000 ;@ N
  orr r9,r9,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap4198: ;@ CHK exception:
  mov r0,#0x18
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [419f]  uses Op419f ----------
Op419f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap419f
;@ Do arithmetic:
  cmp r1,r0
  bicgt r9,r9,#0x80000000 ;@ N
  bgt chktrap419f
;@ old N remains
  bic r9,r9,#0x80000000 ;@ N
  orr r9,r9,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap419f: ;@ CHK exception:
  mov r0,#0x18
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41a0]  uses Op41a0 ----------
Op41a0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41a0
;@ Do arithmetic:
  cmp r1,r0
  bicgt r9,r9,#0x80000000 ;@ N
  bgt chktrap41a0
;@ old N remains
  bic r9,r9,#0x80000000 ;@ N
  orr r9,r9,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41a0: ;@ CHK exception:
  mov r0,#0x18
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#56 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41a7]  uses Op41a7 ----------
Op41a7:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41a7
;@ Do arithmetic:
  cmp r1,r0
  bicgt r9,r9,#0x80000000 ;@ N
  bgt chktrap41a7
;@ old N remains
  bic r9,r9,#0x80000000 ;@ N
  orr r9,r9,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41a7: ;@ CHK exception:
  mov r0,#0x18
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#56 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41a8]  uses Op41a8 ----------
Op41a8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41a8
;@ Do arithmetic:
  cmp r1,r0
  bicgt r9,r9,#0x80000000 ;@ N
  bgt chktrap41a8
;@ old N remains
  bic r9,r9,#0x80000000 ;@ N
  orr r9,r9,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41a8: ;@ CHK exception:
  mov r0,#0x18
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41b0]  uses Op41b0 ----------
Op41b0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41b0
;@ Do arithmetic:
  cmp r1,r0
  bicgt r9,r9,#0x80000000 ;@ N
  bgt chktrap41b0
;@ old N remains
  bic r9,r9,#0x80000000 ;@ N
  orr r9,r9,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41b0: ;@ CHK exception:
  mov r0,#0x18
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41b8]  uses Op41b8 ----------
Op41b8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41b8
;@ Do arithmetic:
  cmp r1,r0
  bicgt r9,r9,#0x80000000 ;@ N
  bgt chktrap41b8
;@ old N remains
  bic r9,r9,#0x80000000 ;@ N
  orr r9,r9,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41b8: ;@ CHK exception:
  mov r0,#0x18
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41b9]  uses Op41b9 ----------
Op41b9:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41b9
;@ Do arithmetic:
  cmp r1,r0
  bicgt r9,r9,#0x80000000 ;@ N
  bgt chktrap41b9
;@ old N remains
  bic r9,r9,#0x80000000 ;@ N
  orr r9,r9,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41b9: ;@ CHK exception:
  mov r0,#0x18
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41ba]  uses Op41ba ----------
Op41ba:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41ba
;@ Do arithmetic:
  cmp r1,r0
  bicgt r9,r9,#0x80000000 ;@ N
  bgt chktrap41ba
;@ old N remains
  bic r9,r9,#0x80000000 ;@ N
  orr r9,r9,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41ba: ;@ CHK exception:
  mov r0,#0x18
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41bb]  uses Op41bb ----------
Op41bb:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41bb
;@ Do arithmetic:
  cmp r1,r0
  bicgt r9,r9,#0x80000000 ;@ N
  bgt chktrap41bb
;@ old N remains
  bic r9,r9,#0x80000000 ;@ N
  orr r9,r9,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41bb: ;@ CHK exception:
  mov r0,#0x18
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41bc]  uses Op41bc ----------
Op41bc:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r0:
  mov r0,r10,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41bc
;@ Do arithmetic:
  cmp r1,r0
  bicgt r9,r9,#0x80000000 ;@ N
  bgt chktrap41bc
;@ old N remains
  bic r9,r9,#0x80000000 ;@ N
  orr r9,r9,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41bc: ;@ CHK exception:
  mov r0,#0x18
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41d0] lea (a0), a0 uses Op41d0 ----------
Op41d0:
;@ EaCalc : Get '(a0)' into r1:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r1,[r7,r2,lsl #2]
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41e8] lea ($3333,a0), a0 uses Op41e8 ----------
Op41e8:
;@ EaCalc : Get '($3333,a0)' into r1:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r1,r0,r2 ;@ Add on offset
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41f0] lea ($33,a0,d3.w*2), a0 uses Op41f0 ----------
Op41f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r1:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r1,r2,r3 ;@ r1=Disp+An+Rn
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41f8] lea $3333.w, a0 uses Op41f8 ----------
Op41f8:
;@ EaCalc : Get '$3333.w' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch Absolute Short address
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41f9] lea $33333333.l, a0 uses Op41f9 ----------
Op41f9:
;@ EaCalc : Get '$33333333.l' into r1:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r1,r0,r2,lsl #16
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41fa] lea ($3333,pc), a0; =3335 uses Op41fa ----------
Op41fa:
;@ EaCalc : Get '($3333,pc)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r1,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41fb] lea ($33,pc,d3.w*2), a0; =35 uses Op41fb ----------
Op41fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r1,r2,r0,asr #8 ;@ r1=Disp+PC+Rn
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4200] clr.b d0 uses Op4200 ----------
Op4200:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4210] clr.b (a0) uses Op4210 ----------
Op4210:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4218] clr.b (a0)+ uses Op4218 ----------
Op4218:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [421f] clr.b (a7)+ uses Op421f ----------
Op421f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4220] clr.b -(a0) uses Op4220 ----------
Op4220:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4227] clr.b -(a7) uses Op4227 ----------
Op4227:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4228] clr.b ($3333,a0) uses Op4228 ----------
Op4228:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4230] clr.b ($33,a0,d3.w*2) uses Op4230 ----------
Op4230:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4238] clr.b $3333.w uses Op4238 ----------
Op4238:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4239] clr.b $33333333.l uses Op4239 ----------
Op4239:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4240] clr.w d0 uses Op4240 ----------
Op4240:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4250] clr.w (a0) uses Op4250 ----------
Op4250:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4258] clr.w (a0)+ uses Op4258 ----------
Op4258:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [425f] clr.w (a7)+ uses Op425f ----------
Op425f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4260] clr.w -(a0) uses Op4260 ----------
Op4260:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4267] clr.w -(a7) uses Op4267 ----------
Op4267:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4268] clr.w ($3333,a0) uses Op4268 ----------
Op4268:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4270] clr.w ($33,a0,d3.w*2) uses Op4270 ----------
Op4270:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4278] clr.w $3333.w uses Op4278 ----------
Op4278:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4279] clr.w $33333333.l uses Op4279 ----------
Op4279:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4280] clr.l d0 uses Op4280 ----------
Op4280:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4290] clr.l (a0) uses Op4290 ----------
Op4290:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4298] clr.l (a0)+ uses Op4298 ----------
Op4298:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [429f] clr.l (a7)+ uses Op429f ----------
Op429f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42a0] clr.l -(a0) uses Op42a0 ----------
Op42a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42a7] clr.l -(a7) uses Op42a7 ----------
Op42a7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42a8] clr.l ($3333,a0) uses Op42a8 ----------
Op42a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42b0] clr.l ($33,a0,d3.w*2) uses Op42b0 ----------
Op42b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42b8] clr.l $3333.w uses Op42b8 ----------
Op42b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42b9] clr.l $33333333.l uses Op42b9 ----------
Op42b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4400] neg.b d0 uses Op4400 ----------
Op4400:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]

;@ Neg:
  mov r0,r0,lsl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4410] neg.b (a0) uses Op4410 ----------
Op4410:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,lsl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4418] neg.b (a0)+ uses Op4418 ----------
Op4418:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,lsl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [441f] neg.b (a7)+ uses Op441f ----------
Op441f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,lsl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4420] neg.b -(a0) uses Op4420 ----------
Op4420:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,lsl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4427] neg.b -(a7) uses Op4427 ----------
Op4427:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,lsl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4428] neg.b ($3333,a0) uses Op4428 ----------
Op4428:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,lsl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4430] neg.b ($33,a0,d3.w*2) uses Op4430 ----------
Op4430:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,lsl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4438] neg.b $3333.w uses Op4438 ----------
Op4438:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,lsl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4439] neg.b $33333333.l uses Op4439 ----------
Op4439:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,lsl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4440] neg.w d0 uses Op4440 ----------
Op4440:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]

;@ Neg:
  mov r0,r0,lsl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4450] neg.w (a0) uses Op4450 ----------
Op4450:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,lsl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4458] neg.w (a0)+ uses Op4458 ----------
Op4458:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,lsl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [445f] neg.w (a7)+ uses Op445f ----------
Op445f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,lsl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4460] neg.w -(a0) uses Op4460 ----------
Op4460:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,lsl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4467] neg.w -(a7) uses Op4467 ----------
Op4467:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,lsl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4468] neg.w ($3333,a0) uses Op4468 ----------
Op4468:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,lsl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4470] neg.w ($33,a0,d3.w*2) uses Op4470 ----------
Op4470:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,lsl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4478] neg.w $3333.w uses Op4478 ----------
Op4478:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,lsl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4479] neg.w $33333333.l uses Op4479 ----------
Op4479:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,lsl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4480] neg.l d0 uses Op4480 ----------
Op4480:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4490] neg.l (a0) uses Op4490 ----------
Op4490:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4498] neg.l (a0)+ uses Op4498 ----------
Op4498:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [449f] neg.l (a7)+ uses Op449f ----------
Op449f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44a0] neg.l -(a0) uses Op44a0 ----------
Op44a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44a7] neg.l -(a7) uses Op44a7 ----------
Op44a7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44a8] neg.l ($3333,a0) uses Op44a8 ----------
Op44a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44b0] neg.l ($33,a0,d3.w*2) uses Op44b0 ----------
Op44b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44b8] neg.l $3333.w uses Op44b8 ----------
Op44b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44b9] neg.l $33333333.l uses Op44b9 ----------
Op44b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44c0] move d0, ccr uses Op44c0 ----------
Op44c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44d0] move (a0), ccr uses Op44d0 ----------
Op44d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44d8] move (a0)+, ccr uses Op44d8 ----------
Op44d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44df] move (a7)+, ccr uses Op44df ----------
Op44df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44e0] move -(a0), ccr uses Op44e0 ----------
Op44e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44e7] move -(a7), ccr uses Op44e7 ----------
Op44e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44e8] move ($3333,a0), ccr uses Op44e8 ----------
Op44e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44f0] move ($33,a0,d3.w*2), ccr uses Op44f0 ----------
Op44f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44f8] move $3333.w, ccr uses Op44f8 ----------
Op44f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44f9] move $33333333.l, ccr uses Op44f9 ----------
Op44f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44fa] move ($3333,pc), ccr; =3335 uses Op44fa ----------
Op44fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44fb] move ($33,pc,d3.w*2), ccr; =35 uses Op44fb ----------
Op44fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44fc] move #$3333, ccr uses Op44fc ----------
Op44fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4600] not.b d0 uses Op4600 ----------
Op4600:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4610] not.b (a0) uses Op4610 ----------
Op4610:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4618] not.b (a0)+ uses Op4618 ----------
Op4618:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [461f] not.b (a7)+ uses Op461f ----------
Op461f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4620] not.b -(a0) uses Op4620 ----------
Op4620:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4627] not.b -(a7) uses Op4627 ----------
Op4627:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4628] not.b ($3333,a0) uses Op4628 ----------
Op4628:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4630] not.b ($33,a0,d3.w*2) uses Op4630 ----------
Op4630:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4638] not.b $3333.w uses Op4638 ----------
Op4638:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4639] not.b $33333333.l uses Op4639 ----------
Op4639:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4640] not.w d0 uses Op4640 ----------
Op4640:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4650] not.w (a0) uses Op4650 ----------
Op4650:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4658] not.w (a0)+ uses Op4658 ----------
Op4658:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [465f] not.w (a7)+ uses Op465f ----------
Op465f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4660] not.w -(a0) uses Op4660 ----------
Op4660:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4667] not.w -(a7) uses Op4667 ----------
Op4667:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4668] not.w ($3333,a0) uses Op4668 ----------
Op4668:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4670] not.w ($33,a0,d3.w*2) uses Op4670 ----------
Op4670:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4678] not.w $3333.w uses Op4678 ----------
Op4678:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4679] not.w $33333333.l uses Op4679 ----------
Op4679:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4680] not.l d0 uses Op4680 ----------
Op4680:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4690] not.l (a0) uses Op4690 ----------
Op4690:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4698] not.l (a0)+ uses Op4698 ----------
Op4698:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [469f] not.l (a7)+ uses Op469f ----------
Op469f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46a0] not.l -(a0) uses Op46a0 ----------
Op46a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46a7] not.l -(a7) uses Op46a7 ----------
Op46a7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46a8] not.l ($3333,a0) uses Op46a8 ----------
Op46a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46b0] not.l ($33,a0,d3.w*2) uses Op46b0 ----------
Op46b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46b8] not.l $3333.w uses Op46b8 ----------
Op46b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46b9] not.l $33333333.l uses Op46b9 ----------
Op46b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46c0] move d0, sr uses Op46c0 ----------
Op46c0:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46c0 ;@ No

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46c0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46c0:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts46c0
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts46c0:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46c0:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46d0] move (a0), sr uses Op46d0 ----------
Op46d0:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46d0 ;@ No

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46d0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46d0:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts46d0
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts46d0:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46d0:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46d8] move (a0)+, sr uses Op46d8 ----------
Op46d8:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46d8 ;@ No

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46d8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46d8:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts46d8
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts46d8:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46d8:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46df] move (a7)+, sr uses Op46df ----------
Op46df:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46df ;@ No

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46df
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46df:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts46df
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts46df:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46df:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46e0] move -(a0), sr uses Op46e0 ----------
Op46e0:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46e0 ;@ No

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46e0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46e0:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts46e0
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts46e0:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46e0:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46e7] move -(a7), sr uses Op46e7 ----------
Op46e7:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46e7 ;@ No

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46e7
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46e7:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts46e7
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts46e7:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46e7:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46e8] move ($3333,a0), sr uses Op46e8 ----------
Op46e8:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46e8 ;@ No

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46e8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46e8:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts46e8
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts46e8:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46e8:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46f0] move ($33,a0,d3.w*2), sr uses Op46f0 ----------
Op46f0:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46f0 ;@ No

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46f0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46f0:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts46f0
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts46f0:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46f0:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46f8] move $3333.w, sr uses Op46f8 ----------
Op46f8:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46f8 ;@ No

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46f8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46f8:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts46f8
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts46f8:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46f8:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46f9] move $33333333.l, sr uses Op46f9 ----------
Op46f9:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46f9 ;@ No

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46f9
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46f9:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts46f9
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts46f9:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46f9:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46fa] move ($3333,pc), sr; =3335 uses Op46fa ----------
Op46fa:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46fa ;@ No

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46fa
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46fa:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts46fa
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts46fa:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46fa:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46fb] move ($33,pc,d3.w*2), sr; =35 uses Op46fb ----------
Op46fb:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46fb ;@ No

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46fb
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46fb:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts46fb
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts46fb:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46fb:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46fc] move #$3333, sr uses Op46fc ----------
Op46fc:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46fc ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46fc
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46fc:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts46fc
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts46fc:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46fc:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4800]  uses Op4800 ----------
Op4800:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  ldrb r2,[r7,#0x45]
  tst r2,#2
  mov r2,r0
  addne r2,r0,#0x01000000 ;@ add X
  rsbs r1,r2,#0x9a000000 ;@ do arithmetic
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  orrmi r9,r9,#0x80000000 ;@ N
  cmp r1,#0x9a000000
  beq finish4800

  mvn r3,r9,lsr #3 ;@ Undefined V behavior
  and r2,r1,#0x0f000000
  cmp r2,#0x0a000000
  andeq r1,r1,#0xf0000000
  addeq r1,r1,#0x10000000
  and r3,r3,r1,lsr #3 ;@ Undefined V behavior part II
  tst r1,r1
  orr r9,r9,r3 ;@ save V
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsl #2]

finish4800:
  mov r2,r9,lsr #28
  strb r2, [r7,#0x45]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4810]  uses Op4810 ----------
Op4810:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  ldrb r2,[r7,#0x45]
  tst r2,#2
  mov r2,r0
  addne r2,r0,#0x01000000 ;@ add X
  rsbs r1,r2,#0x9a000000 ;@ do arithmetic
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  orrmi r9,r9,#0x80000000 ;@ N
  cmp r1,#0x9a000000
  beq finish4810

  mvn r3,r9,lsr #3 ;@ Undefined V behavior
  and r2,r1,#0x0f000000
  cmp r2,#0x0a000000
  andeq r1,r1,#0xf0000000
  addeq r1,r1,#0x10000000
  and r3,r3,r1,lsr #3 ;@ Undefined V behavior part II
  tst r1,r1
  orr r9,r9,r3 ;@ save V
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

finish4810:
  mov r2,r9,lsr #28
  strb r2, [r7,#0x45]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4818]  uses Op4818 ----------
Op4818:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  ldrb r2,[r7,#0x45]
  tst r2,#2
  mov r2,r0
  addne r2,r0,#0x01000000 ;@ add X
  rsbs r1,r2,#0x9a000000 ;@ do arithmetic
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  orrmi r9,r9,#0x80000000 ;@ N
  cmp r1,#0x9a000000
  beq finish4818

  mvn r3,r9,lsr #3 ;@ Undefined V behavior
  and r2,r1,#0x0f000000
  cmp r2,#0x0a000000
  andeq r1,r1,#0xf0000000
  addeq r1,r1,#0x10000000
  and r3,r3,r1,lsr #3 ;@ Undefined V behavior part II
  tst r1,r1
  orr r9,r9,r3 ;@ save V
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

finish4818:
  mov r2,r9,lsr #28
  strb r2, [r7,#0x45]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [481f]  uses Op481f ----------
Op481f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  ldrb r2,[r7,#0x45]
  tst r2,#2
  mov r2,r0
  addne r2,r0,#0x01000000 ;@ add X
  rsbs r1,r2,#0x9a000000 ;@ do arithmetic
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  orrmi r9,r9,#0x80000000 ;@ N
  cmp r1,#0x9a000000
  beq finish481f

  mvn r3,r9,lsr #3 ;@ Undefined V behavior
  and r2,r1,#0x0f000000
  cmp r2,#0x0a000000
  andeq r1,r1,#0xf0000000
  addeq r1,r1,#0x10000000
  and r3,r3,r1,lsr #3 ;@ Undefined V behavior part II
  tst r1,r1
  orr r9,r9,r3 ;@ save V
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

finish481f:
  mov r2,r9,lsr #28
  strb r2, [r7,#0x45]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4820]  uses Op4820 ----------
Op4820:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  ldrb r2,[r7,#0x45]
  tst r2,#2
  mov r2,r0
  addne r2,r0,#0x01000000 ;@ add X
  rsbs r1,r2,#0x9a000000 ;@ do arithmetic
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  orrmi r9,r9,#0x80000000 ;@ N
  cmp r1,#0x9a000000
  beq finish4820

  mvn r3,r9,lsr #3 ;@ Undefined V behavior
  and r2,r1,#0x0f000000
  cmp r2,#0x0a000000
  andeq r1,r1,#0xf0000000
  addeq r1,r1,#0x10000000
  and r3,r3,r1,lsr #3 ;@ Undefined V behavior part II
  tst r1,r1
  orr r9,r9,r3 ;@ save V
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

finish4820:
  mov r2,r9,lsr #28
  strb r2, [r7,#0x45]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4827]  uses Op4827 ----------
Op4827:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  ldrb r2,[r7,#0x45]
  tst r2,#2
  mov r2,r0
  addne r2,r0,#0x01000000 ;@ add X
  rsbs r1,r2,#0x9a000000 ;@ do arithmetic
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  orrmi r9,r9,#0x80000000 ;@ N
  cmp r1,#0x9a000000
  beq finish4827

  mvn r3,r9,lsr #3 ;@ Undefined V behavior
  and r2,r1,#0x0f000000
  cmp r2,#0x0a000000
  andeq r1,r1,#0xf0000000
  addeq r1,r1,#0x10000000
  and r3,r3,r1,lsr #3 ;@ Undefined V behavior part II
  tst r1,r1
  orr r9,r9,r3 ;@ save V
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

finish4827:
  mov r2,r9,lsr #28
  strb r2, [r7,#0x45]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4828]  uses Op4828 ----------
Op4828:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  ldrb r2,[r7,#0x45]
  tst r2,#2
  mov r2,r0
  addne r2,r0,#0x01000000 ;@ add X
  rsbs r1,r2,#0x9a000000 ;@ do arithmetic
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  orrmi r9,r9,#0x80000000 ;@ N
  cmp r1,#0x9a000000
  beq finish4828

  mvn r3,r9,lsr #3 ;@ Undefined V behavior
  and r2,r1,#0x0f000000
  cmp r2,#0x0a000000
  andeq r1,r1,#0xf0000000
  addeq r1,r1,#0x10000000
  and r3,r3,r1,lsr #3 ;@ Undefined V behavior part II
  tst r1,r1
  orr r9,r9,r3 ;@ save V
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

finish4828:
  mov r2,r9,lsr #28
  strb r2, [r7,#0x45]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4830]  uses Op4830 ----------
Op4830:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  ldrb r2,[r7,#0x45]
  tst r2,#2
  mov r2,r0
  addne r2,r0,#0x01000000 ;@ add X
  rsbs r1,r2,#0x9a000000 ;@ do arithmetic
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  orrmi r9,r9,#0x80000000 ;@ N
  cmp r1,#0x9a000000
  beq finish4830

  mvn r3,r9,lsr #3 ;@ Undefined V behavior
  and r2,r1,#0x0f000000
  cmp r2,#0x0a000000
  andeq r1,r1,#0xf0000000
  addeq r1,r1,#0x10000000
  and r3,r3,r1,lsr #3 ;@ Undefined V behavior part II
  tst r1,r1
  orr r9,r9,r3 ;@ save V
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

finish4830:
  mov r2,r9,lsr #28
  strb r2, [r7,#0x45]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4838]  uses Op4838 ----------
Op4838:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  ldrb r2,[r7,#0x45]
  tst r2,#2
  mov r2,r0
  addne r2,r0,#0x01000000 ;@ add X
  rsbs r1,r2,#0x9a000000 ;@ do arithmetic
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  orrmi r9,r9,#0x80000000 ;@ N
  cmp r1,#0x9a000000
  beq finish4838

  mvn r3,r9,lsr #3 ;@ Undefined V behavior
  and r2,r1,#0x0f000000
  cmp r2,#0x0a000000
  andeq r1,r1,#0xf0000000
  addeq r1,r1,#0x10000000
  and r3,r3,r1,lsr #3 ;@ Undefined V behavior part II
  tst r1,r1
  orr r9,r9,r3 ;@ save V
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

finish4838:
  mov r2,r9,lsr #28
  strb r2, [r7,#0x45]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4839]  uses Op4839 ----------
Op4839:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  ldrb r2,[r7,#0x45]
  tst r2,#2
  mov r2,r0
  addne r2,r0,#0x01000000 ;@ add X
  rsbs r1,r2,#0x9a000000 ;@ do arithmetic
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  orrmi r9,r9,#0x80000000 ;@ N
  cmp r1,#0x9a000000
  beq finish4839

  mvn r3,r9,lsr #3 ;@ Undefined V behavior
  and r2,r1,#0x0f000000
  cmp r2,#0x0a000000
  andeq r1,r1,#0xf0000000
  addeq r1,r1,#0x10000000
  and r3,r3,r1,lsr #3 ;@ Undefined V behavior part II
  tst r1,r1
  orr r9,r9,r3 ;@ save V
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

finish4839:
  mov r2,r9,lsr #28
  strb r2, [r7,#0x45]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4840] swap d0 uses Op4840 ----------
Op4840:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r1,r0,ror #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4850] pea (a0) uses Op4850 ----------
Op4850:
;@ EaCalc : Get '(a0)' into r1:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r1,[r7,r2,lsl #2]

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4868] pea ($3333,a0) uses Op4868 ----------
Op4868:
;@ EaCalc : Get '($3333,a0)' into r1:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r1,r0,r2 ;@ Add on offset

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4870] pea ($33,a0,d3.w*2) uses Op4870 ----------
Op4870:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r1:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r1,r2,r3 ;@ r1=Disp+An+Rn

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4878] pea $3333.w uses Op4878 ----------
Op4878:
;@ EaCalc : Get '$3333.w' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch Absolute Short address

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4879] pea $33333333.l uses Op4879 ----------
Op4879:
;@ EaCalc : Get '$33333333.l' into r1:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r1,r0,r2,lsl #16

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [487a] pea ($3333,pc); =3335 uses Op487a ----------
Op487a:
;@ EaCalc : Get '($3333,pc)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r1,r2,r0,asr #8 ;@ ($nn,PC)

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [487b] pea ($33,pc,d3.w*2); =35 uses Op487b ----------
Op487b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r1,r2,r0,asr #8 ;@ r1=Disp+PC+Rn

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4880] ext.w d0 uses Op4880 ----------
Op4880:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]

  mov r0,r0,asl #24
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r0,asr #24

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4890] movem.w d0-d1/d4-d5/a0-a1/a4-a5, (a0) uses Op4890 ----------
Op4890:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r9,[r7,r2,lsl #2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4890:
  tst r11,#1
  beq SkipReg4890

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a0)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4890:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4890

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48a0] movem.w d2-d3/d6-d7/a2-a3/a6-a7, -(a0) uses Op48a0 ----------
Op48a0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r9,[r7,r2,lsl #2]
;@ r10=Register Index*4:
  mov r10,#0x3c ;@ order reversed for -(An)

MoreReg48a0:
  tst r11,#1
  beq SkipReg48a0

  sub r9,r9,#2 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '-(a0)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  sub r5,r5,#4 ;@ Take some cycles

SkipReg48a0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#-4 ;@ r10=Next Register
  bne MoreReg48a0

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48a7] movem.w d2-d3/d6-d7/a2-a3/a6-a7, -(a7) uses Op48a7 ----------
Op48a7:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r9,[r7,r2,lsl #2]
;@ r10=Register Index*4:
  mov r10,#0x3c ;@ order reversed for -(An)

MoreReg48a7:
  tst r11,#1
  beq SkipReg48a7

  sub r9,r9,#2 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '-(a7)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  sub r5,r5,#4 ;@ Take some cycles

SkipReg48a7:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#-4 ;@ r10=Next Register
  bne MoreReg48a7

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48a8] movem.w d0-d1/d4-d5/a0-a1/a4-a5, ($3333,a0) uses Op48a8 ----------
Op48a8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($3333,a0)' into r9:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r9,r0,r2 ;@ Add on offset
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48a8:
  tst r11,#1
  beq SkipReg48a8

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($3333,a0)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg48a8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48a8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48b0] movem.w d0-d1/d4-d5/a0-a1/a4-a5, ($33,a0,d3.w*2) uses Op48b0 ----------
Op48b0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r9:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r9,r2,r3 ;@ r9=Disp+An+Rn
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48b0:
  tst r11,#1
  beq SkipReg48b0

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg48b0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48b0

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48b8] movem.w d0-d1/d4-d5/a0-a1/a4-a5, $3333.w uses Op48b8 ----------
Op48b8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$3333.w' into r9:
  ldrsh r9,[r4],#2 ;@ Fetch Absolute Short address
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48b8:
  tst r11,#1
  beq SkipReg48b8

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$3333.w' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg48b8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48b8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48b9] movem.w d0-d1/d4-d5/a0-a1/a4-a5, $33333333.l uses Op48b9 ----------
Op48b9:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$33333333.l' into r9:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r9,r0,r2,lsl #16
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48b9:
  tst r11,#1
  beq SkipReg48b9

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$33333333.l' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg48b9:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48b9

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48c0] ext.l d0 uses Op48c0 ----------
Op48c0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r0,r0,asl #16
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r0,asr #16

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48d0] movem.l d0-d1/d4-d5/a0-a1/a4-a5, (a0) uses Op48d0 ----------
Op48d0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r9,[r7,r2,lsl #2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48d0:
  tst r11,#1
  beq SkipReg48d0

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a0)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg48d0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48d0

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48e0] movem.l d2-d3/d6-d7/a2-a3/a6-a7, -(a0) uses Op48e0 ----------
Op48e0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r9,[r7,r2,lsl #2]
;@ r10=Register Index*4:
  mov r10,#0x3c ;@ order reversed for -(An)

MoreReg48e0:
  tst r11,#1
  beq SkipReg48e0

  sub r9,r9,#4 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '-(a0)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  sub r5,r5,#8 ;@ Take some cycles

SkipReg48e0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#-4 ;@ r10=Next Register
  bne MoreReg48e0

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48e7] movem.l d2-d3/d6-d7/a2-a3/a6-a7, -(a7) uses Op48e7 ----------
Op48e7:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r9,[r7,r2,lsl #2]
;@ r10=Register Index*4:
  mov r10,#0x3c ;@ order reversed for -(An)

MoreReg48e7:
  tst r11,#1
  beq SkipReg48e7

  sub r9,r9,#4 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '-(a7)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  sub r5,r5,#8 ;@ Take some cycles

SkipReg48e7:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#-4 ;@ r10=Next Register
  bne MoreReg48e7

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48e8] movem.l d0-d1/d4-d5/a0-a1/a4-a5, ($3333,a0) uses Op48e8 ----------
Op48e8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($3333,a0)' into r9:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r9,r0,r2 ;@ Add on offset
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48e8:
  tst r11,#1
  beq SkipReg48e8

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($3333,a0)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg48e8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48e8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48f0] movem.l d0-d1/d4-d5/a0-a1/a4-a5, ($33,a0,d3.w*2) uses Op48f0 ----------
Op48f0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r9:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r9,r2,r3 ;@ r9=Disp+An+Rn
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48f0:
  tst r11,#1
  beq SkipReg48f0

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg48f0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48f0

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48f8] movem.l d0-d1/d4-d5/a0-a1/a4-a5, $3333.w uses Op48f8 ----------
Op48f8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$3333.w' into r9:
  ldrsh r9,[r4],#2 ;@ Fetch Absolute Short address
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48f8:
  tst r11,#1
  beq SkipReg48f8

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$3333.w' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg48f8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48f8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48f9] movem.l d0-d1/d4-d5/a0-a1/a4-a5, $33333333.l uses Op48f9 ----------
Op48f9:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$33333333.l' into r9:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r9,r0,r2,lsl #16
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48f9:
  tst r11,#1
  beq SkipReg48f9

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$33333333.l' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg48f9:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48f9

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a00] tst.b d0 uses Op4a00 ----------
Op4a00:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldrb r0,[r7,r0,lsl #2]
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a10] tst.b (a0) uses Op4a10 ----------
Op4a10:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a18] tst.b (a0)+ uses Op4a18 ----------
Op4a18:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a1f] tst.b (a7)+ uses Op4a1f ----------
Op4a1f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a20] tst.b -(a0) uses Op4a20 ----------
Op4a20:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a27] tst.b -(a7) uses Op4a27 ----------
Op4a27:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a28] tst.b ($3333,a0) uses Op4a28 ----------
Op4a28:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a30] tst.b ($33,a0,d3.w*2) uses Op4a30 ----------
Op4a30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a38] tst.b $3333.w uses Op4a38 ----------
Op4a38:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a39] tst.b $33333333.l uses Op4a39 ----------
Op4a39:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a40] tst.w d0 uses Op4a40 ----------
Op4a40:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a50] tst.w (a0) uses Op4a50 ----------
Op4a50:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a58] tst.w (a0)+ uses Op4a58 ----------
Op4a58:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a5f] tst.w (a7)+ uses Op4a5f ----------
Op4a5f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a60] tst.w -(a0) uses Op4a60 ----------
Op4a60:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a67] tst.w -(a7) uses Op4a67 ----------
Op4a67:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a68] tst.w ($3333,a0) uses Op4a68 ----------
Op4a68:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a70] tst.w ($33,a0,d3.w*2) uses Op4a70 ----------
Op4a70:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a78] tst.w $3333.w uses Op4a78 ----------
Op4a78:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a79] tst.w $33333333.l uses Op4a79 ----------
Op4a79:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a80] tst.l d0 uses Op4a80 ----------
Op4a80:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a90] tst.l (a0) uses Op4a90 ----------
Op4a90:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a98] tst.l (a0)+ uses Op4a98 ----------
Op4a98:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a9f] tst.l (a7)+ uses Op4a9f ----------
Op4a9f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4aa0] tst.l -(a0) uses Op4aa0 ----------
Op4aa0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4aa7] tst.l -(a7) uses Op4aa7 ----------
Op4aa7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4aa8] tst.l ($3333,a0) uses Op4aa8 ----------
Op4aa8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ab0] tst.l ($33,a0,d3.w*2) uses Op4ab0 ----------
Op4ab0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ab8] tst.l $3333.w uses Op4ab8 ----------
Op4ab8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ab9] tst.l $33333333.l uses Op4ab9 ----------
Op4ab9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ac0]  uses Op4ac0 ----------
Op4ac0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r1:
  ldrb r1,[r7,r10,lsl #2]
  mov r1,r1,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ad0]  uses Op4ad0 ----------
Op4ad0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r1:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ad8]  uses Op4ad8 ----------
Op4ad8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r1:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4adf]  uses Op4adf ----------
Op4adf:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r1:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ae0]  uses Op4ae0 ----------
Op4ae0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r1:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ae7]  uses Op4ae7 ----------
Op4ae7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r1:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ae8]  uses Op4ae8 ----------
Op4ae8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r1:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4af0]  uses Op4af0 ----------
Op4af0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r1:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4af8]  uses Op4af8 ----------
Op4af8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r1:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4af9]  uses Op4af9 ----------
Op4af9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r1:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4c90] movem.w (a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4c90 ----------
Op4c90:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r9,[r7,r2,lsl #2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4c90:
  tst r11,#1
  beq SkipReg4c90

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4c90:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4c90

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4c98] movem.w (a0)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4c98 ----------
Op4c98:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r9,[r7,r2,lsl #2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4c98:
  tst r11,#1
  beq SkipReg4c98

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)+' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4c98:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4c98

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4c9f] movem.w (a7)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4c9f ----------
Op4c9f:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r9,[r7,r2,lsl #2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4c9f:
  tst r11,#1
  beq SkipReg4c9f

  ;@ Copy memory to register:
;@ EaRead : Read '(a7)+' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4c9f:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4c9f

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ca8] movem.w ($3333,a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4ca8 ----------
Op4ca8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($3333,a0)' into r9:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r9,r0,r2 ;@ Add on offset
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4ca8:
  tst r11,#1
  beq SkipReg4ca8

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,a0)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4ca8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4ca8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cb0] movem.w ($33,a0,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb0 ----------
Op4cb0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r9:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r9,r2,r3 ;@ r9=Disp+An+Rn
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cb0:
  tst r11,#1
  beq SkipReg4cb0

  ;@ Copy memory to register:
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4cb0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cb0

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cb8] movem.w $3333.w, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb8 ----------
Op4cb8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$3333.w' into r9:
  ldrsh r9,[r4],#2 ;@ Fetch Absolute Short address
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cb8:
  tst r11,#1
  beq SkipReg4cb8

  ;@ Copy memory to register:
;@ EaRead : Read '$3333.w' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4cb8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cb8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cb9] movem.w $33333333.l, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb9 ----------
Op4cb9:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$33333333.l' into r9:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r9,r0,r2,lsl #16
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cb9:
  tst r11,#1
  beq SkipReg4cb9

  ;@ Copy memory to register:
;@ EaRead : Read '$33333333.l' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4cb9:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cb9

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cba] movem.w ($3333,pc), d0-d1/d4-d5/a0-a1/a4-a5; =3337 uses Op4cba ----------
Op4cba:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($3333,pc)' into r9:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r9,r2,r0,asr #8 ;@ ($nn,PC)
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cba:
  tst r11,#1
  beq SkipReg4cba

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,pc)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4cba:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cba

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cbb] movem.w ($33,pc,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5; =37 uses Op4cbb ----------
Op4cbb:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r9:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r9,r2,r0,asr #8 ;@ r9=Disp+PC+Rn
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cbb:
  tst r11,#1
  beq SkipReg4cbb

  ;@ Copy memory to register:
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4cbb:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cbb

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cd0] movem.l (a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cd0 ----------
Op4cd0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r9,[r7,r2,lsl #2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cd0:
  tst r11,#1
  beq SkipReg4cd0

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cd0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cd0

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cd8] movem.l (a0)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cd8 ----------
Op4cd8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r9,[r7,r2,lsl #2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cd8:
  tst r11,#1
  beq SkipReg4cd8

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)+' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cd8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cd8

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cdf] movem.l (a7)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cdf ----------
Op4cdf:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r9,[r7,r2,lsl #2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cdf:
  tst r11,#1
  beq SkipReg4cdf

  ;@ Copy memory to register:
;@ EaRead : Read '(a7)+' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cdf:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cdf

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ce8] movem.l ($3333,a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4ce8 ----------
Op4ce8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($3333,a0)' into r9:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r9,r0,r2 ;@ Add on offset
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4ce8:
  tst r11,#1
  beq SkipReg4ce8

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,a0)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4ce8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4ce8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cf0] movem.l ($33,a0,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf0 ----------
Op4cf0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r9:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r9,r2,r3 ;@ r9=Disp+An+Rn
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cf0:
  tst r11,#1
  beq SkipReg4cf0

  ;@ Copy memory to register:
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cf0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cf0

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cf8] movem.l $3333.w, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf8 ----------
Op4cf8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$3333.w' into r9:
  ldrsh r9,[r4],#2 ;@ Fetch Absolute Short address
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cf8:
  tst r11,#1
  beq SkipReg4cf8

  ;@ Copy memory to register:
;@ EaRead : Read '$3333.w' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cf8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cf8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cf9] movem.l $33333333.l, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf9 ----------
Op4cf9:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$33333333.l' into r9:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r9,r0,r2,lsl #16
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cf9:
  tst r11,#1
  beq SkipReg4cf9

  ;@ Copy memory to register:
;@ EaRead : Read '$33333333.l' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cf9:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cf9

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cfa] movem.l ($3333,pc), d0-d1/d4-d5/a0-a1/a4-a5; =3337 uses Op4cfa ----------
Op4cfa:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($3333,pc)' into r9:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r9,r2,r0,asr #8 ;@ ($nn,PC)
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cfa:
  tst r11,#1
  beq SkipReg4cfa

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,pc)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cfa:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cfa

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cfb] movem.l ($33,pc,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5; =37 uses Op4cfb ----------
Op4cfb:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r9:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r9,r2,r0,asr #8 ;@ r9=Disp+PC+Rn
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cfb:
  tst r11,#1
  beq SkipReg4cfb

  ;@ Copy memory to register:
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cfb:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cfb

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e40] trap #0 uses Op4e40 ----------
Op4e40:
  and r0,r8,#0xf ;@ Get trap number
  orr r0,r0,#0x20
  mov r0,r0,asl #2
  bl Exception

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#38 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e50] link a0,#$3333 uses Op4e50 ----------
Op4e50:
;@ Get An
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  orr r10,r10,#0x8 ;@ A0-7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsl #2]

  ldr r0,[r7,#0x3c] ;@ Get A7
  sub r0,r0,#4 ;@ A7-=4
  mov r11,r0

;@ Write An to Stack
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler
;@ Save to An
;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsl #2]

;@ Get offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  add r11,r11,r0 ;@ Add offset to A7
  str r11,[r7,#0x3c]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e57] link a7,#$3333 uses Op4e57 ----------
Op4e57:
  ldr r0,[r7,#0x3c] ;@ Get A7
  sub r0,r0,#4 ;@ A7-=4
  mov r11,r0
  mov r1,r0

;@ Write An to Stack
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler
;@ Save to An
;@ Get offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  add r11,r11,r0 ;@ Add offset to A7
  str r11,[r7,#0x3c]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e58] unlk a0 uses Op4e58 ----------
Op4e58:
;@ Get An
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  orr r10,r10,#0x8 ;@ A0-7
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  add r11,r0,#4 ;@ A7+=4

;@ Pop An from stack:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r11,[r7,#0x3c] ;@ Save A7

;@ An = value from stack:
;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e60] move a0, usp uses Op4e60 ----------
Op4e60:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode4e60 ;@ No

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  str r0,[r7,#0x48] ;@ Put in USP

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode4e60:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e68] move usp, a0 uses Op4e68 ----------
Op4e68:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode4e68 ;@ No

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
  ldr r1,[r7,#0x48] ;@ Get from USP

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode4e68:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e70] reset uses Op4e70 ----------
Op4e70:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode4e70 ;@ No

  str r4,[r7,#0x40] ;@ Save PC
  mov r1,r9,lsr #28
  strb r1,[r7,#0x46] ;@ Save Flags (NZCV)
  str r5,[r7,#0x5c] ;@ Save Cycles
  ldr r11,[r7,#0x90] ;@ ResetCallback
  tst r11,r11
  movne lr,pc
  movne pc,r11 ;@ call ResetCallback if it is defined
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrb r9,[r7,#0x46] ;@ r9 = Load Flags (NZCV)
  mov r9,r9,lsl #28
  ldr r4,[r7,#0x40] ;@ Load PC
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#132 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode4e70:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e71] nop uses Op4e71 ----------
Op4e71:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e72] stop uses Op4e72 ----------
Op4e72:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode4e72 ;@ No

  ldrh r0,[r4],#2 ;@ Fetch the immediate
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap4e72
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap4e72:

  mov r0,#1
  str r0,[r7,#0x58] ;@ stopped

  mov r5,#0 ;@ eat cycles

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode4e72:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e73] rte uses Op4e73 ----------
Op4e73:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode4e73 ;@ No

;@ Pop SR:
  ldr r0,[r7,#0x3c]
  add r1,r0,#2 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

  ldr r10,[r7,#0x60] ;@ Get Memory base
;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  add r4,r0,r10 ;@ r4=Memory Base+PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap4e73
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap4e73:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  beq NoInts4e73
  cmp r0,#6 ;@ irq>6 ?
  ldrleb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  blgt DoInterrupt
NoInts4e73:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode4e73:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e75] rts uses Op4e75 ----------
Op4e75:
  ldr r10,[r7,#0x60] ;@ Get Memory base
;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  add r4,r0,r10 ;@ r4=Memory Base+PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e76] trapv uses Op4e76 ----------
Op4e76:
  tst r9,#0x10000000
  subne r5,r5,#30
  movne r0,#0x1c ;@ TRAPV exception
  blne Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e77] rtr uses Op4e77 ----------
Op4e77:
;@ Pop SR:
  ldr r0,[r7,#0x3c]
  add r1,r0,#2 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldr r10,[r7,#0x60] ;@ Get Memory base
;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  add r4,r0,r10 ;@ r4=Memory Base+PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e90] jsr (a0) uses Op4e90 ----------
Op4e90:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC
  mov r1,r1,lsl #8
  mov r1,r1,asr #8

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ea8] jsr ($3333,a0) uses Op4ea8 ----------
Op4ea8:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC
  mov r1,r1,lsl #8
  mov r1,r1,asr #8

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eb0] jsr ($33,a0,d3.w*2) uses Op4eb0 ----------
Op4eb0:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC
  mov r1,r1,lsl #8
  mov r1,r1,asr #8

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eb8] jsr $3333.w uses Op4eb8 ----------
Op4eb8:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC
  mov r1,r1,lsl #8
  mov r1,r1,asr #8

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eb9] jsr $33333333.l uses Op4eb9 ----------
Op4eb9:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC
  mov r1,r1,lsl #8
  mov r1,r1,asr #8

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eba] jsr ($3333,pc); =3335 uses Op4eba ----------
Op4eba:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC
  mov r1,r1,lsl #8
  mov r1,r1,asr #8

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ebb] jsr ($33,pc,d3.w*2); =35 uses Op4ebb ----------
Op4ebb:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC
  mov r1,r1,lsl #8
  mov r1,r1,asr #8

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ed0] jmp (a0) uses Op4ed0 ----------
Op4ed0:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ee8] jmp ($3333,a0) uses Op4ee8 ----------
Op4ee8:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ef0] jmp ($33,a0,d3.w*2) uses Op4ef0 ----------
Op4ef0:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ef8] jmp $3333.w uses Op4ef8 ----------
Op4ef8:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ef9] jmp $33333333.l uses Op4ef9 ----------
Op4ef9:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4efa] jmp ($3333,pc); =3335 uses Op4efa ----------
Op4efa:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4efb] jmp ($33,pc,d3.w*2); =35 uses Op4efb ----------
Op4efb:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5000] addq.b #8, d0 uses Op5000 ----------
Op5000:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5010] addq.b #8, (a0) uses Op5010 ----------
Op5010:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5018] addq.b #8, (a0)+ uses Op5018 ----------
Op5018:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [501f] addq.b #8, (a7)+ uses Op501f ----------
Op501f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5020] addq.b #8, -(a0) uses Op5020 ----------
Op5020:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5027] addq.b #8, -(a7) uses Op5027 ----------
Op5027:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5028] addq.b #8, ($3333,a0) uses Op5028 ----------
Op5028:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5030] addq.b #8, ($33,a0,d3.w*2) uses Op5030 ----------
Op5030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5038] addq.b #8, $3333.w uses Op5038 ----------
Op5038:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5039] addq.b #8, $33333333.l uses Op5039 ----------
Op5039:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5040] addq.w #8, d0 uses Op5040 ----------
Op5040:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5048] addq.w #8, a0 uses Op5048 ----------
Op5048:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  adds r1,r0,#0x0008

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5050] addq.w #8, (a0) uses Op5050 ----------
Op5050:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5058] addq.w #8, (a0)+ uses Op5058 ----------
Op5058:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [505f] addq.w #8, (a7)+ uses Op505f ----------
Op505f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5060] addq.w #8, -(a0) uses Op5060 ----------
Op5060:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5067] addq.w #8, -(a7) uses Op5067 ----------
Op5067:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5068] addq.w #8, ($3333,a0) uses Op5068 ----------
Op5068:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5070] addq.w #8, ($33,a0,d3.w*2) uses Op5070 ----------
Op5070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5078] addq.w #8, $3333.w uses Op5078 ----------
Op5078:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5079] addq.w #8, $33333333.l uses Op5079 ----------
Op5079:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5080] addq.l #8, d0 uses Op5080 ----------
Op5080:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5088] addq.l #8, a0 uses Op5088 ----------
Op5088:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  adds r1,r0,#0x0008

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5090] addq.l #8, (a0) uses Op5090 ----------
Op5090:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5098] addq.l #8, (a0)+ uses Op5098 ----------
Op5098:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [509f] addq.l #8, (a7)+ uses Op509f ----------
Op509f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50a0] addq.l #8, -(a0) uses Op50a0 ----------
Op50a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50a7] addq.l #8, -(a7) uses Op50a7 ----------
Op50a7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50a8] addq.l #8, ($3333,a0) uses Op50a8 ----------
Op50a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50b0] addq.l #8, ($33,a0,d3.w*2) uses Op50b0 ----------
Op50b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50b8] addq.l #8, $3333.w uses Op50b8 ----------
Op50b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50b9] addq.l #8, $33333333.l uses Op50b9 ----------
Op50b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50c0] st d0 uses Op50c0 ----------
Op50c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1
  subal r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50c8] dbt d0, 3335 uses Op50c8 ----------
Op50c8:
;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin150c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin150c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue50c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50d0] st (a0) uses Op50d0 ----------
Op50d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50d8] st (a0)+ uses Op50d8 ----------
Op50d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50df] st (a7)+ uses Op50df ----------
Op50df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50e0] st -(a0) uses Op50e0 ----------
Op50e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50e7] st -(a7) uses Op50e7 ----------
Op50e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50e8] st ($3333,a0) uses Op50e8 ----------
Op50e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50f0] st ($33,a0,d3.w*2) uses Op50f0 ----------
Op50f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50f8] st $3333.w uses Op50f8 ----------
Op50f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50f9] st $33333333.l uses Op50f9 ----------
Op50f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5100] subq.b #8, d0 uses Op5100 ----------
Op5100:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5110] subq.b #8, (a0) uses Op5110 ----------
Op5110:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5118] subq.b #8, (a0)+ uses Op5118 ----------
Op5118:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [511f] subq.b #8, (a7)+ uses Op511f ----------
Op511f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5120] subq.b #8, -(a0) uses Op5120 ----------
Op5120:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5127] subq.b #8, -(a7) uses Op5127 ----------
Op5127:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5128] subq.b #8, ($3333,a0) uses Op5128 ----------
Op5128:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5130] subq.b #8, ($33,a0,d3.w*2) uses Op5130 ----------
Op5130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5138] subq.b #8, $3333.w uses Op5138 ----------
Op5138:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5139] subq.b #8, $33333333.l uses Op5139 ----------
Op5139:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5140] subq.w #8, d0 uses Op5140 ----------
Op5140:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5148] subq.w #8, a0 uses Op5148 ----------
Op5148:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  subs r1,r0,#0x0008

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5150] subq.w #8, (a0) uses Op5150 ----------
Op5150:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5158] subq.w #8, (a0)+ uses Op5158 ----------
Op5158:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [515f] subq.w #8, (a7)+ uses Op515f ----------
Op515f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5160] subq.w #8, -(a0) uses Op5160 ----------
Op5160:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5167] subq.w #8, -(a7) uses Op5167 ----------
Op5167:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5168] subq.w #8, ($3333,a0) uses Op5168 ----------
Op5168:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5170] subq.w #8, ($33,a0,d3.w*2) uses Op5170 ----------
Op5170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5178] subq.w #8, $3333.w uses Op5178 ----------
Op5178:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5179] subq.w #8, $33333333.l uses Op5179 ----------
Op5179:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5180] subq.l #8, d0 uses Op5180 ----------
Op5180:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5188] subq.l #8, a0 uses Op5188 ----------
Op5188:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  subs r1,r0,#0x0008

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5190] subq.l #8, (a0) uses Op5190 ----------
Op5190:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5198] subq.l #8, (a0)+ uses Op5198 ----------
Op5198:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [519f] subq.l #8, (a7)+ uses Op519f ----------
Op519f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51a0] subq.l #8, -(a0) uses Op51a0 ----------
Op51a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51a7] subq.l #8, -(a7) uses Op51a7 ----------
Op51a7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51a8] subq.l #8, ($3333,a0) uses Op51a8 ----------
Op51a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51b0] subq.l #8, ($33,a0,d3.w*2) uses Op51b0 ----------
Op51b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51b8] subq.l #8, $3333.w uses Op51b8 ----------
Op51b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51b9] subq.l #8, $33333333.l uses Op51b9 ----------
Op51b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51c0] sf d0 uses Op51c0 ----------
Op51c0:
  mov r1,#0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51c8] dbra d0, 3335 uses Op51c8 ----------
Op51c8:
;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin151c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin151c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue51c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51d0] sf (a0) uses Op51d0 ----------
Op51d0:
  mov r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51d8] sf (a0)+ uses Op51d8 ----------
Op51d8:
  mov r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51df] sf (a7)+ uses Op51df ----------
Op51df:
  mov r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51e0] sf -(a0) uses Op51e0 ----------
Op51e0:
  mov r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51e7] sf -(a7) uses Op51e7 ----------
Op51e7:
  mov r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51e8] sf ($3333,a0) uses Op51e8 ----------
Op51e8:
  mov r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51f0] sf ($33,a0,d3.w*2) uses Op51f0 ----------
Op51f0:
  mov r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51f8] sf $3333.w uses Op51f8 ----------
Op51f8:
  mov r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51f9] sf $33333333.l uses Op51f9 ----------
Op51f9:
  mov r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52c0] shi d0 uses Op52c0 ----------
Op52c0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1
  subhi r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52c8] dbhi d0, 3335 uses Op52c8 ----------
Op52c8:
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
;@ If so, don't dbra
  bhi DbraTrue52c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin152c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin152c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue52c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52d0] shi (a0) uses Op52d0 ----------
Op52d0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52d8] shi (a0)+ uses Op52d8 ----------
Op52d8:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52df] shi (a7)+ uses Op52df ----------
Op52df:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52e0] shi -(a0) uses Op52e0 ----------
Op52e0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52e7] shi -(a7) uses Op52e7 ----------
Op52e7:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52e8] shi ($3333,a0) uses Op52e8 ----------
Op52e8:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52f0] shi ($33,a0,d3.w*2) uses Op52f0 ----------
Op52f0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52f8] shi $3333.w uses Op52f8 ----------
Op52f8:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52f9] shi $33333333.l uses Op52f9 ----------
Op52f9:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53c0] sls d0 uses Op53c0 ----------
Op53c0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1
  subls r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53c8] dbls d0, 3335 uses Op53c8 ----------
Op53c8:
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
;@ If so, don't dbra
  bls DbraTrue53c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin153c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin153c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue53c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53d0] sls (a0) uses Op53d0 ----------
Op53d0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53d8] sls (a0)+ uses Op53d8 ----------
Op53d8:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53df] sls (a7)+ uses Op53df ----------
Op53df:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53e0] sls -(a0) uses Op53e0 ----------
Op53e0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53e7] sls -(a7) uses Op53e7 ----------
Op53e7:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53e8] sls ($3333,a0) uses Op53e8 ----------
Op53e8:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53f0] sls ($33,a0,d3.w*2) uses Op53f0 ----------
Op53f0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53f8] sls $3333.w uses Op53f8 ----------
Op53f8:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53f9] sls $33333333.l uses Op53f9 ----------
Op53f9:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54c0] scc d0 uses Op54c0 ----------
Op54c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1
  subcc r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54c8] dbcc d0, 3335 uses Op54c8 ----------
Op54c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bcc DbraTrue54c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin154c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin154c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue54c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54d0] scc (a0) uses Op54d0 ----------
Op54d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54d8] scc (a0)+ uses Op54d8 ----------
Op54d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54df] scc (a7)+ uses Op54df ----------
Op54df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54e0] scc -(a0) uses Op54e0 ----------
Op54e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54e7] scc -(a7) uses Op54e7 ----------
Op54e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54e8] scc ($3333,a0) uses Op54e8 ----------
Op54e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54f0] scc ($33,a0,d3.w*2) uses Op54f0 ----------
Op54f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54f8] scc $3333.w uses Op54f8 ----------
Op54f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54f9] scc $33333333.l uses Op54f9 ----------
Op54f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55c0] scs d0 uses Op55c0 ----------
Op55c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1
  subcs r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55c8] dbcs d0, 3335 uses Op55c8 ----------
Op55c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bcs DbraTrue55c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin155c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin155c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue55c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55d0] scs (a0) uses Op55d0 ----------
Op55d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55d8] scs (a0)+ uses Op55d8 ----------
Op55d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55df] scs (a7)+ uses Op55df ----------
Op55df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55e0] scs -(a0) uses Op55e0 ----------
Op55e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55e7] scs -(a7) uses Op55e7 ----------
Op55e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55e8] scs ($3333,a0) uses Op55e8 ----------
Op55e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55f0] scs ($33,a0,d3.w*2) uses Op55f0 ----------
Op55f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55f8] scs $3333.w uses Op55f8 ----------
Op55f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55f9] scs $33333333.l uses Op55f9 ----------
Op55f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56c0] sne d0 uses Op56c0 ----------
Op56c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1
  subne r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56c8] dbne d0, 3335 uses Op56c8 ----------
Op56c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bne DbraTrue56c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin156c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin156c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue56c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56d0] sne (a0) uses Op56d0 ----------
Op56d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56d8] sne (a0)+ uses Op56d8 ----------
Op56d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56df] sne (a7)+ uses Op56df ----------
Op56df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56e0] sne -(a0) uses Op56e0 ----------
Op56e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56e7] sne -(a7) uses Op56e7 ----------
Op56e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56e8] sne ($3333,a0) uses Op56e8 ----------
Op56e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56f0] sne ($33,a0,d3.w*2) uses Op56f0 ----------
Op56f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56f8] sne $3333.w uses Op56f8 ----------
Op56f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56f9] sne $33333333.l uses Op56f9 ----------
Op56f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57c0] seq d0 uses Op57c0 ----------
Op57c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1
  subeq r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57c8] dbeq d0, 3335 uses Op57c8 ----------
Op57c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  beq DbraTrue57c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin157c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin157c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue57c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57d0] seq (a0) uses Op57d0 ----------
Op57d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57d8] seq (a0)+ uses Op57d8 ----------
Op57d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57df] seq (a7)+ uses Op57df ----------
Op57df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57e0] seq -(a0) uses Op57e0 ----------
Op57e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57e7] seq -(a7) uses Op57e7 ----------
Op57e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57e8] seq ($3333,a0) uses Op57e8 ----------
Op57e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57f0] seq ($33,a0,d3.w*2) uses Op57f0 ----------
Op57f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57f8] seq $3333.w uses Op57f8 ----------
Op57f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57f9] seq $33333333.l uses Op57f9 ----------
Op57f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58c0] svc d0 uses Op58c0 ----------
Op58c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1
  subvc r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58c8] dbvc d0, 3335 uses Op58c8 ----------
Op58c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bvc DbraTrue58c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin158c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin158c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue58c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58d0] svc (a0) uses Op58d0 ----------
Op58d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58d8] svc (a0)+ uses Op58d8 ----------
Op58d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58df] svc (a7)+ uses Op58df ----------
Op58df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58e0] svc -(a0) uses Op58e0 ----------
Op58e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58e7] svc -(a7) uses Op58e7 ----------
Op58e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58e8] svc ($3333,a0) uses Op58e8 ----------
Op58e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58f0] svc ($33,a0,d3.w*2) uses Op58f0 ----------
Op58f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58f8] svc $3333.w uses Op58f8 ----------
Op58f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58f9] svc $33333333.l uses Op58f9 ----------
Op58f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59c0] svs d0 uses Op59c0 ----------
Op59c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1
  subvs r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59c8] dbvs d0, 3335 uses Op59c8 ----------
Op59c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bvs DbraTrue59c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin159c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin159c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue59c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59d0] svs (a0) uses Op59d0 ----------
Op59d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59d8] svs (a0)+ uses Op59d8 ----------
Op59d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59df] svs (a7)+ uses Op59df ----------
Op59df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59e0] svs -(a0) uses Op59e0 ----------
Op59e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59e7] svs -(a7) uses Op59e7 ----------
Op59e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59e8] svs ($3333,a0) uses Op59e8 ----------
Op59e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59f0] svs ($33,a0,d3.w*2) uses Op59f0 ----------
Op59f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59f8] svs $3333.w uses Op59f8 ----------
Op59f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59f9] svs $33333333.l uses Op59f9 ----------
Op59f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ac0] spl d0 uses Op5ac0 ----------
Op5ac0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1
  subpl r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ac8] dbpl d0, 3335 uses Op5ac8 ----------
Op5ac8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bpl DbraTrue5ac8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin15ac8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin15ac8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue5ac8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ad0] spl (a0) uses Op5ad0 ----------
Op5ad0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ad8] spl (a0)+ uses Op5ad8 ----------
Op5ad8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5adf] spl (a7)+ uses Op5adf ----------
Op5adf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ae0] spl -(a0) uses Op5ae0 ----------
Op5ae0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ae7] spl -(a7) uses Op5ae7 ----------
Op5ae7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ae8] spl ($3333,a0) uses Op5ae8 ----------
Op5ae8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5af0] spl ($33,a0,d3.w*2) uses Op5af0 ----------
Op5af0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5af8] spl $3333.w uses Op5af8 ----------
Op5af8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5af9] spl $33333333.l uses Op5af9 ----------
Op5af9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bc0] smi d0 uses Op5bc0 ----------
Op5bc0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1
  submi r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bc8] dbmi d0, 3335 uses Op5bc8 ----------
Op5bc8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bmi DbraTrue5bc8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin15bc8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin15bc8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue5bc8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bd0] smi (a0) uses Op5bd0 ----------
Op5bd0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bd8] smi (a0)+ uses Op5bd8 ----------
Op5bd8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bdf] smi (a7)+ uses Op5bdf ----------
Op5bdf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5be0] smi -(a0) uses Op5be0 ----------
Op5be0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5be7] smi -(a7) uses Op5be7 ----------
Op5be7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5be8] smi ($3333,a0) uses Op5be8 ----------
Op5be8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bf0] smi ($33,a0,d3.w*2) uses Op5bf0 ----------
Op5bf0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bf8] smi $3333.w uses Op5bf8 ----------
Op5bf8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bf9] smi $33333333.l uses Op5bf9 ----------
Op5bf9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cc0] sge d0 uses Op5cc0 ----------
Op5cc0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1
  subge r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cc8] dbge d0, 3335 uses Op5cc8 ----------
Op5cc8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bge DbraTrue5cc8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin15cc8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin15cc8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue5cc8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cd0] sge (a0) uses Op5cd0 ----------
Op5cd0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cd8] sge (a0)+ uses Op5cd8 ----------
Op5cd8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cdf] sge (a7)+ uses Op5cdf ----------
Op5cdf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ce0] sge -(a0) uses Op5ce0 ----------
Op5ce0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ce7] sge -(a7) uses Op5ce7 ----------
Op5ce7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ce8] sge ($3333,a0) uses Op5ce8 ----------
Op5ce8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cf0] sge ($33,a0,d3.w*2) uses Op5cf0 ----------
Op5cf0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cf8] sge $3333.w uses Op5cf8 ----------
Op5cf8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cf9] sge $33333333.l uses Op5cf9 ----------
Op5cf9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dc0] slt d0 uses Op5dc0 ----------
Op5dc0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1
  sublt r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dc8] dblt d0, 3335 uses Op5dc8 ----------
Op5dc8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  blt DbraTrue5dc8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin15dc8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin15dc8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue5dc8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dd0] slt (a0) uses Op5dd0 ----------
Op5dd0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dd8] slt (a0)+ uses Op5dd8 ----------
Op5dd8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ddf] slt (a7)+ uses Op5ddf ----------
Op5ddf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5de0] slt -(a0) uses Op5de0 ----------
Op5de0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5de7] slt -(a7) uses Op5de7 ----------
Op5de7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5de8] slt ($3333,a0) uses Op5de8 ----------
Op5de8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5df0] slt ($33,a0,d3.w*2) uses Op5df0 ----------
Op5df0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5df8] slt $3333.w uses Op5df8 ----------
Op5df8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5df9] slt $33333333.l uses Op5df9 ----------
Op5df9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e00] addq.b #7, d0 uses Op5e00 ----------
Op5e00:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e10] addq.b #7, (a0) uses Op5e10 ----------
Op5e10:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e18] addq.b #7, (a0)+ uses Op5e18 ----------
Op5e18:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e1f] addq.b #7, (a7)+ uses Op5e1f ----------
Op5e1f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e20] addq.b #7, -(a0) uses Op5e20 ----------
Op5e20:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e27] addq.b #7, -(a7) uses Op5e27 ----------
Op5e27:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e28] addq.b #7, ($3333,a0) uses Op5e28 ----------
Op5e28:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e30] addq.b #7, ($33,a0,d3.w*2) uses Op5e30 ----------
Op5e30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e38] addq.b #7, $3333.w uses Op5e38 ----------
Op5e38:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e39] addq.b #7, $33333333.l uses Op5e39 ----------
Op5e39:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e40] addq.w #7, d0 uses Op5e40 ----------
Op5e40:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e48] addq.w #7, a0 uses Op5e48 ----------
Op5e48:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e50] addq.w #7, (a0) uses Op5e50 ----------
Op5e50:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e58] addq.w #7, (a0)+ uses Op5e58 ----------
Op5e58:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e5f] addq.w #7, (a7)+ uses Op5e5f ----------
Op5e5f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e60] addq.w #7, -(a0) uses Op5e60 ----------
Op5e60:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e67] addq.w #7, -(a7) uses Op5e67 ----------
Op5e67:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e68] addq.w #7, ($3333,a0) uses Op5e68 ----------
Op5e68:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e70] addq.w #7, ($33,a0,d3.w*2) uses Op5e70 ----------
Op5e70:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e78] addq.w #7, $3333.w uses Op5e78 ----------
Op5e78:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e79] addq.w #7, $33333333.l uses Op5e79 ----------
Op5e79:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e80] addq.l #7, d0 uses Op5e80 ----------
Op5e80:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e88] addq.l #7, a0 uses Op5e88 ----------
Op5e88:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e90] addq.l #7, (a0) uses Op5e90 ----------
Op5e90:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e98] addq.l #7, (a0)+ uses Op5e98 ----------
Op5e98:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e9f] addq.l #7, (a7)+ uses Op5e9f ----------
Op5e9f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ea0] addq.l #7, -(a0) uses Op5ea0 ----------
Op5ea0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ea7] addq.l #7, -(a7) uses Op5ea7 ----------
Op5ea7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ea8] addq.l #7, ($3333,a0) uses Op5ea8 ----------
Op5ea8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5eb0] addq.l #7, ($33,a0,d3.w*2) uses Op5eb0 ----------
Op5eb0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5eb8] addq.l #7, $3333.w uses Op5eb8 ----------
Op5eb8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5eb9] addq.l #7, $33333333.l uses Op5eb9 ----------
Op5eb9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ec0] sgt d0 uses Op5ec0 ----------
Op5ec0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1
  subgt r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ec8] dbgt d0, 3335 uses Op5ec8 ----------
Op5ec8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bgt DbraTrue5ec8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin15ec8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin15ec8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue5ec8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ed0] sgt (a0) uses Op5ed0 ----------
Op5ed0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ed8] sgt (a0)+ uses Op5ed8 ----------
Op5ed8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5edf] sgt (a7)+ uses Op5edf ----------
Op5edf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ee0] sgt -(a0) uses Op5ee0 ----------
Op5ee0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ee7] sgt -(a7) uses Op5ee7 ----------
Op5ee7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ee8] sgt ($3333,a0) uses Op5ee8 ----------
Op5ee8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ef0] sgt ($33,a0,d3.w*2) uses Op5ef0 ----------
Op5ef0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ef8] sgt $3333.w uses Op5ef8 ----------
Op5ef8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ef9] sgt $33333333.l uses Op5ef9 ----------
Op5ef9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f00] subq.b #7, d0 uses Op5f00 ----------
Op5f00:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f10] subq.b #7, (a0) uses Op5f10 ----------
Op5f10:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f18] subq.b #7, (a0)+ uses Op5f18 ----------
Op5f18:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f1f] subq.b #7, (a7)+ uses Op5f1f ----------
Op5f1f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f20] subq.b #7, -(a0) uses Op5f20 ----------
Op5f20:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f27] subq.b #7, -(a7) uses Op5f27 ----------
Op5f27:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f28] subq.b #7, ($3333,a0) uses Op5f28 ----------
Op5f28:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f30] subq.b #7, ($33,a0,d3.w*2) uses Op5f30 ----------
Op5f30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f38] subq.b #7, $3333.w uses Op5f38 ----------
Op5f38:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f39] subq.b #7, $33333333.l uses Op5f39 ----------
Op5f39:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f40] subq.w #7, d0 uses Op5f40 ----------
Op5f40:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f48] subq.w #7, a0 uses Op5f48 ----------
Op5f48:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f50] subq.w #7, (a0) uses Op5f50 ----------
Op5f50:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f58] subq.w #7, (a0)+ uses Op5f58 ----------
Op5f58:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f5f] subq.w #7, (a7)+ uses Op5f5f ----------
Op5f5f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f60] subq.w #7, -(a0) uses Op5f60 ----------
Op5f60:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f67] subq.w #7, -(a7) uses Op5f67 ----------
Op5f67:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f68] subq.w #7, ($3333,a0) uses Op5f68 ----------
Op5f68:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f70] subq.w #7, ($33,a0,d3.w*2) uses Op5f70 ----------
Op5f70:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f78] subq.w #7, $3333.w uses Op5f78 ----------
Op5f78:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f79] subq.w #7, $33333333.l uses Op5f79 ----------
Op5f79:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f80] subq.l #7, d0 uses Op5f80 ----------
Op5f80:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f88] subq.l #7, a0 uses Op5f88 ----------
Op5f88:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f90] subq.l #7, (a0) uses Op5f90 ----------
Op5f90:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f98] subq.l #7, (a0)+ uses Op5f98 ----------
Op5f98:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f9f] subq.l #7, (a7)+ uses Op5f9f ----------
Op5f9f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fa0] subq.l #7, -(a0) uses Op5fa0 ----------
Op5fa0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fa7] subq.l #7, -(a7) uses Op5fa7 ----------
Op5fa7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fa8] subq.l #7, ($3333,a0) uses Op5fa8 ----------
Op5fa8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fb0] subq.l #7, ($33,a0,d3.w*2) uses Op5fb0 ----------
Op5fb0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fb8] subq.l #7, $3333.w uses Op5fb8 ----------
Op5fb8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fb9] subq.l #7, $33333333.l uses Op5fb9 ----------
Op5fb9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fc0] sle d0 uses Op5fc0 ----------
Op5fc0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1
  suble r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fc8] dble d0, 3335 uses Op5fc8 ----------
Op5fc8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  ble DbraTrue5fc8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraMin15fc8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin15fc8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ condition true:
DbraTrue5fc8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fd0] sle (a0) uses Op5fd0 ----------
Op5fd0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fd8] sle (a0)+ uses Op5fd8 ----------
Op5fd8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fdf] sle (a7)+ uses Op5fdf ----------
Op5fdf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fe0] sle -(a0) uses Op5fe0 ----------
Op5fe0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fe7] sle -(a7) uses Op5fe7 ----------
Op5fe7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fe8] sle ($3333,a0) uses Op5fe8 ----------
Op5fe8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ff0] sle ($33,a0,d3.w*2) uses Op5ff0 ----------
Op5ff0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ff8] sle $3333.w uses Op5ff8 ----------
Op5ff8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ff9] sle $33333333.l uses Op5ff9 ----------
Op5ff9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6000] bra 3335 uses Op6000 ----------
Op6000:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6001] bra 3 uses Op6001 ----------
Op6001:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

  mov r0,r0,asr #24 ;@ ...shift down

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [60ff] bra 33333335 uses Op60ff ----------
Op60ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6100] bsr 3335 uses Op6100 ----------
Op6100:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r10,[r7,#0x60] ;@ Get Memory base
  sub r1,r4,r10 ;@ r1 = Old PC
  mov r1,r1, lsl #8
  mov r1,r1, asr #8

  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6101] bsr 3 uses Op6101 ----------
Op6101:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

  mov r0,r0,asr #24 ;@ ...shift down

;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r10,[r7,#0x60] ;@ Get Memory base
  sub r1,r4,r10 ;@ r1 = Old PC
  mov r1,r1, lsl #8
  mov r1,r1, asr #8

  add r4,r4,r0 ;@ r4 = New PC

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [61ff] bsr 33333335 uses Op61ff ----------
Op61ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r10,[r7,#0x60] ;@ Get Memory base
  sub r1,r4,r10 ;@ r1 = Old PC
  mov r1,r1, lsl #8
  mov r1,r1, asr #8

  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6200] bhi 3335 uses Op6200 ----------
Op6200:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
  bls DontBranch6200

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6200:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6201] bhi 3 uses Op6201 ----------
Op6201:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
  mov r0,r0,asr #24 ;@ ...shift down

  bls DontBranch6201

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6201:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [62ff] bhi 33333335 uses Op62ff ----------
Op62ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
  bls DontBranch62ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch62ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6300] bls 3335 uses Op6300 ----------
Op6300:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
  bhi DontBranch6300

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6300:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6301] bls 3 uses Op6301 ----------
Op6301:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
  mov r0,r0,asr #24 ;@ ...shift down

  bhi DontBranch6301

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6301:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [63ff] bls 33333335 uses Op63ff ----------
Op63ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
  bhi DontBranch63ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch63ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6400] bcc 3335 uses Op6400 ----------
Op6400:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bcs DontBranch6400

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6400:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6401] bcc 3 uses Op6401 ----------
Op6401:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bcs DontBranch6401

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6401:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [64ff] bcc 33333335 uses Op64ff ----------
Op64ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bcs DontBranch64ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch64ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6500] bcs 3335 uses Op6500 ----------
Op6500:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bcc DontBranch6500

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6500:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6501] bcs 3 uses Op6501 ----------
Op6501:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bcc DontBranch6501

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6501:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [65ff] bcs 33333335 uses Op65ff ----------
Op65ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bcc DontBranch65ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch65ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6600] bne 3335 uses Op6600 ----------
Op6600:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  beq DontBranch6600

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6600:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6601] bne 3 uses Op6601 ----------
Op6601:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  beq DontBranch6601

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6601:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [66ff] bne 33333335 uses Op66ff ----------
Op66ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  beq DontBranch66ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch66ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6700] beq 3335 uses Op6700 ----------
Op6700:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bne DontBranch6700

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6700:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6701] beq 3 uses Op6701 ----------
Op6701:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bne DontBranch6701

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6701:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [67ff] beq 33333335 uses Op67ff ----------
Op67ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bne DontBranch67ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch67ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6800] bvc 3335 uses Op6800 ----------
Op6800:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bvs DontBranch6800

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6800:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6801] bvc 3 uses Op6801 ----------
Op6801:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bvs DontBranch6801

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6801:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [68ff] bvc 33333335 uses Op68ff ----------
Op68ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bvs DontBranch68ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch68ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6900] bvs 3335 uses Op6900 ----------
Op6900:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bvc DontBranch6900

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6900:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6901] bvs 3 uses Op6901 ----------
Op6901:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bvc DontBranch6901

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6901:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [69ff] bvs 33333335 uses Op69ff ----------
Op69ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bvc DontBranch69ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch69ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6a00] bpl 3335 uses Op6a00 ----------
Op6a00:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bmi DontBranch6a00

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6a00:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6a01] bpl 3 uses Op6a01 ----------
Op6a01:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bmi DontBranch6a01

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6a01:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6aff] bpl 33333335 uses Op6aff ----------
Op6aff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bmi DontBranch6aff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6aff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6b00] bmi 3335 uses Op6b00 ----------
Op6b00:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bpl DontBranch6b00

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6b00:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6b01] bmi 3 uses Op6b01 ----------
Op6b01:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bpl DontBranch6b01

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6b01:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6bff] bmi 33333335 uses Op6bff ----------
Op6bff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bpl DontBranch6bff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6bff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6c00] bge 3335 uses Op6c00 ----------
Op6c00:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  blt DontBranch6c00

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6c00:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6c01] bge 3 uses Op6c01 ----------
Op6c01:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  blt DontBranch6c01

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6c01:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6cff] bge 33333335 uses Op6cff ----------
Op6cff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  blt DontBranch6cff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6cff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6d00] blt 3335 uses Op6d00 ----------
Op6d00:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bge DontBranch6d00

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6d00:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6d01] blt 3 uses Op6d01 ----------
Op6d01:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bge DontBranch6d01

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6d01:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6dff] blt 33333335 uses Op6dff ----------
Op6dff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bge DontBranch6dff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6dff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6e00] bgt 3335 uses Op6e00 ----------
Op6e00:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  ble DontBranch6e00

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6e00:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6e01] bgt 3 uses Op6e01 ----------
Op6e01:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  ble DontBranch6e01

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6e01:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6eff] bgt 33333335 uses Op6eff ----------
Op6eff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  ble DontBranch6eff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6eff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6f00] ble 3335 uses Op6f00 ----------
Op6f00:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bgt DontBranch6f00

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6f00:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6f01] ble 3 uses Op6f01 ----------
Op6f01:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bgt DontBranch6f01

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6f01:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6fff] ble 33333335 uses Op6fff ----------
Op6fff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bgt DontBranch6fff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6fff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [7000] moveq #$0, d0 uses Op7000 ----------
Op7000:
  movs r0,r8,asl #24
  and r1,r8,#0x0e00
  mov r0,r0,asr #24 ;@ Sign extended Quick value
  mrs r9,cpsr ;@ r9=NZ flags
  str r0,[r7,r1,lsr #7] ;@ Store into Dn

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8000] or.b d0, d0 uses Op8000 ----------
Op8000:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r11:
  ldrb r11,[r7,r10,lsl #2]
  mov r11,r11,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8010] or.b (a0), d0 uses Op8010 ----------
Op8010:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8018] or.b (a0)+, d0 uses Op8018 ----------
Op8018:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [801f] or.b (a7)+, d0 uses Op801f ----------
Op801f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8020] or.b -(a0), d0 uses Op8020 ----------
Op8020:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8027] or.b -(a7), d0 uses Op8027 ----------
Op8027:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8028] or.b ($3333,a0), d0 uses Op8028 ----------
Op8028:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8030] or.b ($33,a0,d3.w*2), d0 uses Op8030 ----------
Op8030:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8038] or.b $3333.w, d0 uses Op8038 ----------
Op8038:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8039] or.b $33333333.l, d0 uses Op8039 ----------
Op8039:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803a] or.b ($3333,pc), d0; =3335 uses Op803a ----------
Op803a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803b] or.b ($33,pc,d3.w*2), d0; =35 uses Op803b ----------
Op803b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803c] or.b #$33, d0 uses Op803c ----------
Op803c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r11:
  mov r11,r10,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8040] or.w d0, d0 uses Op8040 ----------
Op8040:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r11:
  ldrsh r11,[r7,r10]
  mov r11,r11,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8050] or.w (a0), d0 uses Op8050 ----------
Op8050:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8058] or.w (a0)+, d0 uses Op8058 ----------
Op8058:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [805f] or.w (a7)+, d0 uses Op805f ----------
Op805f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8060] or.w -(a0), d0 uses Op8060 ----------
Op8060:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8067] or.w -(a7), d0 uses Op8067 ----------
Op8067:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8068] or.w ($3333,a0), d0 uses Op8068 ----------
Op8068:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8070] or.w ($33,a0,d3.w*2), d0 uses Op8070 ----------
Op8070:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8078] or.w $3333.w, d0 uses Op8078 ----------
Op8078:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8079] or.w $33333333.l, d0 uses Op8079 ----------
Op8079:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807a] or.w ($3333,pc), d0; =3335 uses Op807a ----------
Op807a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807b] or.w ($33,pc,d3.w*2), d0; =35 uses Op807b ----------
Op807b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807c] or.w #$3333, d0 uses Op807c ----------
Op807c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r11:
  mov r11,r10,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8080] or.l d0, d0 uses Op8080 ----------
Op8080:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsl #2]

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8090] or.l (a0), d0 uses Op8090 ----------
Op8090:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8098] or.l (a0)+, d0 uses Op8098 ----------
Op8098:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [809f] or.l (a7)+, d0 uses Op809f ----------
Op809f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80a0] or.l -(a0), d0 uses Op80a0 ----------
Op80a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80a7] or.l -(a7), d0 uses Op80a7 ----------
Op80a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80a8] or.l ($3333,a0), d0 uses Op80a8 ----------
Op80a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80b0] or.l ($33,a0,d3.w*2), d0 uses Op80b0 ----------
Op80b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80b8] or.l $3333.w, d0 uses Op80b8 ----------
Op80b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80b9] or.l $33333333.l, d0 uses Op80b9 ----------
Op80b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80ba] or.l ($3333,pc), d0; =3335 uses Op80ba ----------
Op80ba:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80bb] or.l ($33,pc,d3.w*2), d0; =35 uses Op80bb ----------
Op80bb:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80bc] or.l #$33333333, d0 uses Op80bc ----------
Op80bc:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r11:
  mov r11,r10,asl #0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80c0] divu.w d0, d0 uses Op80c0 ----------
Op80c0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r10:
  ldrsh r10,[r7,r10]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero80c0 ;@ division by zero

  mov r10,r10,lsl #16 ;@ use only 16 bits of divisor
  mov r10,r10,lsr #16
;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift80c0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80c0

Divide80c0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide80c0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80c0 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop80c0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#140 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80c0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#178 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80d0] divu.w (a0), d0 uses Op80d0 ----------
Op80d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero80d0 ;@ division by zero

  mov r10,r10,lsl #16 ;@ use only 16 bits of divisor
  mov r10,r10,lsr #16
;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift80d0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80d0

Divide80d0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide80d0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80d0 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop80d0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#144 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80d0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#182 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80d8] divu.w (a0)+, d0 uses Op80d8 ----------
Op80d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero80d8 ;@ division by zero

  mov r10,r10,lsl #16 ;@ use only 16 bits of divisor
  mov r10,r10,lsr #16
;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift80d8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80d8

Divide80d8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide80d8

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80d8 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop80d8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#144 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80d8:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#182 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80df] divu.w (a7)+, d0 uses Op80df ----------
Op80df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero80df ;@ division by zero

  mov r10,r10,lsl #16 ;@ use only 16 bits of divisor
  mov r10,r10,lsr #16
;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift80df:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80df

Divide80df:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide80df

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80df ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop80df:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#144 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80df:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#182 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80e0] divu.w -(a0), d0 uses Op80e0 ----------
Op80e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero80e0 ;@ division by zero

  mov r10,r10,lsl #16 ;@ use only 16 bits of divisor
  mov r10,r10,lsr #16
;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift80e0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80e0

Divide80e0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide80e0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80e0 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop80e0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#146 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80e0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#184 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80e7] divu.w -(a7), d0 uses Op80e7 ----------
Op80e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero80e7 ;@ division by zero

  mov r10,r10,lsl #16 ;@ use only 16 bits of divisor
  mov r10,r10,lsr #16
;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift80e7:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80e7

Divide80e7:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide80e7

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80e7 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop80e7:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#146 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80e7:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#184 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80e8] divu.w ($3333,a0), d0 uses Op80e8 ----------
Op80e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero80e8 ;@ division by zero

  mov r10,r10,lsl #16 ;@ use only 16 bits of divisor
  mov r10,r10,lsr #16
;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift80e8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80e8

Divide80e8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide80e8

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80e8 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop80e8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#148 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80e8:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#186 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80f0] divu.w ($33,a0,d3.w*2), d0 uses Op80f0 ----------
Op80f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero80f0 ;@ division by zero

  mov r10,r10,lsl #16 ;@ use only 16 bits of divisor
  mov r10,r10,lsr #16
;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift80f0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80f0

Divide80f0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide80f0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80f0 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop80f0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#150 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80f0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#188 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80f8] divu.w $3333.w, d0 uses Op80f8 ----------
Op80f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero80f8 ;@ division by zero

  mov r10,r10,lsl #16 ;@ use only 16 bits of divisor
  mov r10,r10,lsr #16
;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift80f8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80f8

Divide80f8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide80f8

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80f8 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop80f8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#148 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80f8:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#186 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80f9] divu.w $33333333.l, d0 uses Op80f9 ----------
Op80f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero80f9 ;@ division by zero

  mov r10,r10,lsl #16 ;@ use only 16 bits of divisor
  mov r10,r10,lsr #16
;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift80f9:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80f9

Divide80f9:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide80f9

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80f9 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop80f9:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#152 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80f9:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#190 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80fa] divu.w ($3333,pc), d0; =3335 uses Op80fa ----------
Op80fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero80fa ;@ division by zero

  mov r10,r10,lsl #16 ;@ use only 16 bits of divisor
  mov r10,r10,lsr #16
;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift80fa:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80fa

Divide80fa:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide80fa

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80fa ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop80fa:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#148 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80fa:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#186 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80fb] divu.w ($33,pc,d3.w*2), d0; =35 uses Op80fb ----------
Op80fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero80fb ;@ division by zero

  mov r10,r10,lsl #16 ;@ use only 16 bits of divisor
  mov r10,r10,lsr #16
;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift80fb:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80fb

Divide80fb:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide80fb

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80fb ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop80fb:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#150 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80fb:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#188 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80fc] divu.w #$3333, d0 uses Op80fc ----------
Op80fc:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero80fc ;@ division by zero

  mov r10,r10,lsl #16 ;@ use only 16 bits of divisor
  mov r10,r10,lsr #16
;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift80fc:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80fc

Divide80fc:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide80fc

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80fc ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop80fc:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#144 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80fc:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#182 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [8100] sbcd d0, d0 uses Op8100 ----------
Op8100:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
;@ EaRead : Read register[r0] into r10:
  ldrb r10,[r7,r0,lsl #2]
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldrb r1,[r7,r11,lsr #7]
  mov r1,r1,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: r0 into register[r11]:
  mov r0,r0,asr #24
  strb r0,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8108] sbcd -(a0), -(a0) uses Op8108 ----------
Op8108:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [810f] sbcd -(a7), -(a0) uses Op810f ----------
Op810f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8110] or.b d0, (a0) uses Op8110 ----------
Op8110:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8118] or.b d0, (a0)+ uses Op8118 ----------
Op8118:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [811f] or.b d0, (a7)+ uses Op811f ----------
Op811f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8120] or.b d0, -(a0) uses Op8120 ----------
Op8120:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8127] or.b d0, -(a7) uses Op8127 ----------
Op8127:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8128] or.b d0, ($3333,a0) uses Op8128 ----------
Op8128:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8130] or.b d0, ($33,a0,d3.w*2) uses Op8130 ----------
Op8130:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8138] or.b d0, $3333.w uses Op8138 ----------
Op8138:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8139] or.b d0, $33333333.l uses Op8139 ----------
Op8139:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8150] or.w d0, (a0) uses Op8150 ----------
Op8150:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8158] or.w d0, (a0)+ uses Op8158 ----------
Op8158:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [815f] or.w d0, (a7)+ uses Op815f ----------
Op815f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8160] or.w d0, -(a0) uses Op8160 ----------
Op8160:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8167] or.w d0, -(a7) uses Op8167 ----------
Op8167:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8168] or.w d0, ($3333,a0) uses Op8168 ----------
Op8168:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8170] or.w d0, ($33,a0,d3.w*2) uses Op8170 ----------
Op8170:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8178] or.w d0, $3333.w uses Op8178 ----------
Op8178:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8179] or.w d0, $33333333.l uses Op8179 ----------
Op8179:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8190] or.l d0, (a0) uses Op8190 ----------
Op8190:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8198] or.l d0, (a0)+ uses Op8198 ----------
Op8198:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [819f] or.l d0, (a7)+ uses Op819f ----------
Op819f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81a0] or.l d0, -(a0) uses Op81a0 ----------
Op81a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81a7] or.l d0, -(a7) uses Op81a7 ----------
Op81a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81a8] or.l d0, ($3333,a0) uses Op81a8 ----------
Op81a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81b0] or.l d0, ($33,a0,d3.w*2) uses Op81b0 ----------
Op81b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81b8] or.l d0, $3333.w uses Op81b8 ----------
Op81b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81b9] or.l d0, $33333333.l uses Op81b9 ----------
Op81b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81c0] divs.w d0, d0 uses Op81c0 ----------
Op81c0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r10:
  ldrsh r10,[r7,r10]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero81c0 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  orrmi r11,r11,#1
  rsbmi r10,r10,#0 ;@ Make r10 positive

  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift81c0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81c0

Divide81c0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide81c0

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81c0 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop81c0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#158 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81c0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#196 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81d0] divs.w (a0), d0 uses Op81d0 ----------
Op81d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero81d0 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  orrmi r11,r11,#1
  rsbmi r10,r10,#0 ;@ Make r10 positive

  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift81d0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81d0

Divide81d0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide81d0

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81d0 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop81d0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#162 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81d0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#200 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81d8] divs.w (a0)+, d0 uses Op81d8 ----------
Op81d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero81d8 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  orrmi r11,r11,#1
  rsbmi r10,r10,#0 ;@ Make r10 positive

  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift81d8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81d8

Divide81d8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide81d8

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81d8 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop81d8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#162 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81d8:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#200 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81df] divs.w (a7)+, d0 uses Op81df ----------
Op81df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero81df ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  orrmi r11,r11,#1
  rsbmi r10,r10,#0 ;@ Make r10 positive

  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift81df:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81df

Divide81df:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide81df

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81df ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop81df:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#162 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81df:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#200 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81e0] divs.w -(a0), d0 uses Op81e0 ----------
Op81e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero81e0 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  orrmi r11,r11,#1
  rsbmi r10,r10,#0 ;@ Make r10 positive

  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift81e0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81e0

Divide81e0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide81e0

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81e0 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop81e0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#164 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81e0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#202 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81e7] divs.w -(a7), d0 uses Op81e7 ----------
Op81e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero81e7 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  orrmi r11,r11,#1
  rsbmi r10,r10,#0 ;@ Make r10 positive

  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift81e7:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81e7

Divide81e7:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide81e7

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81e7 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop81e7:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#164 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81e7:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#202 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81e8] divs.w ($3333,a0), d0 uses Op81e8 ----------
Op81e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero81e8 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  orrmi r11,r11,#1
  rsbmi r10,r10,#0 ;@ Make r10 positive

  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift81e8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81e8

Divide81e8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide81e8

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81e8 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop81e8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#166 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81e8:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#204 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81f0] divs.w ($33,a0,d3.w*2), d0 uses Op81f0 ----------
Op81f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero81f0 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  orrmi r11,r11,#1
  rsbmi r10,r10,#0 ;@ Make r10 positive

  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift81f0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81f0

Divide81f0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide81f0

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81f0 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop81f0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#168 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81f0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#206 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81f8] divs.w $3333.w, d0 uses Op81f8 ----------
Op81f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero81f8 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  orrmi r11,r11,#1
  rsbmi r10,r10,#0 ;@ Make r10 positive

  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift81f8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81f8

Divide81f8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide81f8

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81f8 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop81f8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#166 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81f8:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#204 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81f9] divs.w $33333333.l, d0 uses Op81f9 ----------
Op81f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero81f9 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  orrmi r11,r11,#1
  rsbmi r10,r10,#0 ;@ Make r10 positive

  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift81f9:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81f9

Divide81f9:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide81f9

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81f9 ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop81f9:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#170 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81f9:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#208 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81fa] divs.w ($3333,pc), d0; =3335 uses Op81fa ----------
Op81fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero81fa ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  orrmi r11,r11,#1
  rsbmi r10,r10,#0 ;@ Make r10 positive

  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift81fa:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81fa

Divide81fa:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide81fa

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81fa ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop81fa:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#166 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81fa:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#204 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81fb] divs.w ($33,pc,d3.w*2), d0; =35 uses Op81fb ----------
Op81fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero81fb ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  orrmi r11,r11,#1
  rsbmi r10,r10,#0 ;@ Make r10 positive

  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift81fb:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81fb

Divide81fb:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide81fb

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81fb ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop81fb:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#168 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81fb:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#206 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81fc] divs.w #$3333, d0 uses Op81fc ----------
Op81fc:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

  tst r10,r10
  beq divzero81fc ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  orrmi r11,r11,#1
  rsbmi r10,r10,#0 ;@ Make r10 positive

  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10

;@ Shift up divisor till it's just less than numerator
Shift81fc:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81fc

Divide81fc:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r10
  movne r1,r1,lsr #1
  bne Divide81fc

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81fc ;@ overflow!
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofop81fc:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#162 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81fc:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#200 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [830f] sbcd -(a7), -(a1) uses Op830f ----------
Op830f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a1)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a1)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a1)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [850f] sbcd -(a7), -(a2) uses Op850f ----------
Op850f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a2)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a2)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a2)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [870f] sbcd -(a7), -(a3) uses Op870f ----------
Op870f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a3)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a3)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a3)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [890f] sbcd -(a7), -(a4) uses Op890f ----------
Op890f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a4)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a4)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a4)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8b0f] sbcd -(a7), -(a5) uses Op8b0f ----------
Op8b0f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a5)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a5)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a5)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8d0f] sbcd -(a7), -(a6) uses Op8d0f ----------
Op8d0f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a6)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a6)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a6)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8f08] sbcd -(a0), -(a7) uses Op8f08 ----------
Op8f08:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8f09] sbcd -(a1), -(a7) uses Op8f09 ----------
Op8f09:
;@ EaCalc : Get '-(a1)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a1)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8f0a] sbcd -(a2), -(a7) uses Op8f0a ----------
Op8f0a:
;@ EaCalc : Get '-(a2)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8f0b] sbcd -(a3), -(a7) uses Op8f0b ----------
Op8f0b:
;@ EaCalc : Get '-(a3)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a3)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8f0c] sbcd -(a4), -(a7) uses Op8f0c ----------
Op8f0c:
;@ EaCalc : Get '-(a4)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a4)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8f0d] sbcd -(a5), -(a7) uses Op8f0d ----------
Op8f0d:
;@ EaCalc : Get '-(a5)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a5)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8f0e] sbcd -(a6), -(a7) uses Op8f0e ----------
Op8f0e:
;@ EaCalc : Get '-(a6)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a6)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8f0f] sbcd -(a7), -(a7) uses Op8f0f ----------
Op8f0f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r1,lsr #4
  and r2,r3,r10,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9000] sub.b d0, d0 uses Op9000 ----------
Op9000:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r11:
  ldrb r11,[r7,r10,lsl #2]
  mov r11,r11,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9010] sub.b (a0), d0 uses Op9010 ----------
Op9010:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9018] sub.b (a0)+, d0 uses Op9018 ----------
Op9018:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [901f] sub.b (a7)+, d0 uses Op901f ----------
Op901f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9020] sub.b -(a0), d0 uses Op9020 ----------
Op9020:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9027] sub.b -(a7), d0 uses Op9027 ----------
Op9027:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9028] sub.b ($3333,a0), d0 uses Op9028 ----------
Op9028:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9030] sub.b ($33,a0,d3.w*2), d0 uses Op9030 ----------
Op9030:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9038] sub.b $3333.w, d0 uses Op9038 ----------
Op9038:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9039] sub.b $33333333.l, d0 uses Op9039 ----------
Op9039:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903a] sub.b ($3333,pc), d0; =3335 uses Op903a ----------
Op903a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903b] sub.b ($33,pc,d3.w*2), d0; =35 uses Op903b ----------
Op903b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903c] sub.b #$33, d0 uses Op903c ----------
Op903c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r11:
  mov r11,r10,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9040] sub.w d0, d0 uses Op9040 ----------
Op9040:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r11:
  ldrsh r11,[r7,r10]
  mov r11,r11,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9050] sub.w (a0), d0 uses Op9050 ----------
Op9050:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9058] sub.w (a0)+, d0 uses Op9058 ----------
Op9058:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [905f] sub.w (a7)+, d0 uses Op905f ----------
Op905f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9060] sub.w -(a0), d0 uses Op9060 ----------
Op9060:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9067] sub.w -(a7), d0 uses Op9067 ----------
Op9067:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9068] sub.w ($3333,a0), d0 uses Op9068 ----------
Op9068:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9070] sub.w ($33,a0,d3.w*2), d0 uses Op9070 ----------
Op9070:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9078] sub.w $3333.w, d0 uses Op9078 ----------
Op9078:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9079] sub.w $33333333.l, d0 uses Op9079 ----------
Op9079:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907a] sub.w ($3333,pc), d0; =3335 uses Op907a ----------
Op907a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907b] sub.w ($33,pc,d3.w*2), d0; =35 uses Op907b ----------
Op907b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907c] sub.w #$3333, d0 uses Op907c ----------
Op907c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r11:
  mov r11,r10,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9080] sub.l d0, d0 uses Op9080 ----------
Op9080:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsl #2]

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9090] sub.l (a0), d0 uses Op9090 ----------
Op9090:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9098] sub.l (a0)+, d0 uses Op9098 ----------
Op9098:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [909f] sub.l (a7)+, d0 uses Op909f ----------
Op909f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90a0] sub.l -(a0), d0 uses Op90a0 ----------
Op90a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90a7] sub.l -(a7), d0 uses Op90a7 ----------
Op90a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90a8] sub.l ($3333,a0), d0 uses Op90a8 ----------
Op90a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90b0] sub.l ($33,a0,d3.w*2), d0 uses Op90b0 ----------
Op90b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90b8] sub.l $3333.w, d0 uses Op90b8 ----------
Op90b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90b9] sub.l $33333333.l, d0 uses Op90b9 ----------
Op90b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90ba] sub.l ($3333,pc), d0; =3335 uses Op90ba ----------
Op90ba:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90bb] sub.l ($33,pc,d3.w*2), d0; =35 uses Op90bb ----------
Op90bb:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90bc] sub.l #$33333333, d0 uses Op90bc ----------
Op90bc:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r11:
  mov r11,r10,asl #0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90c0] suba.w d0, a0 uses Op90c0 ----------
Op90c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r10:
  ldrsh r10,[r7,r0]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90d0] suba.w (a0), a0 uses Op90d0 ----------
Op90d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90d8] suba.w (a0)+, a0 uses Op90d8 ----------
Op90d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90df] suba.w (a7)+, a0 uses Op90df ----------
Op90df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90e0] suba.w -(a0), a0 uses Op90e0 ----------
Op90e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90e7] suba.w -(a7), a0 uses Op90e7 ----------
Op90e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90e8] suba.w ($3333,a0), a0 uses Op90e8 ----------
Op90e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90f0] suba.w ($33,a0,d3.w*2), a0 uses Op90f0 ----------
Op90f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90f8] suba.w $3333.w, a0 uses Op90f8 ----------
Op90f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90f9] suba.w $33333333.l, a0 uses Op90f9 ----------
Op90f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90fa] suba.w ($3333,pc), a0; =3335 uses Op90fa ----------
Op90fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90fb] suba.w ($33,pc,d3.w*2), a0; =35 uses Op90fb ----------
Op90fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90fc] suba.w #$3333, a0 uses Op90fc ----------
Op90fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r10:
  mov r10,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9100] subx.b d0, d0 uses Op9100 ----------
Op9100:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
;@ EaRead : Read register[r0] into r11:
  ldrb r11,[r7,r0,lsl #2]
  mov r11,r11,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9108] subx.b a0, d0 uses Op9108 ----------
Op9108:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [910f] subx.b a7, d0 uses Op910f ----------
Op910f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9110] sub.b d0, (a0) uses Op9110 ----------
Op9110:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9118] sub.b d0, (a0)+ uses Op9118 ----------
Op9118:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [911f] sub.b d0, (a7)+ uses Op911f ----------
Op911f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9120] sub.b d0, -(a0) uses Op9120 ----------
Op9120:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9127] sub.b d0, -(a7) uses Op9127 ----------
Op9127:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9128] sub.b d0, ($3333,a0) uses Op9128 ----------
Op9128:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9130] sub.b d0, ($33,a0,d3.w*2) uses Op9130 ----------
Op9130:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9138] sub.b d0, $3333.w uses Op9138 ----------
Op9138:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9139] sub.b d0, $33333333.l uses Op9139 ----------
Op9139:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9140] subx.w d0, d0 uses Op9140 ----------
Op9140:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r11:
  ldrsh r11,[r7,r0]
  mov r11,r11,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9148] subx.w a0, d0 uses Op9148 ----------
Op9148:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9150] sub.w d0, (a0) uses Op9150 ----------
Op9150:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9158] sub.w d0, (a0)+ uses Op9158 ----------
Op9158:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [915f] sub.w d0, (a7)+ uses Op915f ----------
Op915f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9160] sub.w d0, -(a0) uses Op9160 ----------
Op9160:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9167] sub.w d0, -(a7) uses Op9167 ----------
Op9167:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9168] sub.w d0, ($3333,a0) uses Op9168 ----------
Op9168:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9170] sub.w d0, ($33,a0,d3.w*2) uses Op9170 ----------
Op9170:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9178] sub.w d0, $3333.w uses Op9178 ----------
Op9178:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9179] sub.w d0, $33333333.l uses Op9179 ----------
Op9179:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9180] subx.l d0, d0 uses Op9180 ----------
Op9180:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
;@ EaRead : Read register[r0] into r11:
  ldr r11,[r7,r0,lsl #2]

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9188] subx.l a0, d0 uses Op9188 ----------
Op9188:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9190] sub.l d0, (a0) uses Op9190 ----------
Op9190:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9198] sub.l d0, (a0)+ uses Op9198 ----------
Op9198:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [919f] sub.l d0, (a7)+ uses Op919f ----------
Op919f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91a0] sub.l d0, -(a0) uses Op91a0 ----------
Op91a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91a7] sub.l d0, -(a7) uses Op91a7 ----------
Op91a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91a8] sub.l d0, ($3333,a0) uses Op91a8 ----------
Op91a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91b0] sub.l d0, ($33,a0,d3.w*2) uses Op91b0 ----------
Op91b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91b8] sub.l d0, $3333.w uses Op91b8 ----------
Op91b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91b9] sub.l d0, $33333333.l uses Op91b9 ----------
Op91b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91c0] suba.l d0, a0 uses Op91c0 ----------
Op91c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r10:
  ldr r10,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91d0] suba.l (a0), a0 uses Op91d0 ----------
Op91d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91d8] suba.l (a0)+, a0 uses Op91d8 ----------
Op91d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91df] suba.l (a7)+, a0 uses Op91df ----------
Op91df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91e0] suba.l -(a0), a0 uses Op91e0 ----------
Op91e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91e7] suba.l -(a7), a0 uses Op91e7 ----------
Op91e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91e8] suba.l ($3333,a0), a0 uses Op91e8 ----------
Op91e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91f0] suba.l ($33,a0,d3.w*2), a0 uses Op91f0 ----------
Op91f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91f8] suba.l $3333.w, a0 uses Op91f8 ----------
Op91f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91f9] suba.l $33333333.l, a0 uses Op91f9 ----------
Op91f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91fa] suba.l ($3333,pc), a0; =3335 uses Op91fa ----------
Op91fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91fb] suba.l ($33,pc,d3.w*2), a0; =35 uses Op91fb ----------
Op91fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91fc] suba.l #$33333333, a0 uses Op91fc ----------
Op91fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r10:
  mov r10,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [930f] subx.b a7, d1 uses Op930f ----------
Op930f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a1)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a1)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a1)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [950f] subx.b a7, d2 uses Op950f ----------
Op950f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a2)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a2)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [970f] subx.b a7, d3 uses Op970f ----------
Op970f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a3)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a3)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a3)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [990f] subx.b a7, d4 uses Op990f ----------
Op990f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a4)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a4)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a4)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9b0f] subx.b a7, d5 uses Op9b0f ----------
Op9b0f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a5)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a5)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a5)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9d0f] subx.b a7, d6 uses Op9d0f ----------
Op9d0f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a6)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a6)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a6)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9f08] subx.b a0, d7 uses Op9f08 ----------
Op9f08:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9f09] subx.b a1, d7 uses Op9f09 ----------
Op9f09:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a1)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a1)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9f0a] subx.b a2, d7 uses Op9f0a ----------
Op9f0a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a2)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a2)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9f0b] subx.b a3, d7 uses Op9f0b ----------
Op9f0b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a3)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a3)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9f0c] subx.b a4, d7 uses Op9f0c ----------
Op9f0c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a4)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a4)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9f0d] subx.b a5, d7 uses Op9f0d ----------
Op9f0d:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a5)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a5)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9f0e] subx.b a6, d7 uses Op9f0e ----------
Op9f0e:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a6)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a6)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9f0f] subx.b a7, d7 uses Op9f0f ----------
Op9f0f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b000] cmp.b d0, d0 uses Opb000 ----------
Opb000:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b010] cmp.b (a0), d0 uses Opb010 ----------
Opb010:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b018] cmp.b (a0)+, d0 uses Opb018 ----------
Opb018:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b01f] cmp.b (a7)+, d0 uses Opb01f ----------
Opb01f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b020] cmp.b -(a0), d0 uses Opb020 ----------
Opb020:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b027] cmp.b -(a7), d0 uses Opb027 ----------
Opb027:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b028] cmp.b ($3333,a0), d0 uses Opb028 ----------
Opb028:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b030] cmp.b ($33,a0,d3.w*2), d0 uses Opb030 ----------
Opb030:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b038] cmp.b $3333.w, d0 uses Opb038 ----------
Opb038:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b039] cmp.b $33333333.l, d0 uses Opb039 ----------
Opb039:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b03a] cmp.b ($3333,pc), d0; =3335 uses Opb03a ----------
Opb03a:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b03b] cmp.b ($33,pc,d3.w*2), d0; =35 uses Opb03b ----------
Opb03b:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b03c] cmp.b #$33, d0 uses Opb03c ----------
Opb03c:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r0:
  mov r0,r10,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b040] cmp.w d0, d0 uses Opb040 ----------
Opb040:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b050] cmp.w (a0), d0 uses Opb050 ----------
Opb050:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b058] cmp.w (a0)+, d0 uses Opb058 ----------
Opb058:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b05f] cmp.w (a7)+, d0 uses Opb05f ----------
Opb05f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b060] cmp.w -(a0), d0 uses Opb060 ----------
Opb060:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b067] cmp.w -(a7), d0 uses Opb067 ----------
Opb067:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b068] cmp.w ($3333,a0), d0 uses Opb068 ----------
Opb068:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b070] cmp.w ($33,a0,d3.w*2), d0 uses Opb070 ----------
Opb070:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b078] cmp.w $3333.w, d0 uses Opb078 ----------
Opb078:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b079] cmp.w $33333333.l, d0 uses Opb079 ----------
Opb079:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b07a] cmp.w ($3333,pc), d0; =3335 uses Opb07a ----------
Opb07a:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b07b] cmp.w ($33,pc,d3.w*2), d0; =35 uses Opb07b ----------
Opb07b:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b07c] cmp.w #$3333, d0 uses Opb07c ----------
Opb07c:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r0:
  mov r0,r10,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b080] cmp.l d0, d0 uses Opb080 ----------
Opb080:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b090] cmp.l (a0), d0 uses Opb090 ----------
Opb090:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b098] cmp.l (a0)+, d0 uses Opb098 ----------
Opb098:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b09f] cmp.l (a7)+, d0 uses Opb09f ----------
Opb09f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0a0] cmp.l -(a0), d0 uses Opb0a0 ----------
Opb0a0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0a7] cmp.l -(a7), d0 uses Opb0a7 ----------
Opb0a7:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0a8] cmp.l ($3333,a0), d0 uses Opb0a8 ----------
Opb0a8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0b0] cmp.l ($33,a0,d3.w*2), d0 uses Opb0b0 ----------
Opb0b0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0b8] cmp.l $3333.w, d0 uses Opb0b8 ----------
Opb0b8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0b9] cmp.l $33333333.l, d0 uses Opb0b9 ----------
Opb0b9:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0ba] cmp.l ($3333,pc), d0; =3335 uses Opb0ba ----------
Opb0ba:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0bb] cmp.l ($33,pc,d3.w*2), d0; =35 uses Opb0bb ----------
Opb0bb:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0bc] cmp.l #$33333333, d0 uses Opb0bc ----------
Opb0bc:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r0:
  mov r0,r10,asl #0

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0c0] cmpa.w d0, a0 uses Opb0c0 ----------
Opb0c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r10:
  ldrsh r10,[r7,r0]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0d0] cmpa.w (a0), a0 uses Opb0d0 ----------
Opb0d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0d8] cmpa.w (a0)+, a0 uses Opb0d8 ----------
Opb0d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0df] cmpa.w (a7)+, a0 uses Opb0df ----------
Opb0df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0e0] cmpa.w -(a0), a0 uses Opb0e0 ----------
Opb0e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0e7] cmpa.w -(a7), a0 uses Opb0e7 ----------
Opb0e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0e8] cmpa.w ($3333,a0), a0 uses Opb0e8 ----------
Opb0e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0f0] cmpa.w ($33,a0,d3.w*2), a0 uses Opb0f0 ----------
Opb0f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0f8] cmpa.w $3333.w, a0 uses Opb0f8 ----------
Opb0f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0f9] cmpa.w $33333333.l, a0 uses Opb0f9 ----------
Opb0f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0fa] cmpa.w ($3333,pc), a0; =3335 uses Opb0fa ----------
Opb0fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0fb] cmpa.w ($33,pc,d3.w*2), a0; =35 uses Opb0fb ----------
Opb0fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0fc] cmpa.w #$3333, a0 uses Opb0fc ----------
Opb0fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r10:
  mov r10,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b100] eor.b d0, d0 uses Opb100 ----------
Opb100:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b108] eor.b d0, a0 uses Opb108 ----------
Opb108:
;@ Get src operand into r10:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b10f] eor.b d0, a7 uses Opb10f ----------
Opb10f:
;@ Get src operand into r10:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b110] eor.b d0, (a0) uses Opb110 ----------
Opb110:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b118] eor.b d0, (a0)+ uses Opb118 ----------
Opb118:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b11f] eor.b d0, (a7)+ uses Opb11f ----------
Opb11f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b120] eor.b d0, -(a0) uses Opb120 ----------
Opb120:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b127] eor.b d0, -(a7) uses Opb127 ----------
Opb127:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b128] eor.b d0, ($3333,a0) uses Opb128 ----------
Opb128:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b130] eor.b d0, ($33,a0,d3.w*2) uses Opb130 ----------
Opb130:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b138] eor.b d0, $3333.w uses Opb138 ----------
Opb138:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b139] eor.b d0, $33333333.l uses Opb139 ----------
Opb139:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b140] eor.w d0, d0 uses Opb140 ----------
Opb140:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b148] eor.w d0, a0 uses Opb148 ----------
Opb148:
;@ Get src operand into r10:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b150] eor.w d0, (a0) uses Opb150 ----------
Opb150:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b158] eor.w d0, (a0)+ uses Opb158 ----------
Opb158:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b15f] eor.w d0, (a7)+ uses Opb15f ----------
Opb15f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b160] eor.w d0, -(a0) uses Opb160 ----------
Opb160:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b167] eor.w d0, -(a7) uses Opb167 ----------
Opb167:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b168] eor.w d0, ($3333,a0) uses Opb168 ----------
Opb168:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b170] eor.w d0, ($33,a0,d3.w*2) uses Opb170 ----------
Opb170:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b178] eor.w d0, $3333.w uses Opb178 ----------
Opb178:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b179] eor.w d0, $33333333.l uses Opb179 ----------
Opb179:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b180] eor.l d0, d0 uses Opb180 ----------
Opb180:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b188] eor.l d0, a0 uses Opb188 ----------
Opb188:
;@ Get src operand into r10:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b190] eor.l d0, (a0) uses Opb190 ----------
Opb190:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b198] eor.l d0, (a0)+ uses Opb198 ----------
Opb198:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b19f] eor.l d0, (a7)+ uses Opb19f ----------
Opb19f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1a0] eor.l d0, -(a0) uses Opb1a0 ----------
Opb1a0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1a7] eor.l d0, -(a7) uses Opb1a7 ----------
Opb1a7:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1a8] eor.l d0, ($3333,a0) uses Opb1a8 ----------
Opb1a8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1b0] eor.l d0, ($33,a0,d3.w*2) uses Opb1b0 ----------
Opb1b0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1b8] eor.l d0, $3333.w uses Opb1b8 ----------
Opb1b8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1b9] eor.l d0, $33333333.l uses Opb1b9 ----------
Opb1b9:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1c0] cmpa.l d0, a0 uses Opb1c0 ----------
Opb1c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r10:
  ldr r10,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1d0] cmpa.l (a0), a0 uses Opb1d0 ----------
Opb1d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1d8] cmpa.l (a0)+, a0 uses Opb1d8 ----------
Opb1d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1df] cmpa.l (a7)+, a0 uses Opb1df ----------
Opb1df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1e0] cmpa.l -(a0), a0 uses Opb1e0 ----------
Opb1e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1e7] cmpa.l -(a7), a0 uses Opb1e7 ----------
Opb1e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1e8] cmpa.l ($3333,a0), a0 uses Opb1e8 ----------
Opb1e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1f0] cmpa.l ($33,a0,d3.w*2), a0 uses Opb1f0 ----------
Opb1f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1f8] cmpa.l $3333.w, a0 uses Opb1f8 ----------
Opb1f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1f9] cmpa.l $33333333.l, a0 uses Opb1f9 ----------
Opb1f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1fa] cmpa.l ($3333,pc), a0; =3335 uses Opb1fa ----------
Opb1fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1fb] cmpa.l ($33,pc,d3.w*2), a0; =35 uses Opb1fb ----------
Opb1fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1fc] cmpa.l #$33333333, a0 uses Opb1fc ----------
Opb1fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r10:
  mov r10,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b30f] eor.b d1, a7 uses Opb30f ----------
Opb30f:
;@ Get src operand into r10:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a1)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a1)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b50f] eor.b d2, a7 uses Opb50f ----------
Opb50f:
;@ Get src operand into r10:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a2)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a2)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b70f] eor.b d3, a7 uses Opb70f ----------
Opb70f:
;@ Get src operand into r10:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a3)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a3)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b90f] eor.b d4, a7 uses Opb90f ----------
Opb90f:
;@ Get src operand into r10:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a4)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a4)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bb0f] eor.b d5, a7 uses Opbb0f ----------
Opbb0f:
;@ Get src operand into r10:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a5)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a5)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bd0f] eor.b d6, a7 uses Opbd0f ----------
Opbd0f:
;@ Get src operand into r10:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a6)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a6)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bf08] eor.b d7, a0 uses Opbf08 ----------
Opbf08:
;@ Get src operand into r10:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bf09] eor.b d7, a1 uses Opbf09 ----------
Opbf09:
;@ Get src operand into r10:
;@ EaCalc : Get '(a1)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a1)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bf0a] eor.b d7, a2 uses Opbf0a ----------
Opbf0a:
;@ Get src operand into r10:
;@ EaCalc : Get '(a2)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a2)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bf0b] eor.b d7, a3 uses Opbf0b ----------
Opbf0b:
;@ Get src operand into r10:
;@ EaCalc : Get '(a3)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a3)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bf0c] eor.b d7, a4 uses Opbf0c ----------
Opbf0c:
;@ Get src operand into r10:
;@ EaCalc : Get '(a4)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a4)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bf0d] eor.b d7, a5 uses Opbf0d ----------
Opbf0d:
;@ Get src operand into r10:
;@ EaCalc : Get '(a5)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a5)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bf0e] eor.b d7, a6 uses Opbf0e ----------
Opbf0e:
;@ Get src operand into r10:
;@ EaCalc : Get '(a6)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a6)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bf0f] eor.b d7, a7 uses Opbf0f ----------
Opbf0f:
;@ Get src operand into r10:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c000] and.b d0, d0 uses Opc000 ----------
Opc000:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r11:
  ldrb r11,[r7,r10,lsl #2]
  mov r11,r11,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c010] and.b (a0), d0 uses Opc010 ----------
Opc010:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c018] and.b (a0)+, d0 uses Opc018 ----------
Opc018:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c01f] and.b (a7)+, d0 uses Opc01f ----------
Opc01f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c020] and.b -(a0), d0 uses Opc020 ----------
Opc020:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c027] and.b -(a7), d0 uses Opc027 ----------
Opc027:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c028] and.b ($3333,a0), d0 uses Opc028 ----------
Opc028:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c030] and.b ($33,a0,d3.w*2), d0 uses Opc030 ----------
Opc030:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c038] and.b $3333.w, d0 uses Opc038 ----------
Opc038:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c039] and.b $33333333.l, d0 uses Opc039 ----------
Opc039:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03a] and.b ($3333,pc), d0; =3335 uses Opc03a ----------
Opc03a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03b] and.b ($33,pc,d3.w*2), d0; =35 uses Opc03b ----------
Opc03b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03c] and.b #$33, d0 uses Opc03c ----------
Opc03c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r11:
  mov r11,r10,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c040] and.w d0, d0 uses Opc040 ----------
Opc040:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r11:
  ldrsh r11,[r7,r10]
  mov r11,r11,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c050] and.w (a0), d0 uses Opc050 ----------
Opc050:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c058] and.w (a0)+, d0 uses Opc058 ----------
Opc058:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c05f] and.w (a7)+, d0 uses Opc05f ----------
Opc05f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c060] and.w -(a0), d0 uses Opc060 ----------
Opc060:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c067] and.w -(a7), d0 uses Opc067 ----------
Opc067:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c068] and.w ($3333,a0), d0 uses Opc068 ----------
Opc068:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c070] and.w ($33,a0,d3.w*2), d0 uses Opc070 ----------
Opc070:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c078] and.w $3333.w, d0 uses Opc078 ----------
Opc078:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c079] and.w $33333333.l, d0 uses Opc079 ----------
Opc079:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07a] and.w ($3333,pc), d0; =3335 uses Opc07a ----------
Opc07a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07b] and.w ($33,pc,d3.w*2), d0; =35 uses Opc07b ----------
Opc07b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07c] and.w #$3333, d0 uses Opc07c ----------
Opc07c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r11:
  mov r11,r10,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c080] and.l d0, d0 uses Opc080 ----------
Opc080:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsl #2]

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c090] and.l (a0), d0 uses Opc090 ----------
Opc090:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c098] and.l (a0)+, d0 uses Opc098 ----------
Opc098:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c09f] and.l (a7)+, d0 uses Opc09f ----------
Opc09f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0a0] and.l -(a0), d0 uses Opc0a0 ----------
Opc0a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0a7] and.l -(a7), d0 uses Opc0a7 ----------
Opc0a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0a8] and.l ($3333,a0), d0 uses Opc0a8 ----------
Opc0a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0b0] and.l ($33,a0,d3.w*2), d0 uses Opc0b0 ----------
Opc0b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0b8] and.l $3333.w, d0 uses Opc0b8 ----------
Opc0b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0b9] and.l $33333333.l, d0 uses Opc0b9 ----------
Opc0b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0ba] and.l ($3333,pc), d0; =3335 uses Opc0ba ----------
Opc0ba:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0bb] and.l ($33,pc,d3.w*2), d0; =35 uses Opc0bb ----------
Opc0bb:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0bc] and.l #$33333333, d0 uses Opc0bc ----------
Opc0bc:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r11:
  mov r11,r10,asl #0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0c0] mulu.w d0, d0 uses Opc0c0 ----------
Opc0c0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r10:
  ldrsh r10,[r7,r10]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc0c0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc0c0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#92 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c0d0] mulu.w (a0), d0 uses Opc0d0 ----------
Opc0d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc0d0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc0d0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#96 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c0d8] mulu.w (a0)+, d0 uses Opc0d8 ----------
Opc0d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc0d8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc0d8:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#96 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c0df] mulu.w (a7)+, d0 uses Opc0df ----------
Opc0df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc0df:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc0df:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#96 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c0e0] mulu.w -(a0), d0 uses Opc0e0 ----------
Opc0e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc0e0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc0e0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#98 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c0e7] mulu.w -(a7), d0 uses Opc0e7 ----------
Opc0e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc0e7:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc0e7:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#98 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c0e8] mulu.w ($3333,a0), d0 uses Opc0e8 ----------
Opc0e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc0e8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc0e8:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#100 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c0f0] mulu.w ($33,a0,d3.w*2), d0 uses Opc0f0 ----------
Opc0f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc0f0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#64 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc0f0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#102 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c0f8] mulu.w $3333.w, d0 uses Opc0f8 ----------
Opc0f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc0f8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc0f8:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#100 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c0f9] mulu.w $33333333.l, d0 uses Opc0f9 ----------
Opc0f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc0f9:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#66 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc0f9:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#104 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c0fa] mulu.w ($3333,pc), d0; =3335 uses Opc0fa ----------
Opc0fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc0fa:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc0fa:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#100 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c0fb] mulu.w ($33,pc,d3.w*2), d0; =35 uses Opc0fb ----------
Opc0fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc0fb:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#64 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc0fb:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#102 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c0fc] mulu.w #$3333, d0 uses Opc0fc ----------
Opc0fc:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc0fc:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc0fc:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#96 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c100] abcd d0, d0 uses Opc100 ----------
Opc100:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
;@ EaRead : Read register[r0] into r10:
  ldrb r10,[r7,r0,lsl #2]
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldrb r1,[r7,r11,lsr #7]
  mov r1,r1,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: r0 into register[r11]:
  mov r0,r0,asr #24
  strb r0,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c108] abcd -(a0), -(a0) uses Opc108 ----------
Opc108:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c10f] abcd -(a7), -(a0) uses Opc10f ----------
Opc10f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c110] and.b d0, (a0) uses Opc110 ----------
Opc110:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c118] and.b d0, (a0)+ uses Opc118 ----------
Opc118:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c11f] and.b d0, (a7)+ uses Opc11f ----------
Opc11f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c120] and.b d0, -(a0) uses Opc120 ----------
Opc120:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c127] and.b d0, -(a7) uses Opc127 ----------
Opc127:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c128] and.b d0, ($3333,a0) uses Opc128 ----------
Opc128:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c130] and.b d0, ($33,a0,d3.w*2) uses Opc130 ----------
Opc130:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c138] and.b d0, $3333.w uses Opc138 ----------
Opc138:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c139] and.b d0, $33333333.l uses Opc139 ----------
Opc139:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c140] exg d0, d0 uses Opc140 ----------
Opc140:
  and r10,r8,#0x0e00 ;@ Find T register
  and r11,r8,#0x000f ;@ Find S register

  ldr r0,[r7,r10,lsr #7] ;@ Get T
  ldr r1,[r7,r11,lsl #2] ;@ Get S

  str r0,[r7,r11,lsl #2] ;@ T->S
  str r1,[r7,r10,lsr #7] ;@ S->T

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c148] exg a0, a0 uses Opc148 ----------
Opc148:
  and r10,r8,#0x0e00 ;@ Find T register
  and r11,r8,#0x000f ;@ Find S register
  orr r10,r10,#0x1000 ;@ T is an address register

  ldr r0,[r7,r10,lsr #7] ;@ Get T
  ldr r1,[r7,r11,lsl #2] ;@ Get S

  str r0,[r7,r11,lsl #2] ;@ T->S
  str r1,[r7,r10,lsr #7] ;@ S->T

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c150] and.w d0, (a0) uses Opc150 ----------
Opc150:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c158] and.w d0, (a0)+ uses Opc158 ----------
Opc158:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c15f] and.w d0, (a7)+ uses Opc15f ----------
Opc15f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c160] and.w d0, -(a0) uses Opc160 ----------
Opc160:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c167] and.w d0, -(a7) uses Opc167 ----------
Opc167:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c168] and.w d0, ($3333,a0) uses Opc168 ----------
Opc168:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c170] and.w d0, ($33,a0,d3.w*2) uses Opc170 ----------
Opc170:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c178] and.w d0, $3333.w uses Opc178 ----------
Opc178:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c179] and.w d0, $33333333.l uses Opc179 ----------
Opc179:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c188] exg a0, d0 uses Opc188 ----------
Opc188:
  and r10,r8,#0x0e00 ;@ Find T register
  and r11,r8,#0x000f ;@ Find S register

  ldr r0,[r7,r10,lsr #7] ;@ Get T
  ldr r1,[r7,r11,lsl #2] ;@ Get S

  str r0,[r7,r11,lsl #2] ;@ T->S
  str r1,[r7,r10,lsr #7] ;@ S->T

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c190] and.l d0, (a0) uses Opc190 ----------
Opc190:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c198] and.l d0, (a0)+ uses Opc198 ----------
Opc198:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c19f] and.l d0, (a7)+ uses Opc19f ----------
Opc19f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1a0] and.l d0, -(a0) uses Opc1a0 ----------
Opc1a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1a7] and.l d0, -(a7) uses Opc1a7 ----------
Opc1a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1a8] and.l d0, ($3333,a0) uses Opc1a8 ----------
Opc1a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1b0] and.l d0, ($33,a0,d3.w*2) uses Opc1b0 ----------
Opc1b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1b8] and.l d0, $3333.w uses Opc1b8 ----------
Opc1b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1b9] and.l d0, $33333333.l uses Opc1b9 ----------
Opc1b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1c0] muls.w d0, d0 uses Opc1c0 ----------
Opc1c0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r10:
  ldrsh r10,[r7,r10]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc1c0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc1c0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#92 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c1d0] muls.w (a0), d0 uses Opc1d0 ----------
Opc1d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc1d0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc1d0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#96 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c1d8] muls.w (a0)+, d0 uses Opc1d8 ----------
Opc1d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc1d8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc1d8:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#96 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c1df] muls.w (a7)+, d0 uses Opc1df ----------
Opc1df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc1df:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc1df:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#96 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c1e0] muls.w -(a0), d0 uses Opc1e0 ----------
Opc1e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc1e0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc1e0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#98 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c1e7] muls.w -(a7), d0 uses Opc1e7 ----------
Opc1e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc1e7:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc1e7:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#98 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c1e8] muls.w ($3333,a0), d0 uses Opc1e8 ----------
Opc1e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc1e8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc1e8:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#100 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c1f0] muls.w ($33,a0,d3.w*2), d0 uses Opc1f0 ----------
Opc1f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc1f0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#64 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc1f0:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#102 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c1f8] muls.w $3333.w, d0 uses Opc1f8 ----------
Opc1f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc1f8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc1f8:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#100 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c1f9] muls.w $33333333.l, d0 uses Opc1f9 ----------
Opc1f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc1f9:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#66 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc1f9:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#104 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c1fa] muls.w ($3333,pc), d0; =3335 uses Opc1fa ----------
Opc1fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc1fa:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc1fa:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#100 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c1fb] muls.w ($33,pc,d3.w*2), d0; =35 uses Opc1fb ----------
Opc1fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc1fb:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#64 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc1fb:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#102 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c1fc] muls.w #$3333, d0 uses Opc1fc ----------
Opc1fc:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsr #7]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

endofopc1fc:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzeroc1fc:
  mov r0,#0x14 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#96 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [c30f] abcd -(a7), -(a1) uses Opc30f ----------
Opc30f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a1)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a1)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a1)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c50f] abcd -(a7), -(a2) uses Opc50f ----------
Opc50f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a2)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a2)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a2)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c70f] abcd -(a7), -(a3) uses Opc70f ----------
Opc70f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a3)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a3)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a3)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c90f] abcd -(a7), -(a4) uses Opc90f ----------
Opc90f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a4)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a4)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a4)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cb0f] abcd -(a7), -(a5) uses Opcb0f ----------
Opcb0f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a5)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a5)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a5)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cd0f] abcd -(a7), -(a6) uses Opcd0f ----------
Opcd0f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a6)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a6)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a6)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cf08] abcd -(a0), -(a7) uses Opcf08 ----------
Opcf08:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cf09] abcd -(a1), -(a7) uses Opcf09 ----------
Opcf09:
;@ EaCalc : Get '-(a1)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a1)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cf0a] abcd -(a2), -(a7) uses Opcf0a ----------
Opcf0a:
;@ EaCalc : Get '-(a2)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cf0b] abcd -(a3), -(a7) uses Opcf0b ----------
Opcf0b:
;@ EaCalc : Get '-(a3)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a3)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cf0c] abcd -(a4), -(a7) uses Opcf0c ----------
Opcf0c:
;@ EaCalc : Get '-(a4)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a4)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cf0d] abcd -(a5), -(a7) uses Opcf0d ----------
Opcf0d:
;@ EaCalc : Get '-(a5)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a5)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cf0e] abcd -(a6), -(a7) uses Opcf0e ----------
Opcf0e:
;@ EaCalc : Get '-(a6)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a6)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cf0f] abcd -(a7), -(a7) uses Opcf0f ----------
Opcf0f:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  mov r3,#0x00f00000
  ldrb r0,[r7,#0x45] ;@ Get X bit
  tst r0,#2
  and r0,r3,r10,lsr #4
  and r2,r3,r1,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d000] add.b d0, d0 uses Opd000 ----------
Opd000:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r11:
  ldrb r11,[r7,r10,lsl #2]
  mov r11,r11,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d010] add.b (a0), d0 uses Opd010 ----------
Opd010:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d018] add.b (a0)+, d0 uses Opd018 ----------
Opd018:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d01f] add.b (a7)+, d0 uses Opd01f ----------
Opd01f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d020] add.b -(a0), d0 uses Opd020 ----------
Opd020:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d027] add.b -(a7), d0 uses Opd027 ----------
Opd027:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d028] add.b ($3333,a0), d0 uses Opd028 ----------
Opd028:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d030] add.b ($33,a0,d3.w*2), d0 uses Opd030 ----------
Opd030:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d038] add.b $3333.w, d0 uses Opd038 ----------
Opd038:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d039] add.b $33333333.l, d0 uses Opd039 ----------
Opd039:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03a] add.b ($3333,pc), d0; =3335 uses Opd03a ----------
Opd03a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03b] add.b ($33,pc,d3.w*2), d0; =35 uses Opd03b ----------
Opd03b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03c] add.b #$33, d0 uses Opd03c ----------
Opd03c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r11:
  mov r11,r10,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d040] add.w d0, d0 uses Opd040 ----------
Opd040:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r11:
  ldrsh r11,[r7,r10]
  mov r11,r11,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d050] add.w (a0), d0 uses Opd050 ----------
Opd050:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d058] add.w (a0)+, d0 uses Opd058 ----------
Opd058:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d05f] add.w (a7)+, d0 uses Opd05f ----------
Opd05f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d060] add.w -(a0), d0 uses Opd060 ----------
Opd060:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d067] add.w -(a7), d0 uses Opd067 ----------
Opd067:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d068] add.w ($3333,a0), d0 uses Opd068 ----------
Opd068:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d070] add.w ($33,a0,d3.w*2), d0 uses Opd070 ----------
Opd070:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d078] add.w $3333.w, d0 uses Opd078 ----------
Opd078:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d079] add.w $33333333.l, d0 uses Opd079 ----------
Opd079:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07a] add.w ($3333,pc), d0; =3335 uses Opd07a ----------
Opd07a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07b] add.w ($33,pc,d3.w*2), d0; =35 uses Opd07b ----------
Opd07b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07c] add.w #$3333, d0 uses Opd07c ----------
Opd07c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r11:
  mov r11,r10,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d080] add.l d0, d0 uses Opd080 ----------
Opd080:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsl #2]

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d090] add.l (a0), d0 uses Opd090 ----------
Opd090:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d098] add.l (a0)+, d0 uses Opd098 ----------
Opd098:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d09f] add.l (a7)+, d0 uses Opd09f ----------
Opd09f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0a0] add.l -(a0), d0 uses Opd0a0 ----------
Opd0a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0a7] add.l -(a7), d0 uses Opd0a7 ----------
Opd0a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0a8] add.l ($3333,a0), d0 uses Opd0a8 ----------
Opd0a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0b0] add.l ($33,a0,d3.w*2), d0 uses Opd0b0 ----------
Opd0b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0b8] add.l $3333.w, d0 uses Opd0b8 ----------
Opd0b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0b9] add.l $33333333.l, d0 uses Opd0b9 ----------
Opd0b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0ba] add.l ($3333,pc), d0; =3335 uses Opd0ba ----------
Opd0ba:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r10,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0bb] add.l ($33,pc,d3.w*2), d0; =35 uses Opd0bb ----------
Opd0bb:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r10,r2,r0,asr #8 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0bc] add.l #$33333333, d0 uses Opd0bc ----------
Opd0bc:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r11:
  mov r11,r10,asl #0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0c0] adda.w d0, a0 uses Opd0c0 ----------
Opd0c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r10:
  ldrsh r10,[r7,r0]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0d0] adda.w (a0), a0 uses Opd0d0 ----------
Opd0d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0d8] adda.w (a0)+, a0 uses Opd0d8 ----------
Opd0d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0df] adda.w (a7)+, a0 uses Opd0df ----------
Opd0df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0e0] adda.w -(a0), a0 uses Opd0e0 ----------
Opd0e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0e7] adda.w -(a7), a0 uses Opd0e7 ----------
Opd0e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0e8] adda.w ($3333,a0), a0 uses Opd0e8 ----------
Opd0e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0f0] adda.w ($33,a0,d3.w*2), a0 uses Opd0f0 ----------
Opd0f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0f8] adda.w $3333.w, a0 uses Opd0f8 ----------
Opd0f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0f9] adda.w $33333333.l, a0 uses Opd0f9 ----------
Opd0f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0fa] adda.w ($3333,pc), a0; =3335 uses Opd0fa ----------
Opd0fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0fb] adda.w ($33,pc,d3.w*2), a0; =35 uses Opd0fb ----------
Opd0fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0fc] adda.w #$3333, a0 uses Opd0fc ----------
Opd0fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r10:
  mov r10,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d100] addx.b d0, d0 uses Opd100 ----------
Opd100:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
;@ EaRead : Read register[r0] into r11:
  ldrb r11,[r7,r0,lsl #2]
  mov r11,r11,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d108] addx.b a0, d0 uses Opd108 ----------
Opd108:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d10f] addx.b a7, d0 uses Opd10f ----------
Opd10f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d110] add.b d0, (a0) uses Opd110 ----------
Opd110:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d118] add.b d0, (a0)+ uses Opd118 ----------
Opd118:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d11f] add.b d0, (a7)+ uses Opd11f ----------
Opd11f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d120] add.b d0, -(a0) uses Opd120 ----------
Opd120:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d127] add.b d0, -(a7) uses Opd127 ----------
Opd127:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d128] add.b d0, ($3333,a0) uses Opd128 ----------
Opd128:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d130] add.b d0, ($33,a0,d3.w*2) uses Opd130 ----------
Opd130:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d138] add.b d0, $3333.w uses Opd138 ----------
Opd138:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d139] add.b d0, $33333333.l uses Opd139 ----------
Opd139:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldrb r1,[r7,r0,lsr #7]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d140] addx.w d0, d0 uses Opd140 ----------
Opd140:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r11:
  ldrsh r11,[r7,r0]
  mov r11,r11,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #16

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d148] addx.w a0, d0 uses Opd148 ----------
Opd148:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r1,r0,asl #16

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #16

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d150] add.w d0, (a0) uses Opd150 ----------
Opd150:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d158] add.w d0, (a0)+ uses Opd158 ----------
Opd158:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d15f] add.w d0, (a7)+ uses Opd15f ----------
Opd15f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d160] add.w d0, -(a0) uses Opd160 ----------
Opd160:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d167] add.w d0, -(a7) uses Opd167 ----------
Opd167:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d168] add.w d0, ($3333,a0) uses Opd168 ----------
Opd168:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d170] add.w d0, ($33,a0,d3.w*2) uses Opd170 ----------
Opd170:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d178] add.w d0, $3333.w uses Opd178 ----------
Opd178:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d179] add.w d0, $33333333.l uses Opd179 ----------
Opd179:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d180] addx.l d0, d0 uses Opd180 ----------
Opd180:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
;@ EaRead : Read register[r0] into r11:
  ldr r11,[r7,r0,lsl #2]

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d188] addx.l a0, d0 uses Opd188 ----------
Opd188:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r1,r0

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d190] add.l d0, (a0) uses Opd190 ----------
Opd190:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d198] add.l d0, (a0)+ uses Opd198 ----------
Opd198:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d19f] add.l d0, (a7)+ uses Opd19f ----------
Opd19f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1a0] add.l d0, -(a0) uses Opd1a0 ----------
Opd1a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1a7] add.l d0, -(a7) uses Opd1a7 ----------
Opd1a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1a8] add.l d0, ($3333,a0) uses Opd1a8 ----------
Opd1a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1b0] add.l d0, ($33,a0,d3.w*2) uses Opd1b0 ----------
Opd1b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1b8] add.l d0, $3333.w uses Opd1b8 ----------
Opd1b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1b9] add.l d0, $33333333.l uses Opd1b9 ----------
Opd1b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1c0] adda.l d0, a0 uses Opd1c0 ----------
Opd1c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r10:
  ldr r10,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1d0] adda.l (a0), a0 uses Opd1d0 ----------
Opd1d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1d8] adda.l (a0)+, a0 uses Opd1d8 ----------
Opd1d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1df] adda.l (a7)+, a0 uses Opd1df ----------
Opd1df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1e0] adda.l -(a0), a0 uses Opd1e0 ----------
Opd1e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1e7] adda.l -(a7), a0 uses Opd1e7 ----------
Opd1e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1e8] adda.l ($3333,a0), a0 uses Opd1e8 ----------
Opd1e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1f0] adda.l ($33,a0,d3.w*2), a0 uses Opd1f0 ----------
Opd1f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1f8] adda.l $3333.w, a0 uses Opd1f8 ----------
Opd1f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1f9] adda.l $33333333.l, a0 uses Opd1f9 ----------
Opd1f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1fa] adda.l ($3333,pc), a0; =3335 uses Opd1fa ----------
Opd1fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1fb] adda.l ($33,pc,d3.w*2), a0; =35 uses Opd1fb ----------
Opd1fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ r0=PC
;@ Get extension word into r3:
  ldrh r3,[r4],#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r3,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1fc] adda.l #$33333333, a0 uses Opd1fc ----------
Opd1fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r10:
  mov r10,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsr #7]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d30f] addx.b a7, d1 uses Opd30f ----------
Opd30f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a1)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a1)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a1)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d50f] addx.b a7, d2 uses Opd50f ----------
Opd50f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a2)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a2)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a2)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d70f] addx.b a7, d3 uses Opd70f ----------
Opd70f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a3)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a3)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a3)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d90f] addx.b a7, d4 uses Opd90f ----------
Opd90f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a4)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a4)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a4)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [db0f] addx.b a7, d5 uses Opdb0f ----------
Opdb0f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a5)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a5)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a5)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [dd0f] addx.b a7, d6 uses Opdd0f ----------
Opdd0f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a6)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a6)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a6)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [df08] addx.b a0, d7 uses Opdf08 ----------
Opdf08:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [df09] addx.b a1, d7 uses Opdf09 ----------
Opdf09:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a1)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a1)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [df0a] addx.b a2, d7 uses Opdf0a ----------
Opdf0a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a2)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a2)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [df0b] addx.b a3, d7 uses Opdf0b ----------
Opdf0b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a3)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a3)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [df0c] addx.b a4, d7 uses Opdf0c ----------
Opdf0c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a4)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a4)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [df0d] addx.b a5, d7 uses Opdf0d ----------
Opdf0d:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a5)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a5)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [df0e] addx.b a6, d7 uses Opdf0e ----------
Opdf0e:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a6)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a6)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [df0f] addx.b a7, d7 uses Opdf0f ----------
Opdf0f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0007
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r1,r11
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e000] asr.b #8, d0 uses Ope000 ----------
Ope000:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #24

;@ Shift register:
  movs r0,r0,asr #8
;@ restore after right shift:
  mov r0,r0,lsl #24

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e008] lsr.b #8, d0 uses Ope008 ----------
Ope008:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr #8
;@ restore after right shift:
  mov r0,r0,lsl #24

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e010] roxr.b #8, d0 uses Ope010 ----------
Ope010:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,#8
  mov r0,r0,lsr #24 ;@ Shift down
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e018] ror.b #8, d0 uses Ope018 ----------
Ope018:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #8
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e020] asr.b d0, d0 uses Ope020 ----------
Ope020:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #24

;@ Shift register:
  movs r0,r0,asr r2
;@ restore after right shift:
  mov r0,r0,lsl #24

  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  movne r1,r9,lsr #28
  strneb r1,[r7,#0x45] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e028] lsr.b d0, d0 uses Ope028 ----------
Ope028:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr r2
;@ restore after right shift:
  mov r0,r0,lsl #24

  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  movne r1,r9,lsr #28
  strneb r1,[r7,#0x45] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e030] roxr.b d0, d0 uses Ope030 ----------
Ope030:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e030:
  subs r2,r2,#9
  bpl Reduce_e030
  adds r2,r2,#9 ;@ Now r2=0-8
  beq norotxe030

  mov r0,r0,lsr #24 ;@ Shift down
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ if not 0, Save X bit
  b nozeroxe030
norotxe030:
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  ldrb r2,[r7,#0x45] ;@ C = old_X
  and r2,r2,#2
  orr r9,r9,r2,lsl #28
nozeroxe030:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e038] ror.b d0, d0 uses Ope038 ----------
Ope038:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear
  cmp r2,#0
  biceq r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e040] asr.w #8, d0 uses Ope040 ----------
Ope040:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #8
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e048] lsr.w #8, d0 uses Ope048 ----------
Ope048:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #8
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e050] roxr.w #8, d0 uses Ope050 ----------
Ope050:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,#8
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e058] ror.w #8, d0 uses Ope058 ----------
Ope058:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #8
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e060] asr.w d0, d0 uses Ope060 ----------
Ope060:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr r2
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  movne r1,r9,lsr #28
  strneb r1,[r7,#0x45] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e068] lsr.w d0, d0 uses Ope068 ----------
Ope068:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr r2
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  movne r1,r9,lsr #28
  strneb r1,[r7,#0x45] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e070] roxr.w d0, d0 uses Ope070 ----------
Ope070:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e070:
  subs r2,r2,#17
  bpl Reduce_e070
  adds r2,r2,#17 ;@ Now r2=0-16
  beq norotxe070

  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ if not 0, Save X bit
  b nozeroxe070
norotxe070:
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  ldrb r2,[r7,#0x45] ;@ C = old_X
  and r2,r2,#2
  orr r9,r9,r2,lsl #28
nozeroxe070:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e078] ror.w d0, d0 uses Ope078 ----------
Ope078:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear
  cmp r2,#0
  biceq r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e080] asr.l #8, d0 uses Ope080 ----------
Ope080:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Shift register:
  movs r0,r0,asr #8
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e088] lsr.l #8, d0 uses Ope088 ----------
Ope088:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Shift register:
  movs r0,r0,lsr #8
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e090] roxr.l #8, d0 uses Ope090 ----------
Ope090:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,#8
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r0,r0
  bicne r9,r9,#0x40000000 ;@ make sure we didn't mess Z

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e098] ror.l #8, d0 uses Ope098 ----------
Ope098:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Rotate register:
  movs r0,r0,ror #8
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0a0] asr.l d0, d0 uses Ope0a0 ----------
Ope0a0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,asr r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  movne r1,r9,lsr #28
  strneb r1,[r7,#0x45] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0a8] lsr.l d0, d0 uses Ope0a8 ----------
Ope0a8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  movne r1,r9,lsr #28
  strneb r1,[r7,#0x45] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0b0] roxr.l d0, d0 uses Ope0b0 ----------
Ope0b0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e0b0:
  subs r2,r2,#33
  bpl Reduce_e0b0
  adds r2,r2,#33 ;@ Now r2=0-32
  beq norotxe0b0

;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  mrs r9,cpsr ;@ r9=flags
  tst r0,r0
  bicne r9,r9,#0x40000000 ;@ make sure we didn't mess Z
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ if not 0, Save X bit
  b nozeroxe0b0
norotxe0b0:
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  ldrb r2,[r7,#0x45] ;@ C = old_X
  and r2,r2,#2
  orr r9,r9,r2,lsl #28
nozeroxe0b0:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0b8] ror.l d0, d0 uses Ope0b8 ----------
Ope0b8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear
  cmp r2,#0
  biceq r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0d0] asr.w (a0) uses Ope0d0 ----------
Ope0d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0d8] asr.w (a0)+ uses Ope0d8 ----------
Ope0d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0df] asr.w (a7)+ uses Ope0df ----------
Ope0df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '(a7)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0e0] asr.w -(a0) uses Ope0e0 ----------
Ope0e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0e7] asr.w -(a7) uses Ope0e7 ----------
Ope0e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0e8] asr.w ($3333,a0) uses Ope0e8 ----------
Ope0e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0f0] asr.w ($33,a0,d3.w*2) uses Ope0f0 ----------
Ope0f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0f8] asr.w $3333.w uses Ope0f8 ----------
Ope0f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0f9] asr.w $33333333.l uses Ope0f9 ----------
Ope0f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e100] asl.b #8, d0 uses Ope100 ----------
Ope100:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl #8
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #8
  cmpne r3,r1,asr #8
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e108] lsl.b #8, d0 uses Ope108 ----------
Ope108:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e110] roxl.b #8, d0 uses Ope110 ----------
Ope110:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,#1 ;@ Reversed
  mov r0,r0,lsr #24 ;@ Shift down
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e118] rol.b #8, d0 uses Ope118 ----------
Ope118:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #24
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e120] asl.b d0, d0 uses Ope120 ----------
Ope120:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  movne r1,r9,lsr #28
  strneb r1,[r7,#0x45] ;@ else Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e128] lsl.b d0, d0 uses Ope128 ----------
Ope128:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  movne r1,r9,lsr #28
  strneb r1,[r7,#0x45] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e130] roxl.b d0, d0 uses Ope130 ----------
Ope130:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e130:
  subs r2,r2,#9
  bpl Reduce_e130
  adds r2,r2,#9 ;@ Now r2=0-8
  beq norotxe130

  rsb r2,r2,#9 ;@ Reverse direction
  mov r0,r0,lsr #24 ;@ Shift down
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ if not 0, Save X bit
  b nozeroxe130
norotxe130:
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  ldrb r2,[r7,#0x45] ;@ C = old_X
  and r2,r2,#2
  orr r9,r9,r2,lsl #28
nozeroxe130:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e138] rol.b d0, d0 uses Ope138 ----------
Ope138:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsbs r2,r2,#32
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  cmp r2,#32 ;@ rotating by 0?
  tstne r0,#1 ;@ no, check bit 0
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e140] asl.w #8, d0 uses Ope140 ----------
Ope140:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl #8
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #8
  cmpne r3,r1,asr #8
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e148] lsl.w #8, d0 uses Ope148 ----------
Ope148:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e150] roxl.w #8, d0 uses Ope150 ----------
Ope150:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,#9 ;@ Reversed
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e158] rol.w #8, d0 uses Ope158 ----------
Ope158:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #24
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e160] asl.w d0, d0 uses Ope160 ----------
Ope160:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  movne r1,r9,lsr #28
  strneb r1,[r7,#0x45] ;@ else Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e168] lsl.w d0, d0 uses Ope168 ----------
Ope168:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  movne r1,r9,lsr #28
  strneb r1,[r7,#0x45] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e170] roxl.w d0, d0 uses Ope170 ----------
Ope170:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e170:
  subs r2,r2,#17
  bpl Reduce_e170
  adds r2,r2,#17 ;@ Now r2=0-16
  beq norotxe170

  rsb r2,r2,#17 ;@ Reverse direction
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ if not 0, Save X bit
  b nozeroxe170
norotxe170:
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  ldrb r2,[r7,#0x45] ;@ C = old_X
  and r2,r2,#2
  orr r9,r9,r2,lsl #28
nozeroxe170:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e178] rol.w d0, d0 uses Ope178 ----------
Ope178:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsbs r2,r2,#32
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  cmp r2,#32 ;@ rotating by 0?
  tstne r0,#1 ;@ no, check bit 0
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e180] asl.l #8, d0 uses Ope180 ----------
Ope180:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl #8
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #8
  cmpne r3,r1,asr #8
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e188] lsl.l #8, d0 uses Ope188 ----------
Ope188:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e190] roxl.l #8, d0 uses Ope190 ----------
Ope190:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,#25 ;@ Reversed
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r0,r0
  bicne r9,r9,#0x40000000 ;@ make sure we didn't mess Z

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e198] rol.l #8, d0 uses Ope198 ----------
Ope198:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Rotate register:
  movs r0,r0,ror #24
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1a0] asl.l d0, d0 uses Ope1a0 ----------
Ope1a0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  movne r1,r9,lsr #28
  strneb r1,[r7,#0x45] ;@ else Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1a8] lsl.l d0, d0 uses Ope1a8 ----------
Ope1a8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  movne r1,r9,lsr #28
  strneb r1,[r7,#0x45] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1b0] roxl.l d0, d0 uses Ope1b0 ----------
Ope1b0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e1b0:
  subs r2,r2,#33
  bpl Reduce_e1b0
  adds r2,r2,#33 ;@ Now r2=0-32
  beq norotxe1b0

  rsb r2,r2,#33 ;@ Reverse direction
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  mrs r9,cpsr ;@ r9=flags
  tst r0,r0
  bicne r9,r9,#0x40000000 ;@ make sure we didn't mess Z
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ if not 0, Save X bit
  b nozeroxe1b0
norotxe1b0:
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  ldrb r2,[r7,#0x45] ;@ C = old_X
  and r2,r2,#2
  orr r9,r9,r2,lsl #28
nozeroxe1b0:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1b8] rol.l d0, d0 uses Ope1b8 ----------
Ope1b8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#7<<9
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  rsbs r2,r2,#32
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  cmp r2,#32 ;@ rotating by 0?
  tstne r0,#1 ;@ no, check bit 0
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1d0] asl.w (a0) uses Ope1d0 ----------
Ope1d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1d8] asl.w (a0)+ uses Ope1d8 ----------
Ope1d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1df] asl.w (a7)+ uses Ope1df ----------
Ope1df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '(a7)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1e0] asl.w -(a0) uses Ope1e0 ----------
Ope1e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1e7] asl.w -(a7) uses Ope1e7 ----------
Ope1e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '-(a7)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1e8] asl.w ($3333,a0) uses Ope1e8 ----------
Ope1e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1f0] asl.w ($33,a0,d3.w*2) uses Ope1f0 ----------
Ope1f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1f8] asl.w $3333.w uses Ope1f8 ----------
Ope1f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1f9] asl.w $33333333.l uses Ope1f9 ----------
Ope1f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e210] roxr.b #1, d0 uses Ope210 ----------
Ope210:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  orr r0,r0,r0,lsr #24
  bic r0,r0,#0x1000000
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e250] roxr.w #1, d0 uses Ope250 ----------
Ope250:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e290] roxr.l #1, d0 uses Ope290 ----------
Ope290:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2d0] lsr.w (a0) uses Ope2d0 ----------
Ope2d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2d8] lsr.w (a0)+ uses Ope2d8 ----------
Ope2d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2df] lsr.w (a7)+ uses Ope2df ----------
Ope2df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '(a7)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2e0] lsr.w -(a0) uses Ope2e0 ----------
Ope2e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2e7] lsr.w -(a7) uses Ope2e7 ----------
Ope2e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2e8] lsr.w ($3333,a0) uses Ope2e8 ----------
Ope2e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2f0] lsr.w ($33,a0,d3.w*2) uses Ope2f0 ----------
Ope2f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2f8] lsr.w $3333.w uses Ope2f8 ----------
Ope2f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2f9] lsr.w $33333333.l uses Ope2f9 ----------
Ope2f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e310] roxl.b #1, d0 uses Ope310 ----------
Ope310:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  ldrb r3,[r7,#0x45]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r3,#2
  orrne r0,r0,#0x1000000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e350] roxl.w #1, d0 uses Ope350 ----------
Ope350:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  ldrb r3,[r7,#0x45]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r3,#2
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e390] roxl.l #1, d0 uses Ope390 ----------
Ope390:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  ldrb r3,[r7,#0x45]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r3,#2
  orrne r0,r0,#0x1
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3d0] lsl.w (a0) uses Ope3d0 ----------
Ope3d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3d8] lsl.w (a0)+ uses Ope3d8 ----------
Ope3d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3df] lsl.w (a7)+ uses Ope3df ----------
Ope3df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '(a7)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3e0] lsl.w -(a0) uses Ope3e0 ----------
Ope3e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3e7] lsl.w -(a7) uses Ope3e7 ----------
Ope3e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3e8] lsl.w ($3333,a0) uses Ope3e8 ----------
Ope3e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3f0] lsl.w ($33,a0,d3.w*2) uses Ope3f0 ----------
Ope3f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3f8] lsl.w $3333.w uses Ope3f8 ----------
Ope3f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3f9] lsl.w $33333333.l uses Ope3f9 ----------
Ope3f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4d0] roxr.w (a0) uses Ope4d0 ----------
Ope4d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4d8] roxr.w (a0)+ uses Ope4d8 ----------
Ope4d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4df] roxr.w (a7)+ uses Ope4df ----------
Ope4df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a7)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4e0] roxr.w -(a0) uses Ope4e0 ----------
Ope4e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4e7] roxr.w -(a7) uses Ope4e7 ----------
Ope4e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '-(a7)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4e8] roxr.w ($3333,a0) uses Ope4e8 ----------
Ope4e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4f0] roxr.w ($33,a0,d3.w*2) uses Ope4f0 ----------
Ope4f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4f8] roxr.w $3333.w uses Ope4f8 ----------
Ope4f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4f9] roxr.w $33333333.l uses Ope4f9 ----------
Ope4f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5d0] roxl.w (a0) uses Ope5d0 ----------
Ope5d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldrb r3,[r7,#0x45]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r3,#2
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5d8] roxl.w (a0)+ uses Ope5d8 ----------
Ope5d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldrb r3,[r7,#0x45]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r3,#2
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5df] roxl.w (a7)+ uses Ope5df ----------
Ope5df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldrb r3,[r7,#0x45]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r3,#2
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a7)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5e0] roxl.w -(a0) uses Ope5e0 ----------
Ope5e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldrb r3,[r7,#0x45]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r3,#2
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5e7] roxl.w -(a7) uses Ope5e7 ----------
Ope5e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldrb r3,[r7,#0x45]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r3,#2
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '-(a7)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5e8] roxl.w ($3333,a0) uses Ope5e8 ----------
Ope5e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldrb r3,[r7,#0x45]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r3,#2
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5f0] roxl.w ($33,a0,d3.w*2) uses Ope5f0 ----------
Ope5f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldrb r3,[r7,#0x45]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r3,#2
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5f8] roxl.w $3333.w uses Ope5f8 ----------
Ope5f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldrb r3,[r7,#0x45]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r3,#2
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5f9] roxl.w $33333333.l uses Ope5f9 ----------
Ope5f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldrb r3,[r7,#0x45]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r3,#2
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6d0] ror.w (a0) uses Ope6d0 ----------
Ope6d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6d8] ror.w (a0)+ uses Ope6d8 ----------
Ope6d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6df] ror.w (a7)+ uses Ope6df ----------
Ope6df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: Write r0 into '(a7)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6e0] ror.w -(a0) uses Ope6e0 ----------
Ope6e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6e7] ror.w -(a7) uses Ope6e7 ----------
Ope6e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: Write r0 into '-(a7)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6e8] ror.w ($3333,a0) uses Ope6e8 ----------
Ope6e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6f0] ror.w ($33,a0,d3.w*2) uses Ope6f0 ----------
Ope6f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6f8] ror.w $3333.w uses Ope6f8 ----------
Ope6f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6f9] ror.w $33333333.l uses Ope6f9 ----------
Ope6f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7d0] rol.w (a0) uses Ope7d0 ----------
Ope7d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7d8] rol.w (a0)+ uses Ope7d8 ----------
Ope7d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7df] rol.w (a7)+ uses Ope7df ----------
Ope7df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: Write r0 into '(a7)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7e0] rol.w -(a0) uses Ope7e0 ----------
Ope7e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7e7] rol.w -(a7) uses Ope7e7 ----------
Ope7e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: Write r0 into '-(a7)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7e8] rol.w ($3333,a0) uses Ope7e8 ----------
Ope7e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7f0] rol.w ($33,a0,d3.w*2) uses Ope7f0 ----------
Ope7f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7f8] rol.w $3333.w uses Ope7f8 ----------
Ope7f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7f9] rol.w $33333333.l uses Ope7f9 ----------
Ope7f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee00] asr.b #7, d0 uses Opee00 ----------
Opee00:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #24

;@ Shift register:
  movs r0,r0,asr r2
;@ restore after right shift:
  mov r0,r0,lsl #24

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee08] lsr.b #7, d0 uses Opee08 ----------
Opee08:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr r2
;@ restore after right shift:
  mov r0,r0,lsl #24

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee10] roxr.b #7, d0 uses Opee10 ----------
Opee10:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r0,r0,lsr #24 ;@ Shift down
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee18] ror.b #7, d0 uses Opee18 ----------
Opee18:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee40] asr.w #7, d0 uses Opee40 ----------
Opee40:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr r2
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee48] lsr.w #7, d0 uses Opee48 ----------
Opee48:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr r2
;@ restore after right shift:
  mov r0,r0,lsl #16

  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee50] roxr.w #7, d0 uses Opee50 ----------
Opee50:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee58] ror.w #7, d0 uses Opee58 ----------
Opee58:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee80] asr.l #7, d0 uses Opee80 ----------
Opee80:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,asr r2
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee88] lsr.l #7, d0 uses Opee88 ----------
Opee88:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee90] roxr.l #7, d0 uses Opee90 ----------
Opee90:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r0,r0
  bicne r9,r9,#0x40000000 ;@ make sure we didn't mess Z

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee98] ror.l #7, d0 uses Opee98 ----------
Opee98:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x10000000 ;@ make suve V is clear

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef00] asl.b #7, d0 uses Opef00 ----------
Opef00:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef08] lsl.b #7, d0 uses Opef08 ----------
Opef08:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef10] roxl.b #7, d0 uses Opef10 ----------
Opef10:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  rsb r2,r2,#9 ;@ Reverse direction
  mov r0,r0,lsr #24 ;@ Shift down
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef18] rol.b #7, d0 uses Opef18 ----------
Opef18:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldrb r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsbs r2,r2,#32
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef40] asl.w #7, d0 uses Opef40 ----------
Opef40:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef48] lsl.w #7, d0 uses Opef48 ----------
Opef48:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef50] roxl.w #7, d0 uses Opef50 ----------
Opef50:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  rsb r2,r2,#17 ;@ Reverse direction
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef58] rol.w #7, d0 uses Opef58 ----------
Opef58:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsbs r2,r2,#32
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef80] asl.l #7, d0 uses Opef80 ----------
Opef80:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r3,r0 ;@ save old value for V flag calculation
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit
;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  biceq r9,r9,#0x10000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef88] lsl.l #7, d0 uses Opef88 ----------
Opef88:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr ;@ r9=flags
  mov r1,r9,lsr #28
  strb r1,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef90] roxl.l #7, d0 uses Opef90 ----------
Opef90:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  rsb r2,r2,#33 ;@ Reverse direction
;@ Rotate bits:
  mov r3,r0,lsr r2 ;@ Get right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  movs r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  orr r0,r0,r3,lsl r2

  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r0,r0
  bicne r9,r9,#0x40000000 ;@ make sure we didn't mess Z

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef98] rol.l #7, d0 uses Opef98 ----------
Opef98:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  rsbs r2,r2,#32
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ -------------------------- Jump Table --------------------------
  .data
  .align 4

JumpTab:
  .rept 0x1400
  .long 0,0,0,0,0,0,0,0
  .endr
  .long Op____,Op__al,Op__fl,Op0000,Op0010,Op0018,Op001f,Op0020 ;@ 0020
  .long Op0027,Op0028,Op0030,Op0038,Op0039,Op003c,Op0040,Op0050 ;@ 0050
  .long Op0058,Op005f,Op0060,Op0067,Op0068,Op0070,Op0078,Op0079 ;@ 0079
  .long Op007c,Op0080,Op0090,Op0098,Op009f,Op00a0,Op00a7,Op00a8 ;@ 00a8
  .long Op00b0,Op00b8,Op00b9,Op0100,Op0108,Op0110,Op0118,Op011f ;@ 011f
  .long Op0120,Op0127,Op0128,Op0130,Op0138,Op0139,Op013a,Op013b ;@ 013b
  .long Op013c,Op0140,Op0148,Op0150,Op0158,Op015f,Op0160,Op0167 ;@ 0167
  .long Op0168,Op0170,Op0178,Op0179,Op0180,Op0188,Op0190,Op0198 ;@ 0198
  .long Op019f,Op01a0,Op01a7,Op01a8,Op01b0,Op01b8,Op01b9,Op01c0 ;@ 01c0
  .long Op01c8,Op01d0,Op01d8,Op01df,Op01e0,Op01e7,Op01e8,Op01f0 ;@ 01f0
  .long Op01f8,Op01f9,Op0200,Op0210,Op0218,Op021f,Op0220,Op0227 ;@ 0227
  .long Op0228,Op0230,Op0238,Op0239,Op023c,Op0240,Op0250,Op0258 ;@ 0258
  .long Op025f,Op0260,Op0267,Op0268,Op0270,Op0278,Op0279,Op027c ;@ 027c
  .long Op0280,Op0290,Op0298,Op029f,Op02a0,Op02a7,Op02a8,Op02b0 ;@ 02b0
  .long Op02b8,Op02b9,Op0400,Op0410,Op0418,Op041f,Op0420,Op0427 ;@ 0427
  .long Op0428,Op0430,Op0438,Op0439,Op0440,Op0450,Op0458,Op045f ;@ 045f
  .long Op0460,Op0467,Op0468,Op0470,Op0478,Op0479,Op0480,Op0490 ;@ 0490
  .long Op0498,Op049f,Op04a0,Op04a7,Op04a8,Op04b0,Op04b8,Op04b9 ;@ 04b9
  .long Op0600,Op0610,Op0618,Op061f,Op0620,Op0627,Op0628,Op0630 ;@ 0630
  .long Op0638,Op0639,Op0640,Op0650,Op0658,Op065f,Op0660,Op0667 ;@ 0667
  .long Op0668,Op0670,Op0678,Op0679,Op0680,Op0690,Op0698,Op069f ;@ 069f
  .long Op06a0,Op06a7,Op06a8,Op06b0,Op06b8,Op06b9,Op0800,Op0810 ;@ 0810
  .long Op0818,Op081f,Op0820,Op0827,Op0828,Op0830,Op0838,Op0839 ;@ 0839
  .long Op083a,Op083b,Op0840,Op0850,Op0858,Op085f,Op0860,Op0867 ;@ 0867
  .long Op0868,Op0870,Op0878,Op0879,Op0880,Op0890,Op0898,Op089f ;@ 089f
  .long Op08a0,Op08a7,Op08a8,Op08b0,Op08b8,Op08b9,Op08c0,Op08d0 ;@ 08d0
  .long Op08d8,Op08df,Op08e0,Op08e7,Op08e8,Op08f0,Op08f8,Op08f9 ;@ 08f9
  .long Op0a00,Op0a10,Op0a18,Op0a1f,Op0a20,Op0a27,Op0a28,Op0a30 ;@ 0a30
  .long Op0a38,Op0a39,Op0a3c,Op0a40,Op0a50,Op0a58,Op0a5f,Op0a60 ;@ 0a60
  .long Op0a67,Op0a68,Op0a70,Op0a78,Op0a79,Op0a7c,Op0a80,Op0a90 ;@ 0a90
  .long Op0a98,Op0a9f,Op0aa0,Op0aa7,Op0aa8,Op0ab0,Op0ab8,Op0ab9 ;@ 0ab9
  .long Op0c00,Op0c10,Op0c18,Op0c1f,Op0c20,Op0c27,Op0c28,Op0c30 ;@ 0c30
  .long Op0c38,Op0c39,Op0c40,Op0c50,Op0c58,Op0c5f,Op0c60,Op0c67 ;@ 0c67
  .long Op0c68,Op0c70,Op0c78,Op0c79,Op0c80,Op0c90,Op0c98,Op0c9f ;@ 0c9f
  .long Op0ca0,Op0ca7,Op0ca8,Op0cb0,Op0cb8,Op0cb9,Op1000,Op1010 ;@ 1010
  .long Op1018,Op101f,Op1020,Op1027,Op1028,Op1030,Op1038,Op1039 ;@ 1039
  .long Op103a,Op103b,Op103c,Op1080,Op1090,Op1098,Op109f,Op10a0 ;@ 10a0
  .long Op10a7,Op10a8,Op10b0,Op10b8,Op10b9,Op10ba,Op10bb,Op10bc ;@ 10bc
  .long Op10c0,Op10d0,Op10d8,Op10df,Op10e0,Op10e7,Op10e8,Op10f0 ;@ 10f0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op1100,Op1110,Op1118 ;@ 1118
  .long Op111f,Op1120,Op1127,Op1128,Op1130,Op1138,Op1139,Op113a ;@ 113a
  .long Op113b,Op113c,Op1140,Op1150,Op1158,Op115f,Op1160,Op1167 ;@ 1167
  .long Op1168,Op1170,Op1178,Op1179,Op117a,Op117b,Op117c,Op1180 ;@ 1180
  .long Op1190,Op1198,Op119f,Op11a0,Op11a7,Op11a8,Op11b0,Op11b8 ;@ 11b8
  .long Op11b9,Op11ba,Op11bb,Op11bc,Op11c0,Op11d0,Op11d8,Op11df ;@ 11df
  .long Op11e0,Op11e7,Op11e8,Op11f0,Op11f8,Op11f9,Op11fa,Op11fb ;@ 11fb
  .long Op11fc,Op13c0,Op13d0,Op13d8,Op13df,Op13e0,Op13e7,Op13e8 ;@ 13e8
  .long Op13f0,Op13f8,Op13f9,Op13fa,Op13fb,Op13fc,Op1ec0,Op1ed0 ;@ 1ed0
  .long Op1ed8,Op1edf,Op1ee0,Op1ee7,Op1ee8,Op1ef0,Op1ef8,Op1ef9 ;@ 1ef9
  .long Op1efa,Op1efb,Op1efc,Op1f00,Op1f10,Op1f18,Op1f1f,Op1f20 ;@ 1f20
  .long Op1f27,Op1f28,Op1f30,Op1f38,Op1f39,Op1f3a,Op1f3b,Op1f3c ;@ 1f3c
  .long Op2000,Op2010,Op2018,Op201f,Op2020,Op2027,Op2028,Op2030 ;@ 2030
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op2040,Op2050,Op2058 ;@ 2058
  .long Op205f,Op2060,Op2067,Op2068,Op2070,Op2078,Op2079,Op207a ;@ 207a
  .long Op207b,Op207c,Op2080,Op2090,Op2098,Op209f,Op20a0,Op20a7 ;@ 20a7
  .long Op20a8,Op20b0,Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op20c0 ;@ 20c0
  .long Op20d0,Op20d8,Op20df,Op20e0,Op20e7,Op20e8,Op20f0,Op20f8 ;@ 20f8
  .long Op20f9,Op20fa,Op20fb,Op20fc,Op2100,Op2110,Op2118,Op211f ;@ 211f
  .long Op2120,Op2127,Op2128,Op2130,Op2138,Op2139,Op213a,Op213b ;@ 213b
  .long Op213c,Op2140,Op2150,Op2158,Op215f,Op2160,Op2167,Op2168 ;@ 2168
  .long Op2170,Op2178,Op2179,Op217a,Op217b,Op217c,Op2180,Op2190 ;@ 2190
  .long Op2198,Op219f,Op21a0,Op21a7,Op21a8,Op21b0,Op21b8,Op21b9 ;@ 21b9
  .long Op21ba,Op21bb,Op21bc,Op21c0,Op21d0,Op21d8,Op21df,Op21e0 ;@ 21e0
  .long Op21e7,Op21e8,Op21f0,Op21f8,Op21f9,Op21fa,Op21fb,Op21fc ;@ 21fc
  .long Op23c0,Op23d0,Op23d8,Op23df,Op23e0,Op23e7,Op23e8,Op23f0 ;@ 23f0
  .long Op23f8,Op23f9,Op23fa,Op23fb,Op23fc,Op2ec0,Op2ed0,Op2ed8 ;@ 2ed8
  .long Op2edf,Op2ee0,Op2ee7,Op2ee8,Op2ef0,Op2ef8,Op2ef9,Op2efa ;@ 2efa
  .long Op2efb,Op2efc,Op2f00,Op2f10,Op2f18,Op2f1f,Op2f20,Op2f27 ;@ 2f27
  .long Op2f28,Op2f30,Op2f38,Op2f39,Op2f3a,Op2f3b,Op2f3c,Op3000 ;@ 3000
  .long Op3010,Op3018,Op301f,Op3020,Op3027,Op3028,Op3030,Op3038 ;@ 3038
  .long Op3039,Op303a,Op303b,Op303c,Op3040,Op3050,Op3058,Op305f ;@ 305f
  .long Op3060,Op3067,Op3068,Op3070,Op3078,Op3079,Op307a,Op307b ;@ 307b
  .long Op307c,Op3080,Op3090,Op3098,Op309f,Op30a0,Op30a7,Op30a8 ;@ 30a8
  .long Op30b0,Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op30c0,Op30d0 ;@ 30d0
  .long Op30d8,Op30df,Op30e0,Op30e7,Op30e8,Op30f0,Op30f8,Op30f9 ;@ 30f9
  .long Op30fa,Op30fb,Op30fc,Op3100,Op3110,Op3118,Op311f,Op3120 ;@ 3120
  .long Op3127,Op3128,Op3130,Op3138,Op3139,Op313a,Op313b,Op313c ;@ 313c
  .long Op3140,Op3150,Op3158,Op315f,Op3160,Op3167,Op3168,Op3170 ;@ 3170
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op3180,Op3190,Op3198 ;@ 3198
  .long Op319f,Op31a0,Op31a7,Op31a8,Op31b0,Op31b8,Op31b9,Op31ba ;@ 31ba
  .long Op31bb,Op31bc,Op31c0,Op31d0,Op31d8,Op31df,Op31e0,Op31e7 ;@ 31e7
  .long Op31e8,Op31f0,Op31f8,Op31f9,Op31fa,Op31fb,Op31fc,Op33c0 ;@ 33c0
  .long Op33d0,Op33d8,Op33df,Op33e0,Op33e7,Op33e8,Op33f0,Op33f8 ;@ 33f8
  .long Op33f9,Op33fa,Op33fb,Op33fc,Op3ec0,Op3ed0,Op3ed8,Op3edf ;@ 3edf
  .long Op3ee0,Op3ee7,Op3ee8,Op3ef0,Op3ef8,Op3ef9,Op3efa,Op3efb ;@ 3efb
  .long Op3efc,Op3f00,Op3f10,Op3f18,Op3f1f,Op3f20,Op3f27,Op3f28 ;@ 3f28
  .long Op3f30,Op3f38,Op3f39,Op3f3a,Op3f3b,Op3f3c,Op4000,Op4010 ;@ 4010
  .long Op4018,Op401f,Op4020,Op4027,Op4028,Op4030,Op4038,Op4039 ;@ 4039
  .long Op4040,Op4050,Op4058,Op405f,Op4060,Op4067,Op4068,Op4070 ;@ 4070
  .long Op4078,Op4079,Op4080,Op4090,Op4098,Op409f,Op40a0,Op40a7 ;@ 40a7
  .long Op40a8,Op40b0,Op40b8,Op40b9,Op40c0,Op40d0,Op40d8,Op40df ;@ 40df
  .long Op40e0,Op40e7,Op40e8,Op40f0,Op40f8,Op40f9,Op4180,Op4190 ;@ 4190
  .long Op4198,Op419f,Op41a0,Op41a7,Op41a8,Op41b0,Op41b8,Op41b9 ;@ 41b9
  .long Op41ba,Op41bb,Op41bc,Op41d0,Op41e8,Op41f0,Op41f8,Op41f9 ;@ 41f9
  .long Op41fa,Op41fb,Op4200,Op4210,Op4218,Op421f,Op4220,Op4227 ;@ 4227
  .long Op4228,Op4230,Op4238,Op4239,Op4240,Op4250,Op4258,Op425f ;@ 425f
  .long Op4260,Op4267,Op4268,Op4270,Op4278,Op4279,Op4280,Op4290 ;@ 4290
  .long Op4298,Op429f,Op42a0,Op42a7,Op42a8,Op42b0,Op42b8,Op42b9 ;@ 42b9
  .long Op4400,Op4410,Op4418,Op441f,Op4420,Op4427,Op4428,Op4430 ;@ 4430
  .long Op4438,Op4439,Op4440,Op4450,Op4458,Op445f,Op4460,Op4467 ;@ 4467
  .long Op4468,Op4470,Op4478,Op4479,Op4480,Op4490,Op4498,Op449f ;@ 449f
  .long Op44a0,Op44a7,Op44a8,Op44b0,Op44b8,Op44b9,Op44c0,Op44d0 ;@ 44d0
  .long Op44d8,Op44df,Op44e0,Op44e7,Op44e8,Op44f0,Op44f8,Op44f9 ;@ 44f9
  .long Op44fa,Op44fb,Op44fc,Op4600,Op4610,Op4618,Op461f,Op4620 ;@ 4620
  .long Op4627,Op4628,Op4630,Op4638,Op4639,Op4640,Op4650,Op4658 ;@ 4658
  .long Op465f,Op4660,Op4667,Op4668,Op4670,Op4678,Op4679,Op4680 ;@ 4680
  .long Op4690,Op4698,Op469f,Op46a0,Op46a7,Op46a8,Op46b0,Op46b8 ;@ 46b8
  .long Op46b9,Op46c0,Op46d0,Op46d8,Op46df,Op46e0,Op46e7,Op46e8 ;@ 46e8
  .long Op46f0,Op46f8,Op46f9,Op46fa,Op46fb,Op46fc,Op4800,Op4810 ;@ 4810
  .long Op4818,Op481f,Op4820,Op4827,Op4828,Op4830,Op4838,Op4839 ;@ 4839
  .long Op4840,Op4850,Op4868,Op4870,Op4878,Op4879,Op487a,Op487b ;@ 487b
  .long Op4880,Op4890,Op48a0,Op48a7,Op48a8,Op48b0,Op48b8,Op48b9 ;@ 48b9
  .long Op48c0,Op48d0,Op48e0,Op48e7,Op48e8,Op48f0,Op48f8,Op48f9 ;@ 48f9
  .long Op4a00,Op4a10,Op4a18,Op4a1f,Op4a20,Op4a27,Op4a28,Op4a30 ;@ 4a30
  .long Op4a38,Op4a39,Op4a40,Op4a50,Op4a58,Op4a5f,Op4a60,Op4a67 ;@ 4a67
  .long Op4a68,Op4a70,Op4a78,Op4a79,Op4a80,Op4a90,Op4a98,Op4a9f ;@ 4a9f
  .long Op4aa0,Op4aa7,Op4aa8,Op4ab0,Op4ab8,Op4ab9,Op4ac0,Op4ad0 ;@ 4ad0
  .long Op4ad8,Op4adf,Op4ae0,Op4ae7,Op4ae8,Op4af0,Op4af8,Op4af9 ;@ 4af9
  .long Op4c90,Op4c98,Op4c9f,Op4ca8,Op4cb0,Op4cb8,Op4cb9,Op4cba ;@ 4cba
  .long Op4cbb,Op4cd0,Op4cd8,Op4cdf,Op4ce8,Op4cf0,Op4cf8,Op4cf9 ;@ 4cf9
  .long Op4cfa,Op4cfb,Op4e40,Op4e50,Op4e57,Op4e58,Op4e60,Op4e68 ;@ 4e68
  .long Op4e70,Op4e71,Op4e72,Op4e73,Op4e75,Op4e76,Op4e77,Op4e90 ;@ 4e90
  .long Op4ea8,Op4eb0,Op4eb8,Op4eb9,Op4eba,Op4ebb,Op4ed0,Op4ee8 ;@ 4ee8
  .long Op4ef0,Op4ef8,Op4ef9,Op4efa,Op4efb,Op5000,Op5010,Op5018 ;@ 5018
  .long Op501f,Op5020,Op5027,Op5028,Op5030,Op5038,Op5039,Op5040 ;@ 5040
  .long Op5048,Op5050,Op5058,Op505f,Op5060,Op5067,Op5068,Op5070 ;@ 5070
  .long Op5078,Op5079,Op5080,Op5088,Op5090,Op5098,Op509f,Op50a0 ;@ 50a0
  .long Op50a7,Op50a8,Op50b0,Op50b8,Op50b9,Op50c0,Op50c8,Op50d0 ;@ 50d0
  .long Op50d8,Op50df,Op50e0,Op50e7,Op50e8,Op50f0,Op50f8,Op50f9 ;@ 50f9
  .long Op5100,Op5110,Op5118,Op511f,Op5120,Op5127,Op5128,Op5130 ;@ 5130
  .long Op5138,Op5139,Op5140,Op5148,Op5150,Op5158,Op515f,Op5160 ;@ 5160
  .long Op5167,Op5168,Op5170,Op5178,Op5179,Op5180,Op5188,Op5190 ;@ 5190
  .long Op5198,Op519f,Op51a0,Op51a7,Op51a8,Op51b0,Op51b8,Op51b9 ;@ 51b9
  .long Op51c0,Op51c8,Op51d0,Op51d8,Op51df,Op51e0,Op51e7,Op51e8 ;@ 51e8
  .long Op51f0,Op51f8,Op51f9,Op5e00,Op5e10,Op5e18,Op5e1f,Op5e20 ;@ 5220
  .long Op5e27,Op5e28,Op5e30,Op5e38,Op5e39,Op5e40,Op5e48,Op5e50 ;@ 5250
  .long Op5e58,Op5e5f,Op5e60,Op5e67,Op5e68,Op5e70,Op5e78,Op5e79 ;@ 5279
  .long Op5e80,Op5e88,Op5e90,Op5e98,Op5e9f,Op5ea0,Op5ea7,Op5ea8 ;@ 52a8
  .long Op5eb0,Op5eb8,Op5eb9,Op52c0,Op52c8,Op52d0,Op52d8,Op52df ;@ 52df
  .long Op52e0,Op52e7,Op52e8,Op52f0,Op52f8,Op52f9,Op5f00,Op5f10 ;@ 5310
  .long Op5f18,Op5f1f,Op5f20,Op5f27,Op5f28,Op5f30,Op5f38,Op5f39 ;@ 5339
  .long Op5f40,Op5f48,Op5f50,Op5f58,Op5f5f,Op5f60,Op5f67,Op5f68 ;@ 5368
  .long Op5f70,Op5f78,Op5f79,Op5f80,Op5f88,Op5f90,Op5f98,Op5f9f ;@ 539f
  .long Op5fa0,Op5fa7,Op5fa8,Op5fb0,Op5fb8,Op5fb9,Op53c0,Op53c8 ;@ 53c8
  .long Op53d0,Op53d8,Op53df,Op53e0,Op53e7,Op53e8,Op53f0,Op53f8 ;@ 53f8
  .long Op53f9,Op54c0,Op54c8,Op54d0,Op54d8,Op54df,Op54e0,Op54e7 ;@ 54e7
  .long Op54e8,Op54f0,Op54f8,Op54f9,Op55c0,Op55c8,Op55d0,Op55d8 ;@ 55d8
  .long Op55df,Op55e0,Op55e7,Op55e8,Op55f0,Op55f8,Op55f9,Op56c0 ;@ 56c0
  .long Op56c8,Op56d0,Op56d8,Op56df,Op56e0,Op56e7,Op56e8,Op56f0 ;@ 56f0
  .long Op56f8,Op56f9,Op57c0,Op57c8,Op57d0,Op57d8,Op57df,Op57e0 ;@ 57e0
  .long Op57e7,Op57e8,Op57f0,Op57f8,Op57f9,Op58c0,Op58c8,Op58d0 ;@ 58d0
  .long Op58d8,Op58df,Op58e0,Op58e7,Op58e8,Op58f0,Op58f8,Op58f9 ;@ 58f9
  .long Op59c0,Op59c8,Op59d0,Op59d8,Op59df,Op59e0,Op59e7,Op59e8 ;@ 59e8
  .long Op59f0,Op59f8,Op59f9,Op5ac0,Op5ac8,Op5ad0,Op5ad8,Op5adf ;@ 5adf
  .long Op5ae0,Op5ae7,Op5ae8,Op5af0,Op5af8,Op5af9,Op5bc0,Op5bc8 ;@ 5bc8
  .long Op5bd0,Op5bd8,Op5bdf,Op5be0,Op5be7,Op5be8,Op5bf0,Op5bf8 ;@ 5bf8
  .long Op5bf9,Op5cc0,Op5cc8,Op5cd0,Op5cd8,Op5cdf,Op5ce0,Op5ce7 ;@ 5ce7
  .long Op5ce8,Op5cf0,Op5cf8,Op5cf9,Op5dc0,Op5dc8,Op5dd0,Op5dd8 ;@ 5dd8
  .long Op5ddf,Op5de0,Op5de7,Op5de8,Op5df0,Op5df8,Op5df9,Op5ec0 ;@ 5ec0
  .long Op5ec8,Op5ed0,Op5ed8,Op5edf,Op5ee0,Op5ee7,Op5ee8,Op5ef0 ;@ 5ef0
  .long Op5ef8,Op5ef9,Op5fc0,Op5fc8,Op5fd0,Op5fd8,Op5fdf,Op5fe0 ;@ 5fe0
  .long Op5fe7,Op5fe8,Op5ff0,Op5ff8,Op5ff9,Op6000,Op6001,Op60ff ;@ 60ff
  .long Op6100,Op6101,Op61ff,Op6200,Op6201,Op62ff,Op6300,Op6301 ;@ 6301
  .long Op63ff,Op6400,Op6401,Op64ff,Op6500,Op6501,Op65ff,Op6600 ;@ 6600
  .long Op6601,Op66ff,Op6700,Op6701,Op67ff,Op6800,Op6801,Op68ff ;@ 68ff
  .long Op6900,Op6901,Op69ff,Op6a00,Op6a01,Op6aff,Op6b00,Op6b01 ;@ 6b01
  .long Op6bff,Op6c00,Op6c01,Op6cff,Op6d00,Op6d01,Op6dff,Op6e00 ;@ 6e00
  .long Op6e01,Op6eff,Op6f00,Op6f01,Op6fff,Op7000,Op8000,Op8010 ;@ 8010
  .long Op8018,Op801f,Op8020,Op8027,Op8028,Op8030,Op8038,Op8039 ;@ 8039
  .long Op803a,Op803b,Op803c,Op8040,Op8050,Op8058,Op805f,Op8060 ;@ 8060
  .long Op8067,Op8068,Op8070,Op8078,Op8079,Op807a,Op807b,Op807c ;@ 807c
  .long Op8080,Op8090,Op8098,Op809f,Op80a0,Op80a7,Op80a8,Op80b0 ;@ 80b0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op80c0,Op80d0,Op80d8 ;@ 80d8
  .long Op80df,Op80e0,Op80e7,Op80e8,Op80f0,Op80f8,Op80f9,Op80fa ;@ 80fa
  .long Op80fb,Op80fc,Op8100,Op8108,Op810f,Op8110,Op8118,Op811f ;@ 811f
  .long Op8120,Op8127,Op8128,Op8130,Op8138,Op8139,Op8150,Op8158 ;@ 8158
  .long Op815f,Op8160,Op8167,Op8168,Op8170,Op8178,Op8179,Op8190 ;@ 8190
  .long Op8198,Op819f,Op81a0,Op81a7,Op81a8,Op81b0,Op81b8,Op81b9 ;@ 81b9
  .long Op81c0,Op81d0,Op81d8,Op81df,Op81e0,Op81e7,Op81e8,Op81f0 ;@ 81f0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op830f,Op850f,Op870f ;@ 870f
  .long Op890f,Op8b0f,Op8d0f,Op8f08,Op8f09,Op8f0a,Op8f0b,Op8f0c ;@ 8f0c
  .long Op8f0d,Op8f0e,Op8f0f,Op9000,Op9010,Op9018,Op901f,Op9020 ;@ 9020
  .long Op9027,Op9028,Op9030,Op9038,Op9039,Op903a,Op903b,Op903c ;@ 903c
  .long Op9040,Op9050,Op9058,Op905f,Op9060,Op9067,Op9068,Op9070 ;@ 9070
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op9080,Op9090,Op9098 ;@ 9098
  .long Op909f,Op90a0,Op90a7,Op90a8,Op90b0,Op90b8,Op90b9,Op90ba ;@ 90ba
  .long Op90bb,Op90bc,Op90c0,Op90d0,Op90d8,Op90df,Op90e0,Op90e7 ;@ 90e7
  .long Op90e8,Op90f0,Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op9100 ;@ 9100
  .long Op9108,Op910f,Op9110,Op9118,Op911f,Op9120,Op9127,Op9128 ;@ 9128
  .long Op9130,Op9138,Op9139,Op9140,Op9148,Op9150,Op9158,Op915f ;@ 915f
  .long Op9160,Op9167,Op9168,Op9170,Op9178,Op9179,Op9180,Op9188 ;@ 9188
  .long Op9190,Op9198,Op919f,Op91a0,Op91a7,Op91a8,Op91b0,Op91b8 ;@ 91b8
  .long Op91b9,Op91c0,Op91d0,Op91d8,Op91df,Op91e0,Op91e7,Op91e8 ;@ 91e8
  .long Op91f0,Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op930f,Op950f ;@ 950f
  .long Op970f,Op990f,Op9b0f,Op9d0f,Op9f08,Op9f09,Op9f0a,Op9f0b ;@ 9f0b
  .long Op9f0c,Op9f0d,Op9f0e,Op9f0f,Opb000,Opb010,Opb018,Opb01f ;@ b01f
  .long Opb020,Opb027,Opb028,Opb030,Opb038,Opb039,Opb03a,Opb03b ;@ b03b
  .long Opb03c,Opb040,Opb050,Opb058,Opb05f,Opb060,Opb067,Opb068 ;@ b068
  .long Opb070,Opb078,Opb079,Opb07a,Opb07b,Opb07c,Opb080,Opb090 ;@ b090
  .long Opb098,Opb09f,Opb0a0,Opb0a7,Opb0a8,Opb0b0,Opb0b8,Opb0b9 ;@ b0b9
  .long Opb0ba,Opb0bb,Opb0bc,Opb0c0,Opb0d0,Opb0d8,Opb0df,Opb0e0 ;@ b0e0
  .long Opb0e7,Opb0e8,Opb0f0,Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc ;@ b0fc
  .long Opb100,Opb108,Opb10f,Opb110,Opb118,Opb11f,Opb120,Opb127 ;@ b127
  .long Opb128,Opb130,Opb138,Opb139,Opb140,Opb148,Opb150,Opb158 ;@ b158
  .long Opb15f,Opb160,Opb167,Opb168,Opb170,Opb178,Opb179,Opb180 ;@ b180
  .long Opb188,Opb190,Opb198,Opb19f,Opb1a0,Opb1a7,Opb1a8,Opb1b0 ;@ b1b0
  .long Opb1b8,Opb1b9,Opb1c0,Opb1d0,Opb1d8,Opb1df,Opb1e0,Opb1e7 ;@ b1e7
  .long Opb1e8,Opb1f0,Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Opb30f ;@ b30f
  .long Opb50f,Opb70f,Opb90f,Opbb0f,Opbd0f,Opbf08,Opbf09,Opbf0a ;@ bf0a
  .long Opbf0b,Opbf0c,Opbf0d,Opbf0e,Opbf0f,Opc000,Opc010,Opc018 ;@ c018
  .long Opc01f,Opc020,Opc027,Opc028,Opc030,Opc038,Opc039,Opc03a ;@ c03a
  .long Opc03b,Opc03c,Opc040,Opc050,Opc058,Opc05f,Opc060,Opc067 ;@ c067
  .long Opc068,Opc070,Opc078,Opc079,Opc07a,Opc07b,Opc07c,Opc080 ;@ c080
  .long Opc090,Opc098,Opc09f,Opc0a0,Opc0a7,Opc0a8,Opc0b0,Opc0b8 ;@ c0b8
  .long Opc0b9,Opc0ba,Opc0bb,Opc0bc,Opc0c0,Opc0d0,Opc0d8,Opc0df ;@ c0df
  .long Opc0e0,Opc0e7,Opc0e8,Opc0f0,Opc0f8,Opc0f9,Opc0fa,Opc0fb ;@ c0fb
  .long Opc0fc,Opc100,Opc108,Opc10f,Opc110,Opc118,Opc11f,Opc120 ;@ c120
  .long Opc127,Opc128,Opc130,Opc138,Opc139,Opc140,Opc148,Opc150 ;@ c150
  .long Opc158,Opc15f,Opc160,Opc167,Opc168,Opc170,Opc178,Opc179 ;@ c179
  .long Opc188,Opc190,Opc198,Opc19f,Opc1a0,Opc1a7,Opc1a8,Opc1b0 ;@ c1b0
  .long Opc1b8,Opc1b9,Opc1c0,Opc1d0,Opc1d8,Opc1df,Opc1e0,Opc1e7 ;@ c1e7
  .long Opc1e8,Opc1f0,Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Opc30f ;@ c30f
  .long Opc50f,Opc70f,Opc90f,Opcb0f,Opcd0f,Opcf08,Opcf09,Opcf0a ;@ cf0a
  .long Opcf0b,Opcf0c,Opcf0d,Opcf0e,Opcf0f,Opd000,Opd010,Opd018 ;@ d018
  .long Opd01f,Opd020,Opd027,Opd028,Opd030,Opd038,Opd039,Opd03a ;@ d03a
  .long Opd03b,Opd03c,Opd040,Opd050,Opd058,Opd05f,Opd060,Opd067 ;@ d067
  .long Opd068,Opd070,Opd078,Opd079,Opd07a,Opd07b,Opd07c,Opd080 ;@ d080
  .long Opd090,Opd098,Opd09f,Opd0a0,Opd0a7,Opd0a8,Opd0b0,Opd0b8 ;@ d0b8
  .long Opd0b9,Opd0ba,Opd0bb,Opd0bc,Opd0c0,Opd0d0,Opd0d8,Opd0df ;@ d0df
  .long Opd0e0,Opd0e7,Opd0e8,Opd0f0,Opd0f8,Opd0f9,Opd0fa,Opd0fb ;@ d0fb
  .long Opd0fc,Opd100,Opd108,Opd10f,Opd110,Opd118,Opd11f,Opd120 ;@ d120
  .long Opd127,Opd128,Opd130,Opd138,Opd139,Opd140,Opd148,Opd150 ;@ d150
  .long Opd158,Opd15f,Opd160,Opd167,Opd168,Opd170,Opd178,Opd179 ;@ d179
  .long Opd180,Opd188,Opd190,Opd198,Opd19f,Opd1a0,Opd1a7,Opd1a8 ;@ d1a8
  .long Opd1b0,Opd1b8,Opd1b9,Opd1c0,Opd1d0,Opd1d8,Opd1df,Opd1e0 ;@ d1e0
  .long Opd1e7,Opd1e8,Opd1f0,Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc ;@ d1fc
  .long Opd30f,Opd50f,Opd70f,Opd90f,Opdb0f,Opdd0f,Opdf08,Opdf09 ;@ df09
  .long Opdf0a,Opdf0b,Opdf0c,Opdf0d,Opdf0e,Opdf0f,Ope000,Ope008 ;@ e008
  .long Ope010,Ope018,Ope020,Ope028,Ope030,Ope038,Ope040,Ope048 ;@ e048
  .long Ope050,Ope058,Ope060,Ope068,Ope070,Ope078,Ope080,Ope088 ;@ e088
  .long Ope090,Ope098,Ope0a0,Ope0a8,Ope0b0,Ope0b8,Ope0d0,Ope0d8 ;@ e0d8
  .long Ope0df,Ope0e0,Ope0e7,Ope0e8,Ope0f0,Ope0f8,Ope0f9,Ope100 ;@ e100
  .long Ope108,Ope110,Ope118,Ope120,Ope128,Ope130,Ope138,Ope140 ;@ e140
  .long Ope148,Ope150,Ope158,Ope160,Ope168,Ope170,Ope178,Ope180 ;@ e180
  .long Ope188,Ope190,Ope198,Ope1a0,Ope1a8,Ope1b0,Ope1b8,Ope1d0 ;@ e1d0
  .long Ope1d8,Ope1df,Ope1e0,Ope1e7,Ope1e8,Ope1f0,Ope1f8,Ope1f9 ;@ e1f9
  .long Opee00,Opee08,Ope210,Opee18,Opee40,Opee48,Ope250,Opee58 ;@ e258
  .long Opee80,Opee88,Ope290,Opee98,Ope2d0,Ope2d8,Ope2df,Ope2e0 ;@ e2e0
  .long Ope2e7,Ope2e8,Ope2f0,Ope2f8,Ope2f9,Opef00,Opef08,Ope310 ;@ e310
  .long Opef18,Opef40,Opef48,Ope350,Opef58,Opef80,Opef88,Ope390 ;@ e390
  .long Opef98,Ope3d0,Ope3d8,Ope3df,Ope3e0,Ope3e7,Ope3e8,Ope3f0 ;@ e3f0
  .long Ope3f8,Ope3f9,Opee10,Opee50,Opee90,Ope4d0,Ope4d8,Ope4df ;@ e4df
  .long Ope4e0,Ope4e7,Ope4e8,Ope4f0,Ope4f8,Ope4f9,Opef10,Opef50 ;@ e550
  .long Opef90,Ope5d0,Ope5d8,Ope5df,Ope5e0,Ope5e7,Ope5e8,Ope5f0 ;@ e5f0
  .long Ope5f8,Ope5f9,Ope6d0,Ope6d8,Ope6df,Ope6e0,Ope6e7,Ope6e8 ;@ e6e8
  .long Ope6f0,Ope6f8,Ope6f9,Ope7d0,Ope7d8,Ope7df,Ope7e0,Ope7e7 ;@ e7e7
  .long Ope7e8,Ope7f0,Ope7f8,Ope7f9,000000,000000,000000,000000
  .rept 0x6ff
  .long 0,0,0,0,0,0,0,0
  .endr
  .hword 0x0038,0x0008,0x0048,0x0057,0x0061,0x0077,0x0081,0x0098
  .hword 0x00a8,0x00b1,0x00c1,0x0002,0x00d1,0x0003,0x00e8,0x0008
  .hword 0x00f8,0x0107,0x0111,0x0127,0x0131,0x0148,0x0158,0x0161
  .hword 0x0171,0x0002,0x0181,0x0003,0x0198,0x0008,0x01a8,0x01b7
  .hword 0x01c1,0x01d7,0x01e1,0x01f8,0x0208,0x0211,0x0221,0x0000
  .hword 0x0046,0x0238,0x0248,0x0258,0x0267,0x0271,0x0287,0x0291
  .hword 0x02a8,0x02b8,0x02c1,0x02d1,0x02e1,0x02f1,0x0301,0x0003
  .hword 0x0318,0x0328,0x0338,0x0347,0x0351,0x0367,0x0371,0x0388
  .hword 0x0398,0x03a1,0x03b1,0x0006,0x03c8,0x03d8,0x03e8,0x03f7
  .hword 0x0401,0x0417,0x0421,0x0438,0x0448,0x0451,0x0461,0x0006
  .hword 0x0478,0x0488,0x0498,0x04a7,0x04b1,0x04c7,0x04d1,0x04e8
  .hword 0x04f8,0x0501,0x0511,0x0006,0x0528,0x0008,0x0538,0x0547
  .hword 0x0551,0x0567,0x0571,0x0588,0x0598,0x05a1,0x05b1,0x0002
  .hword 0x05c1,0x0003,0x05d8,0x0008,0x05e8,0x05f7,0x0601,0x0617
  .hword 0x0621,0x0638,0x0648,0x0651,0x0661,0x0002,0x0671,0x0003
  .hword 0x0688,0x0008,0x0698,0x06a7,0x06b1,0x06c7,0x06d1,0x06e8
  .hword 0x06f8,0x0701,0x0711,0x0000,0x0046,0x0238,0x0248,0x0258
  .hword 0x0267,0x0271,0x0287,0x0291,0x02a8,0x02b8,0x02c1,0x02d1
  .hword 0x02e1,0x02f1,0x0301,0x0003,0x0318,0x0328,0x0338,0x0347
  .hword 0x0351,0x0367,0x0371,0x0388,0x0398,0x03a1,0x03b1,0x0006
  .hword 0x03c8,0x03d8,0x03e8,0x03f7,0x0401,0x0417,0x0421,0x0438
  .hword 0x0448,0x0451,0x0461,0x0006,0x0478,0x0488,0x0498,0x04a7
  .hword 0x04b1,0x04c7,0x04d1,0x04e8,0x04f8,0x0501,0x0511,0x0006
  .hword 0x0728,0x0008,0x0738,0x0747,0x0751,0x0767,0x0771,0x0788
  .hword 0x0798,0x07a1,0x07b1,0x0006,0x07c8,0x0008,0x07d8,0x07e7
  .hword 0x07f1,0x0807,0x0811,0x0828,0x0838,0x0841,0x0851,0x0006
  .hword 0x0868,0x0008,0x0878,0x0887,0x0891,0x08a7,0x08b1,0x08c8
  .hword 0x08d8,0x08e1,0x08f1,0x0000,0x0046,0x0238,0x0248,0x0258
  .hword 0x0267,0x0271,0x0287,0x0291,0x02a8,0x02b8,0x02c1,0x02d1
  .hword 0x02e1,0x02f1,0x0301,0x0003,0x0318,0x0328,0x0338,0x0347
  .hword 0x0351,0x0367,0x0371,0x0388,0x0398,0x03a1,0x03b1,0x0006
  .hword 0x03c8,0x03d8,0x03e8,0x03f7,0x0401,0x0417,0x0421,0x0438
  .hword 0x0448,0x0451,0x0461,0x0006,0x0478,0x0488,0x0498,0x04a7
  .hword 0x04b1,0x04c7,0x04d1,0x04e8,0x04f8,0x0501,0x0511,0x0006
  .hword 0x0908,0x0008,0x0918,0x0927,0x0931,0x0947,0x0951,0x0968
  .hword 0x0978,0x0981,0x0991,0x0006,0x09a8,0x0008,0x09b8,0x09c7
  .hword 0x09d1,0x09e7,0x09f1,0x0a08,0x0a18,0x0a21,0x0a31,0x0006
  .hword 0x0a48,0x0008,0x0a58,0x0a67,0x0a71,0x0a87,0x0a91,0x0aa8
  .hword 0x0ab8,0x0ac1,0x0ad1,0x0000,0x0046,0x0238,0x0248,0x0258
  .hword 0x0267,0x0271,0x0287,0x0291,0x02a8,0x02b8,0x02c1,0x02d1
  .hword 0x02e1,0x02f1,0x0301,0x0003,0x0318,0x0328,0x0338,0x0347
  .hword 0x0351,0x0367,0x0371,0x0388,0x0398,0x03a1,0x03b1,0x0006
  .hword 0x03c8,0x03d8,0x03e8,0x03f7,0x0401,0x0417,0x0421,0x0438
  .hword 0x0448,0x0451,0x0461,0x0006,0x0478,0x0488,0x0498,0x04a7
  .hword 0x04b1,0x04c7,0x04d1,0x04e8,0x04f8,0x0501,0x0511,0x0006
  .hword 0x0ae8,0x0008,0x0af8,0x0b07,0x0b11,0x0b27,0x0b31,0x0b48
  .hword 0x0b58,0x0b61,0x0b71,0x0b81,0x0b91,0x0004,0x0ba8,0x0008
  .hword 0x0bb8,0x0bc7,0x0bd1,0x0be7,0x0bf1,0x0c08,0x0c18,0x0c21
  .hword 0x0c31,0x0006,0x0c48,0x0008,0x0c58,0x0c67,0x0c71,0x0c87
  .hword 0x0c91,0x0ca8,0x0cb8,0x0cc1,0x0cd1,0x0006,0x0ce8,0x0008
  .hword 0x0cf8,0x0d07,0x0d11,0x0d27,0x0d31,0x0d48,0x0d58,0x0d61
  .hword 0x0d71,0x0006,0x0238,0x0248,0x0258,0x0267,0x0271,0x0287
  .hword 0x0291,0x02a8,0x02b8,0x02c1,0x02d1,0x02e1,0x02f1,0x0301
  .hword 0x0003,0x0318,0x0328,0x0338,0x0347,0x0351,0x0367,0x0371
  .hword 0x0388,0x0398,0x03a1,0x03b1,0x0006,0x03c8,0x03d8,0x03e8
  .hword 0x03f7,0x0401,0x0417,0x0421,0x0438,0x0448,0x0451,0x0461
  .hword 0x0006,0x0478,0x0488,0x0498,0x04a7,0x04b1,0x04c7,0x04d1
  .hword 0x04e8,0x04f8,0x0501,0x0511,0x0006,0x0d88,0x0008,0x0d98
  .hword 0x0da7,0x0db1,0x0dc7,0x0dd1,0x0de8,0x0df8,0x0e01,0x0e11
  .hword 0x0002,0x0e21,0x0003,0x0e38,0x0008,0x0e48,0x0e57,0x0e61
  .hword 0x0e77,0x0e81,0x0e98,0x0ea8,0x0eb1,0x0ec1,0x0002,0x0ed1
  .hword 0x0003,0x0ee8,0x0008,0x0ef8,0x0f07,0x0f11,0x0f27,0x0f31
  .hword 0x0f48,0x0f58,0x0f61,0x0f71,0x0000,0x0046,0x0238,0x0248
  .hword 0x0258,0x0267,0x0271,0x0287,0x0291,0x02a8,0x02b8,0x02c1
  .hword 0x02d1,0x02e1,0x02f1,0x0301,0x0003,0x0318,0x0328,0x0338
  .hword 0x0347,0x0351,0x0367,0x0371,0x0388,0x0398,0x03a1,0x03b1
  .hword 0x0006,0x03c8,0x03d8,0x03e8,0x03f7,0x0401,0x0417,0x0421
  .hword 0x0438,0x0448,0x0451,0x0461,0x0006,0x0478,0x0488,0x0498
  .hword 0x04a7,0x04b1,0x04c7,0x04d1,0x04e8,0x04f8,0x0501,0x0511
  .hword 0x0006,0x0f88,0x0008,0x0f98,0x0fa7,0x0fb1,0x0fc7,0x0fd1
  .hword 0x0fe8,0x0ff8,0x1001,0x1011,0x0006,0x1028,0x0008,0x1038
  .hword 0x1047,0x1051,0x1067,0x1071,0x1088,0x1098,0x10a1,0x10b1
  .hword 0x0006,0x10c8,0x0008,0x10d8,0x10e7,0x10f1,0x1107,0x1111
  .hword 0x1128,0x1138,0x1141,0x1151,0x0000,0x0046,0x0238,0x0248
  .hword 0x0258,0x0267,0x0271,0x0287,0x0291,0x02a8,0x02b8,0x02c1
  .hword 0x02d1,0x02e1,0x02f1,0x0301,0x0003,0x0318,0x0328,0x0338
  .hword 0x0347,0x0351,0x0367,0x0371,0x0388,0x0398,0x03a1,0x03b1
  .hword 0x0006,0x03c8,0x03d8,0x03e8,0x03f7,0x0401,0x0417,0x0421
  .hword 0x0438,0x0448,0x0451,0x0461,0x0006,0x0478,0x0488,0x0498
  .hword 0x04a7,0x04b1,0x04c7,0x04d1,0x04e8,0x04f8,0x0501,0x0511
  .hword 0x0000,0x0106,0x0238,0x0248,0x0258,0x0267,0x0271,0x0287
  .hword 0x0291,0x02a8,0x02b8,0x02c1,0x02d1,0x02e1,0x02f1,0x0301
  .hword 0x0003,0x0318,0x0328,0x0338,0x0347,0x0351,0x0367,0x0371
  .hword 0x0388,0x0398,0x03a1,0x03b1,0x0006,0x03c8,0x03d8,0x03e8
  .hword 0x03f7,0x0401,0x0417,0x0421,0x0438,0x0448,0x0451,0x0461
  .hword 0x0006,0x0478,0x0488,0x0498,0x04a7,0x04b1,0x04c7,0x04d1
  .hword 0x04e8,0x04f8,0x0501,0x0511,0x0006,0x1168,0x0008,0x1178
  .hword 0x1187,0x1191,0x11a7,0x11b1,0x11c8,0x11d8,0x11e1,0x11f1
  .hword 0x1201,0x1211,0x1221,0x0000,0x0043,0x1238,0x0008,0x1248
  .hword 0x1257,0x1261,0x1277,0x1281,0x1298,0x12a8,0x12b1,0x12c1
  .hword 0x12d1,0x12e1,0x12f1,0x0003,0x1308,0x0008,0x1318,0x1327
  .hword 0x1331,0x1347,0x1351,0x1368,0x1378,0x1381,0x1391,0x13a1
  .hword 0x13b1,0x13c1,0x0003,0x13d8,0x0008,0x13e8,0x13f7,0x1401
  .hword 0x1417,0x1421,0x1438,0x1448,0x1451,0x1461,0x1471,0x1481
  .hword 0x1491,0x0003,0x14a8,0x0008,0x14b8,0x14c7,0x14d1,0x14e7
  .hword 0x14f1,0x1508,0x1518,0x1521,0x1531,0x1541,0x1551,0x1561
  .hword 0x0003,0x1578,0x0008,0x1588,0x1597,0x15a1,0x15b7,0x15c1
  .hword 0x15d8,0x15e8,0x15f1,0x1601,0x1611,0x1621,0x1631,0x0003
  .hword 0x1648,0x0008,0x1658,0x1667,0x1671,0x1687,0x1691,0x16a8
  .hword 0x16b8,0x16c1,0x16d1,0x16e1,0x16f1,0x1701,0x0003,0x1168
  .hword 0x0008,0x1178,0x1187,0x1191,0x11a7,0x11b1,0x11c8,0x11d8
  .hword 0x11e1,0x11f1,0x1201,0x1211,0x1221,0x0000,0x0043,0x1238
  .hword 0x0008,0x1248,0x1257,0x1261,0x1277,0x1281,0x1298,0x12a8
  .hword 0x12b1,0x12c1,0x12d1,0x12e1,0x12f1,0x0003,0x1308,0x0008
  .hword 0x1318,0x1327,0x1331,0x1347,0x1351,0x1368,0x1378,0x1381
  .hword 0x1391,0x13a1,0x13b1,0x13c1,0x0003,0x13d8,0x0008,0x13e8
  .hword 0x13f7,0x1401,0x1417,0x1421,0x1438,0x1448,0x1451,0x1461
  .hword 0x1471,0x1481,0x1491,0x0003,0x14a8,0x0008,0x14b8,0x14c7
  .hword 0x14d1,0x14e7,0x14f1,0x1508,0x1518,0x1521,0x1531,0x1541
  .hword 0x1551,0x1561,0x0003,0x1578,0x0008,0x1588,0x1597,0x15a1
  .hword 0x15b7,0x15c1,0x15d8,0x15e8,0x15f1,0x1601,0x1611,0x1621
  .hword 0x1631,0x0003,0x1718,0x0008,0x1728,0x1737,0x1741,0x1757
  .hword 0x1761,0x1778,0x1788,0x1791,0x17a1,0x17b1,0x17c1,0x17d1
  .hword 0x0003,0x1168,0x0008,0x1178,0x1187,0x1191,0x11a7,0x11b1
  .hword 0x11c8,0x11d8,0x11e1,0x11f1,0x1201,0x1211,0x1221,0x0000
  .hword 0x0043,0x1238,0x0008,0x1248,0x1257,0x1261,0x1277,0x1281
  .hword 0x1298,0x12a8,0x12b1,0x12c1,0x12d1,0x12e1,0x12f1,0x0003
  .hword 0x1308,0x0008,0x1318,0x1327,0x1331,0x1347,0x1351,0x1368
  .hword 0x1378,0x1381,0x1391,0x13a1,0x13b1,0x13c1,0x0003,0x13d8
  .hword 0x0008,0x13e8,0x13f7,0x1401,0x1417,0x1421,0x1438,0x1448
  .hword 0x1451,0x1461,0x1471,0x1481,0x1491,0x0003,0x14a8,0x0008
  .hword 0x14b8,0x14c7,0x14d1,0x14e7,0x14f1,0x1508,0x1518,0x1521
  .hword 0x1531,0x1541,0x1551,0x1561,0x0003,0x1578,0x0008,0x1588
  .hword 0x1597,0x15a1,0x15b7,0x15c1,0x15d8,0x15e8,0x15f1,0x1601
  .hword 0x1611,0x1621,0x1631,0x0000,0x0043,0x1168,0x0008,0x1178
  .hword 0x1187,0x1191,0x11a7,0x11b1,0x11c8,0x11d8,0x11e1,0x11f1
  .hword 0x1201,0x1211,0x1221,0x0000,0x0043,0x1238,0x0008,0x1248
  .hword 0x1257,0x1261,0x1277,0x1281,0x1298,0x12a8,0x12b1,0x12c1
  .hword 0x12d1,0x12e1,0x12f1,0x0003,0x1308,0x0008,0x1318,0x1327
  .hword 0x1331,0x1347,0x1351,0x1368,0x1378,0x1381,0x1391,0x13a1
  .hword 0x13b1,0x13c1,0x0003,0x13d8,0x0008,0x13e8,0x13f7,0x1401
  .hword 0x1417,0x1421,0x1438,0x1448,0x1451,0x1461,0x1471,0x1481
  .hword 0x1491,0x0003,0x14a8,0x0008,0x14b8,0x14c7,0x14d1,0x14e7
  .hword 0x14f1,0x1508,0x1518,0x1521,0x1531,0x1541,0x1551,0x1561
  .hword 0x0003,0x1578,0x0008,0x1588,0x1597,0x15a1,0x15b7,0x15c1
  .hword 0x15d8,0x15e8,0x15f1,0x1601,0x1611,0x1621,0x1631,0x0000
  .hword 0x0043,0x1168,0x0008,0x1178,0x1187,0x1191,0x11a7,0x11b1
  .hword 0x11c8,0x11d8,0x11e1,0x11f1,0x1201,0x1211,0x1221,0x0000
  .hword 0x0043,0x1238,0x0008,0x1248,0x1257,0x1261,0x1277,0x1281
  .hword 0x1298,0x12a8,0x12b1,0x12c1,0x12d1,0x12e1,0x12f1,0x0003
  .hword 0x1308,0x0008,0x1318,0x1327,0x1331,0x1347,0x1351,0x1368
  .hword 0x1378,0x1381,0x1391,0x13a1,0x13b1,0x13c1,0x0003,0x13d8
  .hword 0x0008,0x13e8,0x13f7,0x1401,0x1417,0x1421,0x1438,0x1448
  .hword 0x1451,0x1461,0x1471,0x1481,0x1491,0x0003,0x14a8,0x0008
  .hword 0x14b8,0x14c7,0x14d1,0x14e7,0x14f1,0x1508,0x1518,0x1521
  .hword 0x1531,0x1541,0x1551,0x1561,0x0003,0x1578,0x0008,0x1588
  .hword 0x1597,0x15a1,0x15b7,0x15c1,0x15d8,0x15e8,0x15f1,0x1601
  .hword 0x1611,0x1621,0x1631,0x0000,0x0043,0x1168,0x0008,0x1178
  .hword 0x1187,0x1191,0x11a7,0x11b1,0x11c8,0x11d8,0x11e1,0x11f1
  .hword 0x1201,0x1211,0x1221,0x0000,0x0043,0x1238,0x0008,0x1248
  .hword 0x1257,0x1261,0x1277,0x1281,0x1298,0x12a8,0x12b1,0x12c1
  .hword 0x12d1,0x12e1,0x12f1,0x0003,0x1308,0x0008,0x1318,0x1327
  .hword 0x1331,0x1347,0x1351,0x1368,0x1378,0x1381,0x1391,0x13a1
  .hword 0x13b1,0x13c1,0x0003,0x13d8,0x0008,0x13e8,0x13f7,0x1401
  .hword 0x1417,0x1421,0x1438,0x1448,0x1451,0x1461,0x1471,0x1481
  .hword 0x1491,0x0003,0x14a8,0x0008,0x14b8,0x14c7,0x14d1,0x14e7
  .hword 0x14f1,0x1508,0x1518,0x1521,0x1531,0x1541,0x1551,0x1561
  .hword 0x0003,0x1578,0x0008,0x1588,0x1597,0x15a1,0x15b7,0x15c1
  .hword 0x15d8,0x15e8,0x15f1,0x1601,0x1611,0x1621,0x1631,0x0000
  .hword 0x0043,0x1168,0x0008,0x1178,0x1187,0x1191,0x11a7,0x11b1
  .hword 0x11c8,0x11d8,0x11e1,0x11f1,0x1201,0x1211,0x1221,0x0000
  .hword 0x0043,0x1238,0x0008,0x1248,0x1257,0x1261,0x1277,0x1281
  .hword 0x1298,0x12a8,0x12b1,0x12c1,0x12d1,0x12e1,0x12f1,0x0003
  .hword 0x1308,0x0008,0x1318,0x1327,0x1331,0x1347,0x1351,0x1368
  .hword 0x1378,0x1381,0x1391,0x13a1,0x13b1,0x13c1,0x0003,0x13d8
  .hword 0x0008,0x13e8,0x13f7,0x1401,0x1417,0x1421,0x1438,0x1448
  .hword 0x1451,0x1461,0x1471,0x1481,0x1491,0x0003,0x14a8,0x0008
  .hword 0x14b8,0x14c7,0x14d1,0x14e7,0x14f1,0x1508,0x1518,0x1521
  .hword 0x1531,0x1541,0x1551,0x1561,0x0003,0x1578,0x0008,0x1588
  .hword 0x1597,0x15a1,0x15b7,0x15c1,0x15d8,0x15e8,0x15f1,0x1601
  .hword 0x1611,0x1621,0x1631,0x0000,0x0043,0x1168,0x0008,0x1178
  .hword 0x1187,0x1191,0x11a7,0x11b1,0x11c8,0x11d8,0x11e1,0x11f1
  .hword 0x1201,0x1211,0x1221,0x0000,0x0043,0x1238,0x0008,0x1248
  .hword 0x1257,0x1261,0x1277,0x1281,0x1298,0x12a8,0x12b1,0x12c1
  .hword 0x12d1,0x12e1,0x12f1,0x0003,0x17e8,0x0008,0x17f8,0x1807
  .hword 0x1811,0x1827,0x1831,0x1848,0x1858,0x1861,0x1871,0x1881
  .hword 0x1891,0x18a1,0x0003,0x18b8,0x0008,0x18c8,0x18d7,0x18e1
  .hword 0x18f7,0x1901,0x1918,0x1928,0x1931,0x1941,0x1951,0x1961
  .hword 0x1971,0x0003,0x14a8,0x0008,0x14b8,0x14c7,0x14d1,0x14e7
  .hword 0x14f1,0x1508,0x1518,0x1521,0x1531,0x1541,0x1551,0x1561
  .hword 0x0003,0x1578,0x0008,0x1588,0x1597,0x15a1,0x15b7,0x15c1
  .hword 0x15d8,0x15e8,0x15f1,0x1601,0x1611,0x1621,0x1631,0x0000
  .hword 0x0043,0x198f,0x1998,0x19a7,0x19b1,0x19c7,0x19d1,0x19e8
  .hword 0x19f8,0x1a01,0x1a11,0x1a21,0x1a31,0x1a41,0x0003,0x1a5f
  .hword 0x1a68,0x1a77,0x1a81,0x1a97,0x1aa1,0x1ab8,0x1ac8,0x1ad1
  .hword 0x1ae1,0x1af1,0x1b01,0x1b11,0x0003,0x1b2f,0x1b38,0x1b47
  .hword 0x1b51,0x1b67,0x1b71,0x1b88,0x1b98,0x1ba1,0x1bb1,0x1bc1
  .hword 0x1bd1,0x1be1,0x0003,0x1bff,0x1c08,0x1c17,0x1c21,0x1c37
  .hword 0x1c41,0x1c58,0x1c68,0x1c71,0x1c81,0x1c91,0x1ca1,0x1cb1
  .hword 0x0003,0x1ccf,0x1cd8,0x1ce7,0x1cf1,0x1d07,0x1d11,0x1d28
  .hword 0x1d38,0x1d41,0x1d51,0x1d61,0x1d71,0x1d81,0x0003,0x1d9f
  .hword 0x1da8,0x1db7,0x1dc1,0x1dd7,0x1de1,0x1df8,0x1e08,0x1e11
  .hword 0x1e21,0x1e31,0x1e41,0x1e51,0x0003,0x1e6f,0x1e78,0x1e87
  .hword 0x1e91,0x1ea7,0x1eb1,0x1ec8,0x1ed8,0x1ee1,0x1ef1,0x1f01
  .hword 0x1f11,0x1f21,0x0003,0x1f3f,0x1f48,0x1f57,0x1f61,0x1f77
  .hword 0x1f81,0x1f98,0x1fa8,0x1fb1,0x1fc1,0x1fd1,0x1fe1,0x1ff1
  .hword 0x0003,0x198f,0x1998,0x19a7,0x19b1,0x19c7,0x19d1,0x19e8
  .hword 0x19f8,0x1a01,0x1a11,0x1a21,0x1a31,0x1a41,0x0003,0x1a5f
  .hword 0x1a68,0x1a77,0x1a81,0x1a97,0x1aa1,0x1ab8,0x1ac8,0x1ad1
  .hword 0x1ae1,0x1af1,0x1b01,0x1b11,0x0003,0x1b2f,0x1b38,0x1b47
  .hword 0x1b51,0x1b67,0x1b71,0x1b88,0x1b98,0x1ba1,0x1bb1,0x1bc1
  .hword 0x1bd1,0x1be1,0x0003,0x1bff,0x1c08,0x1c17,0x1c21,0x1c37
  .hword 0x1c41,0x1c58,0x1c68,0x1c71,0x1c81,0x1c91,0x1ca1,0x1cb1
  .hword 0x0003,0x1ccf,0x1cd8,0x1ce7,0x1cf1,0x1d07,0x1d11,0x1d28
  .hword 0x1d38,0x1d41,0x1d51,0x1d61,0x1d71,0x1d81,0x0003,0x1d9f
  .hword 0x1da8,0x1db7,0x1dc1,0x1dd7,0x1de1,0x1df8,0x1e08,0x1e11
  .hword 0x1e21,0x1e31,0x1e41,0x1e51,0x0003,0x1e6f,0x1e78,0x1e87
  .hword 0x1e91,0x1ea7,0x1eb1,0x1ec8,0x1ed8,0x1ee1,0x1ef1,0x1f01
  .hword 0x1f11,0x1f21,0x0003,0x200f,0x2018,0x2027,0x2031,0x2047
  .hword 0x2051,0x2068,0x2078,0x2081,0x2091,0x20a1,0x20b1,0x20c1
  .hword 0x0003,0x198f,0x1998,0x19a7,0x19b1,0x19c7,0x19d1,0x19e8
  .hword 0x19f8,0x1a01,0x1a11,0x1a21,0x1a31,0x1a41,0x0003,0x1a5f
  .hword 0x1a68,0x1a77,0x1a81,0x1a97,0x1aa1,0x1ab8,0x1ac8,0x1ad1
  .hword 0x1ae1,0x1af1,0x1b01,0x1b11,0x0003,0x1b2f,0x1b38,0x1b47
  .hword 0x1b51,0x1b67,0x1b71,0x1b88,0x1b98,0x1ba1,0x1bb1,0x1bc1
  .hword 0x1bd1,0x1be1,0x0003,0x1bff,0x1c08,0x1c17,0x1c21,0x1c37
  .hword 0x1c41,0x1c58,0x1c68,0x1c71,0x1c81,0x1c91,0x1ca1,0x1cb1
  .hword 0x0003,0x1ccf,0x1cd8,0x1ce7,0x1cf1,0x1d07,0x1d11,0x1d28
  .hword 0x1d38,0x1d41,0x1d51,0x1d61,0x1d71,0x1d81,0x0003,0x1d9f
  .hword 0x1da8,0x1db7,0x1dc1,0x1dd7,0x1de1,0x1df8,0x1e08,0x1e11
  .hword 0x1e21,0x1e31,0x1e41,0x1e51,0x0003,0x1e6f,0x1e78,0x1e87
  .hword 0x1e91,0x1ea7,0x1eb1,0x1ec8,0x1ed8,0x1ee1,0x1ef1,0x1f01
  .hword 0x1f11,0x1f21,0x0000,0x0043,0x198f,0x1998,0x19a7,0x19b1
  .hword 0x19c7,0x19d1,0x19e8,0x19f8,0x1a01,0x1a11,0x1a21,0x1a31
  .hword 0x1a41,0x0003,0x1a5f,0x1a68,0x1a77,0x1a81,0x1a97,0x1aa1
  .hword 0x1ab8,0x1ac8,0x1ad1,0x1ae1,0x1af1,0x1b01,0x1b11,0x0003
  .hword 0x1b2f,0x1b38,0x1b47,0x1b51,0x1b67,0x1b71,0x1b88,0x1b98
  .hword 0x1ba1,0x1bb1,0x1bc1,0x1bd1,0x1be1,0x0003,0x1bff,0x1c08
  .hword 0x1c17,0x1c21,0x1c37,0x1c41,0x1c58,0x1c68,0x1c71,0x1c81
  .hword 0x1c91,0x1ca1,0x1cb1,0x0003,0x1ccf,0x1cd8,0x1ce7,0x1cf1
  .hword 0x1d07,0x1d11,0x1d28,0x1d38,0x1d41,0x1d51,0x1d61,0x1d71
  .hword 0x1d81,0x0003,0x1d9f,0x1da8,0x1db7,0x1dc1,0x1dd7,0x1de1
  .hword 0x1df8,0x1e08,0x1e11,0x1e21,0x1e31,0x1e41,0x1e51,0x0003
  .hword 0x1e6f,0x1e78,0x1e87,0x1e91,0x1ea7,0x1eb1,0x1ec8,0x1ed8
  .hword 0x1ee1,0x1ef1,0x1f01,0x1f11,0x1f21,0x0000,0x0043,0x198f
  .hword 0x1998,0x19a7,0x19b1,0x19c7,0x19d1,0x19e8,0x19f8,0x1a01
  .hword 0x1a11,0x1a21,0x1a31,0x1a41,0x0003,0x1a5f,0x1a68,0x1a77
  .hword 0x1a81,0x1a97,0x1aa1,0x1ab8,0x1ac8,0x1ad1,0x1ae1,0x1af1
  .hword 0x1b01,0x1b11,0x0003,0x1b2f,0x1b38,0x1b47,0x1b51,0x1b67
  .hword 0x1b71,0x1b88,0x1b98,0x1ba1,0x1bb1,0x1bc1,0x1bd1,0x1be1
  .hword 0x0003,0x1bff,0x1c08,0x1c17,0x1c21,0x1c37,0x1c41,0x1c58
  .hword 0x1c68,0x1c71,0x1c81,0x1c91,0x1ca1,0x1cb1,0x0003,0x1ccf
  .hword 0x1cd8,0x1ce7,0x1cf1,0x1d07,0x1d11,0x1d28,0x1d38,0x1d41
  .hword 0x1d51,0x1d61,0x1d71,0x1d81,0x0003,0x1d9f,0x1da8,0x1db7
  .hword 0x1dc1,0x1dd7,0x1de1,0x1df8,0x1e08,0x1e11,0x1e21,0x1e31
  .hword 0x1e41,0x1e51,0x0003,0x1e6f,0x1e78,0x1e87,0x1e91,0x1ea7
  .hword 0x1eb1,0x1ec8,0x1ed8,0x1ee1,0x1ef1,0x1f01,0x1f11,0x1f21
  .hword 0x0000,0x0043,0x198f,0x1998,0x19a7,0x19b1,0x19c7,0x19d1
  .hword 0x19e8,0x19f8,0x1a01,0x1a11,0x1a21,0x1a31,0x1a41,0x0003
  .hword 0x1a5f,0x1a68,0x1a77,0x1a81,0x1a97,0x1aa1,0x1ab8,0x1ac8
  .hword 0x1ad1,0x1ae1,0x1af1,0x1b01,0x1b11,0x0003,0x1b2f,0x1b38
  .hword 0x1b47,0x1b51,0x1b67,0x1b71,0x1b88,0x1b98,0x1ba1,0x1bb1
  .hword 0x1bc1,0x1bd1,0x1be1,0x0003,0x1bff,0x1c08,0x1c17,0x1c21
  .hword 0x1c37,0x1c41,0x1c58,0x1c68,0x1c71,0x1c81,0x1c91,0x1ca1
  .hword 0x1cb1,0x0003,0x1ccf,0x1cd8,0x1ce7,0x1cf1,0x1d07,0x1d11
  .hword 0x1d28,0x1d38,0x1d41,0x1d51,0x1d61,0x1d71,0x1d81,0x0003
  .hword 0x1d9f,0x1da8,0x1db7,0x1dc1,0x1dd7,0x1de1,0x1df8,0x1e08
  .hword 0x1e11,0x1e21,0x1e31,0x1e41,0x1e51,0x0003,0x1e6f,0x1e78
  .hword 0x1e87,0x1e91,0x1ea7,0x1eb1,0x1ec8,0x1ed8,0x1ee1,0x1ef1
  .hword 0x1f01,0x1f11,0x1f21,0x0000,0x0043,0x198f,0x1998,0x19a7
  .hword 0x19b1,0x19c7,0x19d1,0x19e8,0x19f8,0x1a01,0x1a11,0x1a21
  .hword 0x1a31,0x1a41,0x0003,0x1a5f,0x1a68,0x1a77,0x1a81,0x1a97
  .hword 0x1aa1,0x1ab8,0x1ac8,0x1ad1,0x1ae1,0x1af1,0x1b01,0x1b11
  .hword 0x0003,0x1b2f,0x1b38,0x1b47,0x1b51,0x1b67,0x1b71,0x1b88
  .hword 0x1b98,0x1ba1,0x1bb1,0x1bc1,0x1bd1,0x1be1,0x0003,0x1bff
  .hword 0x1c08,0x1c17,0x1c21,0x1c37,0x1c41,0x1c58,0x1c68,0x1c71
  .hword 0x1c81,0x1c91,0x1ca1,0x1cb1,0x0003,0x1ccf,0x1cd8,0x1ce7
  .hword 0x1cf1,0x1d07,0x1d11,0x1d28,0x1d38,0x1d41,0x1d51,0x1d61
  .hword 0x1d71,0x1d81,0x0003,0x1d9f,0x1da8,0x1db7,0x1dc1,0x1dd7
  .hword 0x1de1,0x1df8,0x1e08,0x1e11,0x1e21,0x1e31,0x1e41,0x1e51
  .hword 0x0003,0x1e6f,0x1e78,0x1e87,0x1e91,0x1ea7,0x1eb1,0x1ec8
  .hword 0x1ed8,0x1ee1,0x1ef1,0x1f01,0x1f11,0x1f21,0x0000,0x0043
  .hword 0x198f,0x1998,0x19a7,0x19b1,0x19c7,0x19d1,0x19e8,0x19f8
  .hword 0x1a01,0x1a11,0x1a21,0x1a31,0x1a41,0x0003,0x1a5f,0x1a68
  .hword 0x1a77,0x1a81,0x1a97,0x1aa1,0x1ab8,0x1ac8,0x1ad1,0x1ae1
  .hword 0x1af1,0x1b01,0x1b11,0x0003,0x1b2f,0x1b38,0x1b47,0x1b51
  .hword 0x1b67,0x1b71,0x1b88,0x1b98,0x1ba1,0x1bb1,0x1bc1,0x1bd1
  .hword 0x1be1,0x0003,0x20df,0x20e8,0x20f7,0x2101,0x2117,0x2121
  .hword 0x2138,0x2148,0x2151,0x2161,0x2171,0x2181,0x2191,0x0003
  .hword 0x21af,0x21b8,0x21c7,0x21d1,0x21e7,0x21f1,0x2208,0x2218
  .hword 0x2221,0x2231,0x2241,0x2251,0x2261,0x0003,0x1d9f,0x1da8
  .hword 0x1db7,0x1dc1,0x1dd7,0x1de1,0x1df8,0x1e08,0x1e11,0x1e21
  .hword 0x1e31,0x1e41,0x1e51,0x0003,0x1e6f,0x1e78,0x1e87,0x1e91
  .hword 0x1ea7,0x1eb1,0x1ec8,0x1ed8,0x1ee1,0x1ef1,0x1f01,0x1f11
  .hword 0x1f21,0x0000,0x0043,0x227f,0x2288,0x2297,0x22a1,0x22b7
  .hword 0x22c1,0x22d8,0x22e8,0x22f1,0x2301,0x2311,0x2321,0x2331
  .hword 0x0003,0x234f,0x2358,0x2367,0x2371,0x2387,0x2391,0x23a8
  .hword 0x23b8,0x23c1,0x23d1,0x23e1,0x23f1,0x2401,0x0003,0x241f
  .hword 0x2428,0x2437,0x2441,0x2457,0x2461,0x2478,0x2488,0x2491
  .hword 0x24a1,0x24b1,0x24c1,0x24d1,0x0003,0x24ef,0x24f8,0x2507
  .hword 0x2511,0x2527,0x2531,0x2548,0x2558,0x2561,0x2571,0x2581
  .hword 0x2591,0x25a1,0x0003,0x25bf,0x25c8,0x25d7,0x25e1,0x25f7
  .hword 0x2601,0x2618,0x2628,0x2631,0x2641,0x2651,0x2661,0x2671
  .hword 0x0003,0x268f,0x2698,0x26a7,0x26b1,0x26c7,0x26d1,0x26e8
  .hword 0x26f8,0x2701,0x2711,0x2721,0x2731,0x2741,0x0003,0x275f
  .hword 0x2768,0x2777,0x2781,0x2797,0x27a1,0x27b8,0x27c8,0x27d1
  .hword 0x27e1,0x27f1,0x2801,0x2811,0x0003,0x282f,0x2838,0x2847
  .hword 0x2851,0x2867,0x2871,0x2888,0x2898,0x28a1,0x28b1,0x28c1
  .hword 0x28d1,0x28e1,0x0003,0x227f,0x2288,0x2297,0x22a1,0x22b7
  .hword 0x22c1,0x22d8,0x22e8,0x22f1,0x2301,0x2311,0x2321,0x2331
  .hword 0x0003,0x234f,0x2358,0x2367,0x2371,0x2387,0x2391,0x23a8
  .hword 0x23b8,0x23c1,0x23d1,0x23e1,0x23f1,0x2401,0x0003,0x241f
  .hword 0x2428,0x2437,0x2441,0x2457,0x2461,0x2478,0x2488,0x2491
  .hword 0x24a1,0x24b1,0x24c1,0x24d1,0x0003,0x24ef,0x24f8,0x2507
  .hword 0x2511,0x2527,0x2531,0x2548,0x2558,0x2561,0x2571,0x2581
  .hword 0x2591,0x25a1,0x0003,0x25bf,0x25c8,0x25d7,0x25e1,0x25f7
  .hword 0x2601,0x2618,0x2628,0x2631,0x2641,0x2651,0x2661,0x2671
  .hword 0x0003,0x268f,0x2698,0x26a7,0x26b1,0x26c7,0x26d1,0x26e8
  .hword 0x26f8,0x2701,0x2711,0x2721,0x2731,0x2741,0x0003,0x275f
  .hword 0x2768,0x2777,0x2781,0x2797,0x27a1,0x27b8,0x27c8,0x27d1
  .hword 0x27e1,0x27f1,0x2801,0x2811,0x0003,0x28ff,0x2908,0x2917
  .hword 0x2921,0x2937,0x2941,0x2958,0x2968,0x2971,0x2981,0x2991
  .hword 0x29a1,0x29b1,0x0003,0x227f,0x2288,0x2297,0x22a1,0x22b7
  .hword 0x22c1,0x22d8,0x22e8,0x22f1,0x2301,0x2311,0x2321,0x2331
  .hword 0x0003,0x234f,0x2358,0x2367,0x2371,0x2387,0x2391,0x23a8
  .hword 0x23b8,0x23c1,0x23d1,0x23e1,0x23f1,0x2401,0x0003,0x241f
  .hword 0x2428,0x2437,0x2441,0x2457,0x2461,0x2478,0x2488,0x2491
  .hword 0x24a1,0x24b1,0x24c1,0x24d1,0x0003,0x24ef,0x24f8,0x2507
  .hword 0x2511,0x2527,0x2531,0x2548,0x2558,0x2561,0x2571,0x2581
  .hword 0x2591,0x25a1,0x0003,0x25bf,0x25c8,0x25d7,0x25e1,0x25f7
  .hword 0x2601,0x2618,0x2628,0x2631,0x2641,0x2651,0x2661,0x2671
  .hword 0x0003,0x268f,0x2698,0x26a7,0x26b1,0x26c7,0x26d1,0x26e8
  .hword 0x26f8,0x2701,0x2711,0x2721,0x2731,0x2741,0x0003,0x275f
  .hword 0x2768,0x2777,0x2781,0x2797,0x27a1,0x27b8,0x27c8,0x27d1
  .hword 0x27e1,0x27f1,0x2801,0x2811,0x0000,0x0043,0x227f,0x2288
  .hword 0x2297,0x22a1,0x22b7,0x22c1,0x22d8,0x22e8,0x22f1,0x2301
  .hword 0x2311,0x2321,0x2331,0x0003,0x234f,0x2358,0x2367,0x2371
  .hword 0x2387,0x2391,0x23a8,0x23b8,0x23c1,0x23d1,0x23e1,0x23f1
  .hword 0x2401,0x0003,0x241f,0x2428,0x2437,0x2441,0x2457,0x2461
  .hword 0x2478,0x2488,0x2491,0x24a1,0x24b1,0x24c1,0x24d1,0x0003
  .hword 0x24ef,0x24f8,0x2507,0x2511,0x2527,0x2531,0x2548,0x2558
  .hword 0x2561,0x2571,0x2581,0x2591,0x25a1,0x0003,0x25bf,0x25c8
  .hword 0x25d7,0x25e1,0x25f7,0x2601,0x2618,0x2628,0x2631,0x2641
  .hword 0x2651,0x2661,0x2671,0x0003,0x268f,0x2698,0x26a7,0x26b1
  .hword 0x26c7,0x26d1,0x26e8,0x26f8,0x2701,0x2711,0x2721,0x2731
  .hword 0x2741,0x0003,0x275f,0x2768,0x2777,0x2781,0x2797,0x27a1
  .hword 0x27b8,0x27c8,0x27d1,0x27e1,0x27f1,0x2801,0x2811,0x0000
  .hword 0x0043,0x227f,0x2288,0x2297,0x22a1,0x22b7,0x22c1,0x22d8
  .hword 0x22e8,0x22f1,0x2301,0x2311,0x2321,0x2331,0x0003,0x234f
  .hword 0x2358,0x2367,0x2371,0x2387,0x2391,0x23a8,0x23b8,0x23c1
  .hword 0x23d1,0x23e1,0x23f1,0x2401,0x0003,0x241f,0x2428,0x2437
  .hword 0x2441,0x2457,0x2461,0x2478,0x2488,0x2491,0x24a1,0x24b1
  .hword 0x24c1,0x24d1,0x0003,0x24ef,0x24f8,0x2507,0x2511,0x2527
  .hword 0x2531,0x2548,0x2558,0x2561,0x2571,0x2581,0x2591,0x25a1
  .hword 0x0003,0x25bf,0x25c8,0x25d7,0x25e1,0x25f7,0x2601,0x2618
  .hword 0x2628,0x2631,0x2641,0x2651,0x2661,0x2671,0x0003,0x268f
  .hword 0x2698,0x26a7,0x26b1,0x26c7,0x26d1,0x26e8,0x26f8,0x2701
  .hword 0x2711,0x2721,0x2731,0x2741,0x0003,0x275f,0x2768,0x2777
  .hword 0x2781,0x2797,0x27a1,0x27b8,0x27c8,0x27d1,0x27e1,0x27f1
  .hword 0x2801,0x2811,0x0000,0x0043,0x227f,0x2288,0x2297,0x22a1
  .hword 0x22b7,0x22c1,0x22d8,0x22e8,0x22f1,0x2301,0x2311,0x2321
  .hword 0x2331,0x0003,0x234f,0x2358,0x2367,0x2371,0x2387,0x2391
  .hword 0x23a8,0x23b8,0x23c1,0x23d1,0x23e1,0x23f1,0x2401,0x0003
  .hword 0x241f,0x2428,0x2437,0x2441,0x2457,0x2461,0x2478,0x2488
  .hword 0x2491,0x24a1,0x24b1,0x24c1,0x24d1,0x0003,0x24ef,0x24f8
  .hword 0x2507,0x2511,0x2527,0x2531,0x2548,0x2558,0x2561,0x2571
  .hword 0x2581,0x2591,0x25a1,0x0003,0x25bf,0x25c8,0x25d7,0x25e1
  .hword 0x25f7,0x2601,0x2618,0x2628,0x2631,0x2641,0x2651,0x2661
  .hword 0x2671,0x0003,0x268f,0x2698,0x26a7,0x26b1,0x26c7,0x26d1
  .hword 0x26e8,0x26f8,0x2701,0x2711,0x2721,0x2731,0x2741,0x0003
  .hword 0x275f,0x2768,0x2777,0x2781,0x2797,0x27a1,0x27b8,0x27c8
  .hword 0x27d1,0x27e1,0x27f1,0x2801,0x2811,0x0000,0x0043,0x227f
  .hword 0x2288,0x2297,0x22a1,0x22b7,0x22c1,0x22d8,0x22e8,0x22f1
  .hword 0x2301,0x2311,0x2321,0x2331,0x0003,0x234f,0x2358,0x2367
  .hword 0x2371,0x2387,0x2391,0x23a8,0x23b8,0x23c1,0x23d1,0x23e1
  .hword 0x23f1,0x2401,0x0003,0x241f,0x2428,0x2437,0x2441,0x2457
  .hword 0x2461,0x2478,0x2488,0x2491,0x24a1,0x24b1,0x24c1,0x24d1
  .hword 0x0003,0x24ef,0x24f8,0x2507,0x2511,0x2527,0x2531,0x2548
  .hword 0x2558,0x2561,0x2571,0x2581,0x2591,0x25a1,0x0003,0x25bf
  .hword 0x25c8,0x25d7,0x25e1,0x25f7,0x2601,0x2618,0x2628,0x2631
  .hword 0x2641,0x2651,0x2661,0x2671,0x0003,0x268f,0x2698,0x26a7
  .hword 0x26b1,0x26c7,0x26d1,0x26e8,0x26f8,0x2701,0x2711,0x2721
  .hword 0x2731,0x2741,0x0003,0x275f,0x2768,0x2777,0x2781,0x2797
  .hword 0x27a1,0x27b8,0x27c8,0x27d1,0x27e1,0x27f1,0x2801,0x2811
  .hword 0x0000,0x0043,0x227f,0x2288,0x2297,0x22a1,0x22b7,0x22c1
  .hword 0x22d8,0x22e8,0x22f1,0x2301,0x2311,0x2321,0x2331,0x0003
  .hword 0x234f,0x2358,0x2367,0x2371,0x2387,0x2391,0x23a8,0x23b8
  .hword 0x23c1,0x23d1,0x23e1,0x23f1,0x2401,0x0003,0x241f,0x2428
  .hword 0x2437,0x2441,0x2457,0x2461,0x2478,0x2488,0x2491,0x24a1
  .hword 0x24b1,0x24c1,0x24d1,0x0003,0x29cf,0x29d8,0x29e7,0x29f1
  .hword 0x2a07,0x2a11,0x2a28,0x2a38,0x2a41,0x2a51,0x2a61,0x2a71
  .hword 0x2a81,0x0003,0x2a9f,0x2aa8,0x2ab7,0x2ac1,0x2ad7,0x2ae1
  .hword 0x2af8,0x2b08,0x2b11,0x2b21,0x2b31,0x2b41,0x2b51,0x0003
  .hword 0x268f,0x2698,0x26a7,0x26b1,0x26c7,0x26d1,0x26e8,0x26f8
  .hword 0x2701,0x2711,0x2721,0x2731,0x2741,0x0003,0x275f,0x2768
  .hword 0x2777,0x2781,0x2797,0x27a1,0x27b8,0x27c8,0x27d1,0x27e1
  .hword 0x27f1,0x2801,0x2811,0x0000,0x0043,0x2b68,0x0008,0x2b78
  .hword 0x2b87,0x2b91,0x2ba7,0x2bb1,0x2bc8,0x2bd8,0x2be1,0x2bf1
  .hword 0x0006,0x2c08,0x0008,0x2c18,0x2c27,0x2c31,0x2c47,0x2c51
  .hword 0x2c68,0x2c78,0x2c81,0x2c91,0x0006,0x2ca8,0x0008,0x2cb8
  .hword 0x2cc7,0x2cd1,0x2ce7,0x2cf1,0x2d08,0x2d18,0x2d21,0x2d31
  .hword 0x0006,0x2d48,0x0008,0x2d58,0x2d67,0x2d71,0x2d87,0x2d91
  .hword 0x2da8,0x2db8,0x2dc1,0x2dd1,0x0000,0x0086,0x2de8,0x0008
  .hword 0x2df8,0x2e07,0x2e11,0x2e27,0x2e31,0x2e48,0x2e58,0x2e61
  .hword 0x2e71,0x2e81,0x2e91,0x2ea1,0x0000,0x0013,0x2eb8,0x000f
  .hword 0x2ec8,0x2ed8,0x2ee1,0x2ef1,0x2f01,0x2f11,0x0004,0x2f28
  .hword 0x0008,0x2f38,0x2f47,0x2f51,0x2f67,0x2f71,0x2f88,0x2f98
  .hword 0x2fa1,0x2fb1,0x0006,0x2fc8,0x0008,0x2fd8,0x2fe7,0x2ff1
  .hword 0x3007,0x3011,0x3028,0x3038,0x3041,0x3051,0x0006,0x3068
  .hword 0x0008,0x3078,0x3087,0x3091,0x30a7,0x30b1,0x30c8,0x30d8
  .hword 0x30e1,0x30f1,0x0000,0x00c6,0x2de8,0x0008,0x2df8,0x2e07
  .hword 0x2e11,0x2e27,0x2e31,0x2e48,0x2e58,0x2e61,0x2e71,0x2e81
  .hword 0x2e91,0x2ea1,0x0000,0x0013,0x2eb8,0x000f,0x2ec8,0x2ed8
  .hword 0x2ee1,0x2ef1,0x2f01,0x2f11,0x0004,0x3108,0x0008,0x3118
  .hword 0x3127,0x3131,0x3147,0x3151,0x3168,0x3178,0x3181,0x3191
  .hword 0x0006,0x31a8,0x0008,0x31b8,0x31c7,0x31d1,0x31e7,0x31f1
  .hword 0x3208,0x3218,0x3221,0x3231,0x0006,0x3248,0x0008,0x3258
  .hword 0x3267,0x3271,0x3287,0x3291,0x32a8,0x32b8,0x32c1,0x32d1
  .hword 0x0006,0x32e8,0x0008,0x32f8,0x3307,0x3311,0x3327,0x3331
  .hword 0x3348,0x3358,0x3361,0x3371,0x3381,0x3391,0x33a1,0x0000
  .hword 0x0083,0x2de8,0x0008,0x2df8,0x2e07,0x2e11,0x2e27,0x2e31
  .hword 0x2e48,0x2e58,0x2e61,0x2e71,0x2e81,0x2e91,0x2ea1,0x0000
  .hword 0x0013,0x2eb8,0x000f,0x2ec8,0x2ed8,0x2ee1,0x2ef1,0x2f01
  .hword 0x2f11,0x0004,0x33b8,0x0008,0x33c8,0x33d7,0x33e1,0x33f7
  .hword 0x3401,0x3418,0x3428,0x3431,0x3441,0x0006,0x3458,0x0008
  .hword 0x3468,0x3477,0x3481,0x3497,0x34a1,0x34b8,0x34c8,0x34d1
  .hword 0x34e1,0x0006,0x34f8,0x0008,0x3508,0x3517,0x3521,0x3537
  .hword 0x3541,0x3558,0x3568,0x3571,0x3581,0x0006,0x3598,0x0008
  .hword 0x35a8,0x35b7,0x35c1,0x35d7,0x35e1,0x35f8,0x3608,0x3611
  .hword 0x3621,0x3631,0x3641,0x3651,0x0000,0x0083,0x2de8,0x0008
  .hword 0x2df8,0x2e07,0x2e11,0x2e27,0x2e31,0x2e48,0x2e58,0x2e61
  .hword 0x2e71,0x2e81,0x2e91,0x2ea1,0x0000,0x0013,0x2eb8,0x000f
  .hword 0x2ec8,0x2ed8,0x2ee1,0x2ef1,0x2f01,0x2f11,0x0004,0x3668
  .hword 0x0008,0x3678,0x3687,0x3691,0x36a7,0x36b1,0x36c8,0x36d8
  .hword 0x36e1,0x36f1,0x0006,0x3708,0x0008,0x3718,0x000f,0x3728
  .hword 0x3738,0x3741,0x3751,0x3761,0x3771,0x0004,0x3788,0x0008
  .hword 0x3798,0x0008,0x37a7,0x37b1,0x37c8,0x37d8,0x37e1,0x37f1
  .hword 0x0006,0x3808,0x0008,0x3818,0x0008,0x3827,0x3831,0x3848
  .hword 0x3858,0x3861,0x3871,0x0000,0x0086,0x2de8,0x0008,0x2df8
  .hword 0x2e07,0x2e11,0x2e27,0x2e31,0x2e48,0x2e58,0x2e61,0x2e71
  .hword 0x2e81,0x2e91,0x2ea1,0x0000,0x0013,0x2eb8,0x000f,0x2ec8
  .hword 0x2ed8,0x2ee1,0x2ef1,0x2f01,0x2f11,0x0004,0x3888,0x0008
  .hword 0x3898,0x38a7,0x38b1,0x38c7,0x38d1,0x38e8,0x38f8,0x3901
  .hword 0x3911,0x0006,0x3928,0x0008,0x3938,0x3947,0x3951,0x3967
  .hword 0x3971,0x3988,0x3998,0x39a1,0x39b1,0x0006,0x39c8,0x0008
  .hword 0x39d8,0x39e7,0x39f1,0x3a07,0x3a11,0x3a28,0x3a38,0x3a41
  .hword 0x3a51,0x0006,0x3a68,0x0008,0x3a78,0x3a87,0x3a91,0x3aa7
  .hword 0x3ab1,0x3ac8,0x3ad8,0x3ae1,0x3af1,0x0000,0x0086,0x2de8
  .hword 0x0008,0x2df8,0x2e07,0x2e11,0x2e27,0x2e31,0x2e48,0x2e58
  .hword 0x2e61,0x2e71,0x2e81,0x2e91,0x2ea1,0x0000,0x0013,0x2eb8
  .hword 0x000f,0x2ec8,0x2ed8,0x2ee1,0x2ef1,0x2f01,0x2f11,0x0000
  .hword 0x0094,0x3b08,0x3b17,0x3b21,0x0008,0x3b38,0x3b48,0x3b51
  .hword 0x3b61,0x3b71,0x3b81,0x0000,0x0014,0x3b98,0x3ba7,0x3bb1
  .hword 0x0008,0x3bc8,0x3bd8,0x3be1,0x3bf1,0x3c01,0x3c11,0x0000
  .hword 0x0084,0x2de8,0x0008,0x2df8,0x2e07,0x2e11,0x2e27,0x2e31
  .hword 0x2e48,0x2e58,0x2e61,0x2e71,0x2e81,0x2e91,0x2ea1,0x0000
  .hword 0x0013,0x2eb8,0x000f,0x2ec8,0x2ed8,0x2ee1,0x2ef1,0x2f01
  .hword 0x2f11,0x0000,0x0044,0x3c2f,0x3c37,0x3c41,0x3c58,0x3c68
  .hword 0x3c78,0x3c81,0x3c91,0x3ca1,0x3cb1,0x0001,0x3cc1,0x3cd1
  .hword 0x3ce1,0x0000,0x0018,0x3cf8,0x000f,0x3d08,0x3d18,0x3d21
  .hword 0x3d31,0x3d41,0x3d51,0x0000,0x0014,0x3d68,0x000f,0x3d78
  .hword 0x3d88,0x3d91,0x3da1,0x3db1,0x3dc1,0x0000,0x0084,0x2de8
  .hword 0x0008,0x2df8,0x2e07,0x2e11,0x2e27,0x2e31,0x2e48,0x2e58
  .hword 0x2e61,0x2e71,0x2e81,0x2e91,0x2ea1,0x0000,0x0013,0x2eb8
  .hword 0x000f,0x2ec8,0x2ed8,0x2ee1,0x2ef1,0x2f01,0x2f11,0x0004
  .hword 0x3dd8,0x0008,0x3de8,0x3df7,0x3e01,0x3e17,0x3e21,0x3e38
  .hword 0x3e48,0x3e51,0x3e61,0x0006,0x3e78,0x3e88,0x3e98,0x3ea7
  .hword 0x3eb1,0x3ec7,0x3ed1,0x3ee8,0x3ef8,0x3f01,0x3f11,0x0006
  .hword 0x3f28,0x3f38,0x3f48,0x3f57,0x3f61,0x3f77,0x3f81,0x3f98
  .hword 0x3fa8,0x3fb1,0x3fc1,0x0006,0x3fd8,0x3fe8,0x3ff8,0x4007
  .hword 0x4011,0x4027,0x4031,0x4048,0x4058,0x4061,0x4071,0x0006
  .hword 0x4088,0x0008,0x4098,0x40a7,0x40b1,0x40c7,0x40d1,0x40e8
  .hword 0x40f8,0x4101,0x4111,0x0006,0x4128,0x4138,0x4148,0x4157
  .hword 0x4161,0x4177,0x4181,0x4198,0x41a8,0x41b1,0x41c1,0x0006
  .hword 0x41d8,0x41e8,0x41f8,0x4207,0x4211,0x4227,0x4231,0x4248
  .hword 0x4258,0x4261,0x4271,0x0006,0x4288,0x4298,0x42a8,0x42b7
  .hword 0x42c1,0x42d7,0x42e1,0x42f8,0x4308,0x4311,0x4321,0x0006
  .hword 0x4338,0x0008,0x4348,0x4357,0x4361,0x4377,0x4381,0x4398
  .hword 0x43a8,0x43b1,0x43c1,0x0006,0x43d8,0x43e8,0x43f8,0x4407
  .hword 0x4411,0x4427,0x4431,0x4448,0x4458,0x4461,0x4471,0x0006
  .hword 0x4488,0x4498,0x44a8,0x44b7,0x44c1,0x44d7,0x44e1,0x44f8
  .hword 0x4508,0x4511,0x4521,0x0006,0x4538,0x4548,0x4558,0x4567
  .hword 0x4571,0x4587,0x4591,0x45a8,0x45b8,0x45c1,0x45d1,0x0006
  .hword 0x45e8,0x0008,0x45f8,0x4607,0x4611,0x4627,0x4631,0x4648
  .hword 0x4658,0x4661,0x4671,0x0006,0x4688,0x4698,0x46a8,0x46b7
  .hword 0x46c1,0x46d7,0x46e1,0x46f8,0x4708,0x4711,0x4721,0x0006
  .hword 0x4738,0x4748,0x4758,0x4767,0x4771,0x4787,0x4791,0x47a8
  .hword 0x47b8,0x47c1,0x47d1,0x0006,0x47e8,0x47f8,0x4808,0x4817
  .hword 0x4821,0x4837,0x4841,0x4858,0x4868,0x4871,0x4881,0x0006
  .hword 0x4338,0x0008,0x4348,0x4357,0x4361,0x4377,0x4381,0x4398
  .hword 0x43a8,0x43b1,0x43c1,0x0006,0x43d8,0x43e8,0x43f8,0x4407
  .hword 0x4411,0x4427,0x4431,0x4448,0x4458,0x4461,0x4471,0x0006
  .hword 0x4488,0x4498,0x44a8,0x44b7,0x44c1,0x44d7,0x44e1,0x44f8
  .hword 0x4508,0x4511,0x4521,0x0006,0x4898,0x48a8,0x48b8,0x48c7
  .hword 0x48d1,0x48e7,0x48f1,0x4908,0x4918,0x4921,0x4931,0x0006
  .hword 0x45e8,0x0008,0x45f8,0x4607,0x4611,0x4627,0x4631,0x4648
  .hword 0x4658,0x4661,0x4671,0x0006,0x4688,0x4698,0x46a8,0x46b7
  .hword 0x46c1,0x46d7,0x46e1,0x46f8,0x4708,0x4711,0x4721,0x0006
  .hword 0x4738,0x4748,0x4758,0x4767,0x4771,0x4787,0x4791,0x47a8
  .hword 0x47b8,0x47c1,0x47d1,0x0006,0x4948,0x4958,0x4968,0x4977
  .hword 0x4981,0x4997,0x49a1,0x49b8,0x49c8,0x49d1,0x49e1,0x0006
  .hword 0x4338,0x0008,0x4348,0x4357,0x4361,0x4377,0x4381,0x4398
  .hword 0x43a8,0x43b1,0x43c1,0x0006,0x43d8,0x43e8,0x43f8,0x4407
  .hword 0x4411,0x4427,0x4431,0x4448,0x4458,0x4461,0x4471,0x0006
  .hword 0x4488,0x4498,0x44a8,0x44b7,0x44c1,0x44d7,0x44e1,0x44f8
  .hword 0x4508,0x4511,0x4521,0x0006,0x49f8,0x4a08,0x4a18,0x4a27
  .hword 0x4a31,0x4a47,0x4a51,0x4a68,0x4a78,0x4a81,0x4a91,0x0006
  .hword 0x45e8,0x0008,0x45f8,0x4607,0x4611,0x4627,0x4631,0x4648
  .hword 0x4658,0x4661,0x4671,0x0006,0x4688,0x4698,0x46a8,0x46b7
  .hword 0x46c1,0x46d7,0x46e1,0x46f8,0x4708,0x4711,0x4721,0x0006
  .hword 0x4738,0x4748,0x4758,0x4767,0x4771,0x4787,0x4791,0x47a8
  .hword 0x47b8,0x47c1,0x47d1,0x0006,0x4aa8,0x4ab8,0x4ac8,0x4ad7
  .hword 0x4ae1,0x4af7,0x4b01,0x4b18,0x4b28,0x4b31,0x4b41,0x0006
  .hword 0x4338,0x0008,0x4348,0x4357,0x4361,0x4377,0x4381,0x4398
  .hword 0x43a8,0x43b1,0x43c1,0x0006,0x43d8,0x43e8,0x43f8,0x4407
  .hword 0x4411,0x4427,0x4431,0x4448,0x4458,0x4461,0x4471,0x0006
  .hword 0x4488,0x4498,0x44a8,0x44b7,0x44c1,0x44d7,0x44e1,0x44f8
  .hword 0x4508,0x4511,0x4521,0x0006,0x4b58,0x4b68,0x4b78,0x4b87
  .hword 0x4b91,0x4ba7,0x4bb1,0x4bc8,0x4bd8,0x4be1,0x4bf1,0x0006
  .hword 0x45e8,0x0008,0x45f8,0x4607,0x4611,0x4627,0x4631,0x4648
  .hword 0x4658,0x4661,0x4671,0x0006,0x4688,0x4698,0x46a8,0x46b7
  .hword 0x46c1,0x46d7,0x46e1,0x46f8,0x4708,0x4711,0x4721,0x0006
  .hword 0x4738,0x4748,0x4758,0x4767,0x4771,0x4787,0x4791,0x47a8
  .hword 0x47b8,0x47c1,0x47d1,0x0006,0x4c08,0x4c18,0x4c28,0x4c37
  .hword 0x4c41,0x4c57,0x4c61,0x4c78,0x4c88,0x4c91,0x4ca1,0x0006
  .hword 0x4338,0x0008,0x4348,0x4357,0x4361,0x4377,0x4381,0x4398
  .hword 0x43a8,0x43b1,0x43c1,0x0006,0x43d8,0x43e8,0x43f8,0x4407
  .hword 0x4411,0x4427,0x4431,0x4448,0x4458,0x4461,0x4471,0x0006
  .hword 0x4488,0x4498,0x44a8,0x44b7,0x44c1,0x44d7,0x44e1,0x44f8
  .hword 0x4508,0x4511,0x4521,0x0006,0x4cb8,0x4cc8,0x4cd8,0x4ce7
  .hword 0x4cf1,0x4d07,0x4d11,0x4d28,0x4d38,0x4d41,0x4d51,0x0006
  .hword 0x45e8,0x0008,0x45f8,0x4607,0x4611,0x4627,0x4631,0x4648
  .hword 0x4658,0x4661,0x4671,0x0006,0x4688,0x4698,0x46a8,0x46b7
  .hword 0x46c1,0x46d7,0x46e1,0x46f8,0x4708,0x4711,0x4721,0x0006
  .hword 0x4738,0x4748,0x4758,0x4767,0x4771,0x4787,0x4791,0x47a8
  .hword 0x47b8,0x47c1,0x47d1,0x0006,0x4d68,0x4d78,0x4d88,0x4d97
  .hword 0x4da1,0x4db7,0x4dc1,0x4dd8,0x4de8,0x4df1,0x4e01,0x0006
  .hword 0x4338,0x0008,0x4348,0x4357,0x4361,0x4377,0x4381,0x4398
  .hword 0x43a8,0x43b1,0x43c1,0x0006,0x43d8,0x43e8,0x43f8,0x4407
  .hword 0x4411,0x4427,0x4431,0x4448,0x4458,0x4461,0x4471,0x0006
  .hword 0x4488,0x4498,0x44a8,0x44b7,0x44c1,0x44d7,0x44e1,0x44f8
  .hword 0x4508,0x4511,0x4521,0x0006,0x4e18,0x4e28,0x4e38,0x4e47
  .hword 0x4e51,0x4e67,0x4e71,0x4e88,0x4e98,0x4ea1,0x4eb1,0x0006
  .hword 0x45e8,0x0008,0x45f8,0x4607,0x4611,0x4627,0x4631,0x4648
  .hword 0x4658,0x4661,0x4671,0x0006,0x4688,0x4698,0x46a8,0x46b7
  .hword 0x46c1,0x46d7,0x46e1,0x46f8,0x4708,0x4711,0x4721,0x0006
  .hword 0x4738,0x4748,0x4758,0x4767,0x4771,0x4787,0x4791,0x47a8
  .hword 0x47b8,0x47c1,0x47d1,0x0006,0x4ec8,0x4ed8,0x4ee8,0x4ef7
  .hword 0x4f01,0x4f17,0x4f21,0x4f38,0x4f48,0x4f51,0x4f61,0x0006
  .hword 0x4338,0x0008,0x4348,0x4357,0x4361,0x4377,0x4381,0x4398
  .hword 0x43a8,0x43b1,0x43c1,0x0006,0x43d8,0x43e8,0x43f8,0x4407
  .hword 0x4411,0x4427,0x4431,0x4448,0x4458,0x4461,0x4471,0x0006
  .hword 0x4488,0x4498,0x44a8,0x44b7,0x44c1,0x44d7,0x44e1,0x44f8
  .hword 0x4508,0x4511,0x4521,0x0006,0x4f78,0x4f88,0x4f98,0x4fa7
  .hword 0x4fb1,0x4fc7,0x4fd1,0x4fe8,0x4ff8,0x5001,0x5011,0x0006
  .hword 0x45e8,0x0008,0x45f8,0x4607,0x4611,0x4627,0x4631,0x4648
  .hword 0x4658,0x4661,0x4671,0x0006,0x4688,0x4698,0x46a8,0x46b7
  .hword 0x46c1,0x46d7,0x46e1,0x46f8,0x4708,0x4711,0x4721,0x0006
  .hword 0x4738,0x4748,0x4758,0x4767,0x4771,0x4787,0x4791,0x47a8
  .hword 0x47b8,0x47c1,0x47d1,0x0006,0x5028,0x5038,0x5048,0x5057
  .hword 0x5061,0x5077,0x5081,0x5098,0x50a8,0x50b1,0x50c1,0x0006
  .hword 0x50d1,0x50e0,0x00fe,0x50f1,0x5101,0x5110,0x00fe,0x5121
  .hword 0x5131,0x5140,0x00fe,0x5151,0x5161,0x5170,0x00fe,0x5181
  .hword 0x5191,0x51a0,0x00fe,0x51b1,0x51c1,0x51d0,0x00fe,0x51e1
  .hword 0x51f1,0x5200,0x00fe,0x5211,0x5221,0x5230,0x00fe,0x5241
  .hword 0x5251,0x5260,0x00fe,0x5271,0x5281,0x5290,0x00fe,0x52a1
  .hword 0x52b1,0x52c0,0x00fe,0x52d1,0x52e1,0x52f0,0x00fe,0x5301
  .hword 0x5311,0x5320,0x00fe,0x5331,0x5341,0x5350,0x00fe,0x5361
  .hword 0x5371,0x5380,0x00fe,0x5391,0x53a1,0x53b0,0x00fe,0x53c1
  .hword 0x53d0,0x0100,0x0000,0x0100,0x53d0,0x0100,0x0000,0x0100
  .hword 0x53d0,0x0100,0x0000,0x0100,0x53d0,0x0100,0x0000,0x0100
  .hword 0x53d0,0x0100,0x0000,0x0100,0x53d0,0x0100,0x0000,0x0100
  .hword 0x53d0,0x0100,0x0000,0x0100,0x53d0,0x0100,0x0000,0x0100
  .hword 0x53e8,0x0008,0x53f8,0x5407,0x5411,0x5427,0x5431,0x5448
  .hword 0x5458,0x5461,0x5471,0x5481,0x5491,0x54a1,0x0003,0x54b8
  .hword 0x0008,0x54c8,0x54d7,0x54e1,0x54f7,0x5501,0x5518,0x5528
  .hword 0x5531,0x5541,0x5551,0x5561,0x5571,0x0003,0x5588,0x0008
  .hword 0x5598,0x55a7,0x55b1,0x55c7,0x55d1,0x55e8,0x55f8,0x5601
  .hword 0x5611,0x5621,0x5631,0x5641,0x0003,0x5658,0x0008,0x5668
  .hword 0x5677,0x5681,0x5697,0x56a1,0x56b8,0x56c8,0x56d1,0x56e1
  .hword 0x56f1,0x5701,0x5711,0x0003,0x5728,0x5737,0x5741,0x5758
  .hword 0x5767,0x5771,0x5787,0x5791,0x57a8,0x57b8,0x57c1,0x57d1
  .hword 0x0000,0x0016,0x57e8,0x57f7,0x5801,0x5817,0x5821,0x5838
  .hword 0x5848,0x5851,0x5861,0x0000,0x0016,0x5878,0x5887,0x5891
  .hword 0x58a7,0x58b1,0x58c8,0x58d8,0x58e1,0x58f1,0x0006,0x5908
  .hword 0x0008,0x5918,0x5927,0x5931,0x5947,0x5951,0x5968,0x5978
  .hword 0x5981,0x5991,0x59a1,0x59b1,0x59c1,0x0003,0x53e8,0x0008
  .hword 0x53f8,0x5407,0x5411,0x5427,0x5431,0x5448,0x5458,0x5461
  .hword 0x5471,0x5481,0x5491,0x54a1,0x0003,0x54b8,0x0008,0x54c8
  .hword 0x54d7,0x54e1,0x54f7,0x5501,0x5518,0x5528,0x5531,0x5541
  .hword 0x5551,0x5561,0x5571,0x0003,0x5588,0x0008,0x5598,0x55a7
  .hword 0x55b1,0x55c7,0x55d1,0x55e8,0x55f8,0x5601,0x5611,0x5621
  .hword 0x5631,0x5641,0x0003,0x5658,0x0008,0x5668,0x5677,0x5681
  .hword 0x5697,0x56a1,0x56b8,0x56c8,0x56d1,0x56e1,0x56f1,0x5701
  .hword 0x5711,0x0003,0x5728,0x5737,0x59d1,0x5758,0x5767,0x5771
  .hword 0x5787,0x5791,0x57a8,0x57b8,0x57c1,0x57d1,0x0000,0x0016
  .hword 0x57e8,0x57f7,0x5801,0x5817,0x5821,0x5838,0x5848,0x5851
  .hword 0x5861,0x0000,0x0016,0x5878,0x5887,0x5891,0x58a7,0x58b1
  .hword 0x58c8,0x58d8,0x58e1,0x58f1,0x0006,0x5908,0x0008,0x5918
  .hword 0x5927,0x5931,0x5947,0x5951,0x5968,0x5978,0x5981,0x5991
  .hword 0x59a1,0x59b1,0x59c1,0x0003,0x53e8,0x0008,0x53f8,0x5407
  .hword 0x5411,0x5427,0x5431,0x5448,0x5458,0x5461,0x5471,0x5481
  .hword 0x5491,0x54a1,0x0003,0x54b8,0x0008,0x54c8,0x54d7,0x54e1
  .hword 0x54f7,0x5501,0x5518,0x5528,0x5531,0x5541,0x5551,0x5561
  .hword 0x5571,0x0003,0x5588,0x0008,0x5598,0x55a7,0x55b1,0x55c7
  .hword 0x55d1,0x55e8,0x55f8,0x5601,0x5611,0x5621,0x5631,0x5641
  .hword 0x0003,0x5658,0x0008,0x5668,0x5677,0x5681,0x5697,0x56a1
  .hword 0x56b8,0x56c8,0x56d1,0x56e1,0x56f1,0x5701,0x5711,0x0003
  .hword 0x5728,0x5737,0x59e1,0x5758,0x5767,0x5771,0x5787,0x5791
  .hword 0x57a8,0x57b8,0x57c1,0x57d1,0x0000,0x0016,0x57e8,0x57f7
  .hword 0x5801,0x5817,0x5821,0x5838,0x5848,0x5851,0x5861,0x0000
  .hword 0x0016,0x5878,0x5887,0x5891,0x58a7,0x58b1,0x58c8,0x58d8
  .hword 0x58e1,0x58f1,0x0006,0x5908,0x0008,0x5918,0x5927,0x5931
  .hword 0x5947,0x5951,0x5968,0x5978,0x5981,0x5991,0x59a1,0x59b1
  .hword 0x59c1,0x0003,0x53e8,0x0008,0x53f8,0x5407,0x5411,0x5427
  .hword 0x5431,0x5448,0x5458,0x5461,0x5471,0x5481,0x5491,0x54a1
  .hword 0x0003,0x54b8,0x0008,0x54c8,0x54d7,0x54e1,0x54f7,0x5501
  .hword 0x5518,0x5528,0x5531,0x5541,0x5551,0x5561,0x5571,0x0003
  .hword 0x5588,0x0008,0x5598,0x55a7,0x55b1,0x55c7,0x55d1,0x55e8
  .hword 0x55f8,0x5601,0x5611,0x5621,0x5631,0x5641,0x0003,0x5658
  .hword 0x0008,0x5668,0x5677,0x5681,0x5697,0x56a1,0x56b8,0x56c8
  .hword 0x56d1,0x56e1,0x56f1,0x5701,0x5711,0x0003,0x5728,0x5737
  .hword 0x59f1,0x5758,0x5767,0x5771,0x5787,0x5791,0x57a8,0x57b8
  .hword 0x57c1,0x57d1,0x0000,0x0016,0x57e8,0x57f7,0x5801,0x5817
  .hword 0x5821,0x5838,0x5848,0x5851,0x5861,0x0000,0x0016,0x5878
  .hword 0x5887,0x5891,0x58a7,0x58b1,0x58c8,0x58d8,0x58e1,0x58f1
  .hword 0x0006,0x5908,0x0008,0x5918,0x5927,0x5931,0x5947,0x5951
  .hword 0x5968,0x5978,0x5981,0x5991,0x59a1,0x59b1,0x59c1,0x0003
  .hword 0x53e8,0x0008,0x53f8,0x5407,0x5411,0x5427,0x5431,0x5448
  .hword 0x5458,0x5461,0x5471,0x5481,0x5491,0x54a1,0x0003,0x54b8
  .hword 0x0008,0x54c8,0x54d7,0x54e1,0x54f7,0x5501,0x5518,0x5528
  .hword 0x5531,0x5541,0x5551,0x5561,0x5571,0x0003,0x5588,0x0008
  .hword 0x5598,0x55a7,0x55b1,0x55c7,0x55d1,0x55e8,0x55f8,0x5601
  .hword 0x5611,0x5621,0x5631,0x5641,0x0003,0x5658,0x0008,0x5668
  .hword 0x5677,0x5681,0x5697,0x56a1,0x56b8,0x56c8,0x56d1,0x56e1
  .hword 0x56f1,0x5701,0x5711,0x0003,0x5728,0x5737,0x5a01,0x5758
  .hword 0x5767,0x5771,0x5787,0x5791,0x57a8,0x57b8,0x57c1,0x57d1
  .hword 0x0000,0x0016,0x57e8,0x57f7,0x5801,0x5817,0x5821,0x5838
  .hword 0x5848,0x5851,0x5861,0x0000,0x0016,0x5878,0x5887,0x5891
  .hword 0x58a7,0x58b1,0x58c8,0x58d8,0x58e1,0x58f1,0x0006,0x5908
  .hword 0x0008,0x5918,0x5927,0x5931,0x5947,0x5951,0x5968,0x5978
  .hword 0x5981,0x5991,0x59a1,0x59b1,0x59c1,0x0003,0x53e8,0x0008
  .hword 0x53f8,0x5407,0x5411,0x5427,0x5431,0x5448,0x5458,0x5461
  .hword 0x5471,0x5481,0x5491,0x54a1,0x0003,0x54b8,0x0008,0x54c8
  .hword 0x54d7,0x54e1,0x54f7,0x5501,0x5518,0x5528,0x5531,0x5541
  .hword 0x5551,0x5561,0x5571,0x0003,0x5588,0x0008,0x5598,0x55a7
  .hword 0x55b1,0x55c7,0x55d1,0x55e8,0x55f8,0x5601,0x5611,0x5621
  .hword 0x5631,0x5641,0x0003,0x5658,0x0008,0x5668,0x5677,0x5681
  .hword 0x5697,0x56a1,0x56b8,0x56c8,0x56d1,0x56e1,0x56f1,0x5701
  .hword 0x5711,0x0003,0x5728,0x5737,0x5a11,0x5758,0x5767,0x5771
  .hword 0x5787,0x5791,0x57a8,0x57b8,0x57c1,0x57d1,0x0000,0x0016
  .hword 0x57e8,0x57f7,0x5801,0x5817,0x5821,0x5838,0x5848,0x5851
  .hword 0x5861,0x0000,0x0016,0x5878,0x5887,0x5891,0x58a7,0x58b1
  .hword 0x58c8,0x58d8,0x58e1,0x58f1,0x0006,0x5908,0x0008,0x5918
  .hword 0x5927,0x5931,0x5947,0x5951,0x5968,0x5978,0x5981,0x5991
  .hword 0x59a1,0x59b1,0x59c1,0x0003,0x53e8,0x0008,0x53f8,0x5407
  .hword 0x5411,0x5427,0x5431,0x5448,0x5458,0x5461,0x5471,0x5481
  .hword 0x5491,0x54a1,0x0003,0x54b8,0x0008,0x54c8,0x54d7,0x54e1
  .hword 0x54f7,0x5501,0x5518,0x5528,0x5531,0x5541,0x5551,0x5561
  .hword 0x5571,0x0003,0x5588,0x0008,0x5598,0x55a7,0x55b1,0x55c7
  .hword 0x55d1,0x55e8,0x55f8,0x5601,0x5611,0x5621,0x5631,0x5641
  .hword 0x0003,0x5658,0x0008,0x5668,0x5677,0x5681,0x5697,0x56a1
  .hword 0x56b8,0x56c8,0x56d1,0x56e1,0x56f1,0x5701,0x5711,0x0003
  .hword 0x5728,0x5737,0x5a21,0x5758,0x5767,0x5771,0x5787,0x5791
  .hword 0x57a8,0x57b8,0x57c1,0x57d1,0x0000,0x0016,0x57e8,0x57f7
  .hword 0x5801,0x5817,0x5821,0x5838,0x5848,0x5851,0x5861,0x0000
  .hword 0x0016,0x5878,0x5887,0x5891,0x58a7,0x58b1,0x58c8,0x58d8
  .hword 0x58e1,0x58f1,0x0006,0x5908,0x0008,0x5918,0x5927,0x5931
  .hword 0x5947,0x5951,0x5968,0x5978,0x5981,0x5991,0x59a1,0x59b1
  .hword 0x59c1,0x0003,0x53e8,0x0008,0x53f8,0x5407,0x5411,0x5427
  .hword 0x5431,0x5448,0x5458,0x5461,0x5471,0x5481,0x5491,0x54a1
  .hword 0x0003,0x54b8,0x0008,0x54c8,0x54d7,0x54e1,0x54f7,0x5501
  .hword 0x5518,0x5528,0x5531,0x5541,0x5551,0x5561,0x5571,0x0003
  .hword 0x5588,0x0008,0x5598,0x55a7,0x55b1,0x55c7,0x55d1,0x55e8
  .hword 0x55f8,0x5601,0x5611,0x5621,0x5631,0x5641,0x0003,0x5658
  .hword 0x0008,0x5668,0x5677,0x5681,0x5697,0x56a1,0x56b8,0x56c8
  .hword 0x56d1,0x56e1,0x56f1,0x5701,0x5711,0x0003,0x5728,0x5a31
  .hword 0x5a41,0x5a51,0x5a61,0x5a71,0x5a81,0x5a91,0x5aa1,0x5758
  .hword 0x5767,0x5771,0x5787,0x5791,0x57a8,0x57b8,0x57c1,0x57d1
  .hword 0x0000,0x0016,0x57e8,0x57f7,0x5801,0x5817,0x5821,0x5838
  .hword 0x5848,0x5851,0x5861,0x0000,0x0016,0x5878,0x5887,0x5891
  .hword 0x58a7,0x58b1,0x58c8,0x58d8,0x58e1,0x58f1,0x0006,0x5908
  .hword 0x0008,0x5918,0x5927,0x5931,0x5947,0x5951,0x5968,0x5978
  .hword 0x5981,0x5991,0x59a1,0x59b1,0x59c1,0x0003,0x5ab8,0x0008
  .hword 0x5ac8,0x5ad7,0x5ae1,0x5af7,0x5b01,0x5b18,0x5b28,0x5b31
  .hword 0x5b41,0x5b51,0x5b61,0x5b71,0x0003,0x5b8f,0x5b98,0x5ba7
  .hword 0x5bb1,0x5bc7,0x5bd1,0x5be8,0x5bf8,0x5c01,0x5c11,0x5c21
  .hword 0x5c31,0x5c41,0x0003,0x5c5f,0x5c68,0x5c77,0x5c81,0x5c97
  .hword 0x5ca1,0x5cb8,0x5cc8,0x5cd1,0x5ce1,0x5cf1,0x5d01,0x5d11
  .hword 0x0003,0x5d2f,0x5d38,0x5d47,0x5d51,0x5d67,0x5d71,0x5d88
  .hword 0x5d98,0x5da1,0x5db1,0x5dc1,0x5dd1,0x5de1,0x0003,0x5df8
  .hword 0x5e07,0x5e11,0x5e28,0x5e37,0x5e41,0x5e57,0x5e61,0x5e78
  .hword 0x5e88,0x5e91,0x5ea1,0x0006,0x5eb8,0x5ec8,0x5ed8,0x5ee7
  .hword 0x5ef1,0x5f07,0x5f11,0x5f28,0x5f38,0x5f41,0x5f51,0x0006
  .hword 0x5f68,0x5f78,0x5f88,0x5f97,0x5fa1,0x5fb7,0x5fc1,0x5fd8
  .hword 0x5fe8,0x5ff1,0x6001,0x0006,0x601f,0x6028,0x6037,0x6041
  .hword 0x6057,0x6061,0x6078,0x6088,0x6091,0x60a1,0x60b1,0x60c1
  .hword 0x60d1,0x0003,0x5ab8,0x0008,0x5ac8,0x5ad7,0x5ae1,0x5af7
  .hword 0x5b01,0x5b18,0x5b28,0x5b31,0x5b41,0x5b51,0x5b61,0x5b71
  .hword 0x0003,0x5b8f,0x5b98,0x5ba7,0x5bb1,0x5bc7,0x5bd1,0x5be8
  .hword 0x5bf8,0x5c01,0x5c11,0x5c21,0x5c31,0x5c41,0x0003,0x5c5f
  .hword 0x5c68,0x5c77,0x5c81,0x5c97,0x5ca1,0x5cb8,0x5cc8,0x5cd1
  .hword 0x5ce1,0x5cf1,0x5d01,0x5d11,0x0003,0x5d2f,0x5d38,0x5d47
  .hword 0x5d51,0x5d67,0x5d71,0x5d88,0x5d98,0x5da1,0x5db1,0x5dc1
  .hword 0x5dd1,0x5de1,0x0003,0x5df8,0x5e07,0x60e1,0x5e28,0x5e37
  .hword 0x5e41,0x5e57,0x5e61,0x5e78,0x5e88,0x5e91,0x5ea1,0x0006
  .hword 0x5eb8,0x5ec8,0x5ed8,0x5ee7,0x5ef1,0x5f07,0x5f11,0x5f28
  .hword 0x5f38,0x5f41,0x5f51,0x0006,0x5f68,0x5f78,0x5f88,0x5f97
  .hword 0x5fa1,0x5fb7,0x5fc1,0x5fd8,0x5fe8,0x5ff1,0x6001,0x0006
  .hword 0x601f,0x6028,0x6037,0x6041,0x6057,0x6061,0x6078,0x6088
  .hword 0x6091,0x60a1,0x60b1,0x60c1,0x60d1,0x0003,0x5ab8,0x0008
  .hword 0x5ac8,0x5ad7,0x5ae1,0x5af7,0x5b01,0x5b18,0x5b28,0x5b31
  .hword 0x5b41,0x5b51,0x5b61,0x5b71,0x0003,0x5b8f,0x5b98,0x5ba7
  .hword 0x5bb1,0x5bc7,0x5bd1,0x5be8,0x5bf8,0x5c01,0x5c11,0x5c21
  .hword 0x5c31,0x5c41,0x0003,0x5c5f,0x5c68,0x5c77,0x5c81,0x5c97
  .hword 0x5ca1,0x5cb8,0x5cc8,0x5cd1,0x5ce1,0x5cf1,0x5d01,0x5d11
  .hword 0x0003,0x5d2f,0x5d38,0x5d47,0x5d51,0x5d67,0x5d71,0x5d88
  .hword 0x5d98,0x5da1,0x5db1,0x5dc1,0x5dd1,0x5de1,0x0003,0x5df8
  .hword 0x5e07,0x60f1,0x5e28,0x5e37,0x5e41,0x5e57,0x5e61,0x5e78
  .hword 0x5e88,0x5e91,0x5ea1,0x0006,0x5eb8,0x5ec8,0x5ed8,0x5ee7
  .hword 0x5ef1,0x5f07,0x5f11,0x5f28,0x5f38,0x5f41,0x5f51,0x0006
  .hword 0x5f68,0x5f78,0x5f88,0x5f97,0x5fa1,0x5fb7,0x5fc1,0x5fd8
  .hword 0x5fe8,0x5ff1,0x6001,0x0006,0x601f,0x6028,0x6037,0x6041
  .hword 0x6057,0x6061,0x6078,0x6088,0x6091,0x60a1,0x60b1,0x60c1
  .hword 0x60d1,0x0003,0x5ab8,0x0008,0x5ac8,0x5ad7,0x5ae1,0x5af7
  .hword 0x5b01,0x5b18,0x5b28,0x5b31,0x5b41,0x5b51,0x5b61,0x5b71
  .hword 0x0003,0x5b8f,0x5b98,0x5ba7,0x5bb1,0x5bc7,0x5bd1,0x5be8
  .hword 0x5bf8,0x5c01,0x5c11,0x5c21,0x5c31,0x5c41,0x0003,0x5c5f
  .hword 0x5c68,0x5c77,0x5c81,0x5c97,0x5ca1,0x5cb8,0x5cc8,0x5cd1
  .hword 0x5ce1,0x5cf1,0x5d01,0x5d11,0x0003,0x5d2f,0x5d38,0x5d47
  .hword 0x5d51,0x5d67,0x5d71,0x5d88,0x5d98,0x5da1,0x5db1,0x5dc1
  .hword 0x5dd1,0x5de1,0x0003,0x5df8,0x5e07,0x6101,0x5e28,0x5e37
  .hword 0x5e41,0x5e57,0x5e61,0x5e78,0x5e88,0x5e91,0x5ea1,0x0006
  .hword 0x5eb8,0x5ec8,0x5ed8,0x5ee7,0x5ef1,0x5f07,0x5f11,0x5f28
  .hword 0x5f38,0x5f41,0x5f51,0x0006,0x5f68,0x5f78,0x5f88,0x5f97
  .hword 0x5fa1,0x5fb7,0x5fc1,0x5fd8,0x5fe8,0x5ff1,0x6001,0x0006
  .hword 0x601f,0x6028,0x6037,0x6041,0x6057,0x6061,0x6078,0x6088
  .hword 0x6091,0x60a1,0x60b1,0x60c1,0x60d1,0x0003,0x5ab8,0x0008
  .hword 0x5ac8,0x5ad7,0x5ae1,0x5af7,0x5b01,0x5b18,0x5b28,0x5b31
  .hword 0x5b41,0x5b51,0x5b61,0x5b71,0x0003,0x5b8f,0x5b98,0x5ba7
  .hword 0x5bb1,0x5bc7,0x5bd1,0x5be8,0x5bf8,0x5c01,0x5c11,0x5c21
  .hword 0x5c31,0x5c41,0x0003,0x5c5f,0x5c68,0x5c77,0x5c81,0x5c97
  .hword 0x5ca1,0x5cb8,0x5cc8,0x5cd1,0x5ce1,0x5cf1,0x5d01,0x5d11
  .hword 0x0003,0x5d2f,0x5d38,0x5d47,0x5d51,0x5d67,0x5d71,0x5d88
  .hword 0x5d98,0x5da1,0x5db1,0x5dc1,0x5dd1,0x5de1,0x0003,0x5df8
  .hword 0x5e07,0x6111,0x5e28,0x5e37,0x5e41,0x5e57,0x5e61,0x5e78
  .hword 0x5e88,0x5e91,0x5ea1,0x0006,0x5eb8,0x5ec8,0x5ed8,0x5ee7
  .hword 0x5ef1,0x5f07,0x5f11,0x5f28,0x5f38,0x5f41,0x5f51,0x0006
  .hword 0x5f68,0x5f78,0x5f88,0x5f97,0x5fa1,0x5fb7,0x5fc1,0x5fd8
  .hword 0x5fe8,0x5ff1,0x6001,0x0006,0x601f,0x6028,0x6037,0x6041
  .hword 0x6057,0x6061,0x6078,0x6088,0x6091,0x60a1,0x60b1,0x60c1
  .hword 0x60d1,0x0003,0x5ab8,0x0008,0x5ac8,0x5ad7,0x5ae1,0x5af7
  .hword 0x5b01,0x5b18,0x5b28,0x5b31,0x5b41,0x5b51,0x5b61,0x5b71
  .hword 0x0003,0x5b8f,0x5b98,0x5ba7,0x5bb1,0x5bc7,0x5bd1,0x5be8
  .hword 0x5bf8,0x5c01,0x5c11,0x5c21,0x5c31,0x5c41,0x0003,0x5c5f
  .hword 0x5c68,0x5c77,0x5c81,0x5c97,0x5ca1,0x5cb8,0x5cc8,0x5cd1
  .hword 0x5ce1,0x5cf1,0x5d01,0x5d11,0x0003,0x5d2f,0x5d38,0x5d47
  .hword 0x5d51,0x5d67,0x5d71,0x5d88,0x5d98,0x5da1,0x5db1,0x5dc1
  .hword 0x5dd1,0x5de1,0x0003,0x5df8,0x5e07,0x6121,0x5e28,0x5e37
  .hword 0x5e41,0x5e57,0x5e61,0x5e78,0x5e88,0x5e91,0x5ea1,0x0006
  .hword 0x5eb8,0x5ec8,0x5ed8,0x5ee7,0x5ef1,0x5f07,0x5f11,0x5f28
  .hword 0x5f38,0x5f41,0x5f51,0x0006,0x5f68,0x5f78,0x5f88,0x5f97
  .hword 0x5fa1,0x5fb7,0x5fc1,0x5fd8,0x5fe8,0x5ff1,0x6001,0x0006
  .hword 0x601f,0x6028,0x6037,0x6041,0x6057,0x6061,0x6078,0x6088
  .hword 0x6091,0x60a1,0x60b1,0x60c1,0x60d1,0x0003,0x5ab8,0x0008
  .hword 0x5ac8,0x5ad7,0x5ae1,0x5af7,0x5b01,0x5b18,0x5b28,0x5b31
  .hword 0x5b41,0x5b51,0x5b61,0x5b71,0x0003,0x5b8f,0x5b98,0x5ba7
  .hword 0x5bb1,0x5bc7,0x5bd1,0x5be8,0x5bf8,0x5c01,0x5c11,0x5c21
  .hword 0x5c31,0x5c41,0x0003,0x5c5f,0x5c68,0x5c77,0x5c81,0x5c97
  .hword 0x5ca1,0x5cb8,0x5cc8,0x5cd1,0x5ce1,0x5cf1,0x5d01,0x5d11
  .hword 0x0003,0x5d2f,0x5d38,0x5d47,0x5d51,0x5d67,0x5d71,0x5d88
  .hword 0x5d98,0x5da1,0x5db1,0x5dc1,0x5dd1,0x5de1,0x0003,0x5df8
  .hword 0x5e07,0x6131,0x5e28,0x5e37,0x5e41,0x5e57,0x5e61,0x5e78
  .hword 0x5e88,0x5e91,0x5ea1,0x0006,0x5eb8,0x5ec8,0x5ed8,0x5ee7
  .hword 0x5ef1,0x5f07,0x5f11,0x5f28,0x5f38,0x5f41,0x5f51,0x0006
  .hword 0x5f68,0x5f78,0x5f88,0x5f97,0x5fa1,0x5fb7,0x5fc1,0x5fd8
  .hword 0x5fe8,0x5ff1,0x6001,0x0006,0x601f,0x6028,0x6037,0x6041
  .hword 0x6057,0x6061,0x6078,0x6088,0x6091,0x60a1,0x60b1,0x60c1
  .hword 0x60d1,0x0003,0x5ab8,0x0008,0x5ac8,0x5ad7,0x5ae1,0x5af7
  .hword 0x5b01,0x5b18,0x5b28,0x5b31,0x5b41,0x5b51,0x5b61,0x5b71
  .hword 0x0003,0x5b8f,0x5b98,0x5ba7,0x5bb1,0x5bc7,0x5bd1,0x5be8
  .hword 0x5bf8,0x5c01,0x5c11,0x5c21,0x5c31,0x5c41,0x0003,0x5c5f
  .hword 0x5c68,0x5c77,0x5c81,0x5c97,0x5ca1,0x5cb8,0x5cc8,0x5cd1
  .hword 0x5ce1,0x5cf1,0x5d01,0x5d11,0x0003,0x5d2f,0x5d38,0x5d47
  .hword 0x5d51,0x5d67,0x5d71,0x5d88,0x5d98,0x5da1,0x5db1,0x5dc1
  .hword 0x5dd1,0x5de1,0x0003,0x5df8,0x6141,0x6151,0x6161,0x6171
  .hword 0x6181,0x6191,0x61a1,0x61b1,0x5e28,0x5e37,0x5e41,0x5e57
  .hword 0x5e61,0x5e78,0x5e88,0x5e91,0x5ea1,0x0006,0x5eb8,0x5ec8
  .hword 0x5ed8,0x5ee7,0x5ef1,0x5f07,0x5f11,0x5f28,0x5f38,0x5f41
  .hword 0x5f51,0x0006,0x5f68,0x5f78,0x5f88,0x5f97,0x5fa1,0x5fb7
  .hword 0x5fc1,0x5fd8,0x5fe8,0x5ff1,0x6001,0x0006,0x601f,0x6028
  .hword 0x6037,0x6041,0x6057,0x6061,0x6078,0x6088,0x6091,0x60a1
  .hword 0x60b1,0x60c1,0x60d1,0x0003,0x8040,0x1000,0x61c8,0x0008
  .hword 0x61d8,0x61e7,0x61f1,0x6207,0x6211,0x6228,0x6238,0x6241
  .hword 0x6251,0x6261,0x6271,0x6281,0x0003,0x629f,0x62a8,0x62b7
  .hword 0x62c1,0x62d7,0x62e1,0x62f8,0x6308,0x6311,0x6321,0x6331
  .hword 0x6341,0x6351,0x0003,0x636f,0x6378,0x6387,0x6391,0x63a7
  .hword 0x63b1,0x63c8,0x63d8,0x63e1,0x63f1,0x6401,0x6411,0x6421
  .hword 0x0003,0x643f,0x6448,0x6457,0x6461,0x6477,0x6481,0x6498
  .hword 0x64a8,0x64b1,0x64c1,0x64d1,0x64e1,0x64f1,0x0003,0x6508
  .hword 0x6517,0x6521,0x6538,0x6547,0x6551,0x6567,0x6571,0x6588
  .hword 0x6598,0x65a1,0x65b1,0x0006,0x65c8,0x65d8,0x65e8,0x65f7
  .hword 0x6601,0x6617,0x6621,0x6638,0x6648,0x6651,0x6661,0x0006
  .hword 0x6678,0x6688,0x6698,0x66a7,0x66b1,0x66c7,0x66d1,0x66e8
  .hword 0x66f8,0x6701,0x6711,0x0006,0x672f,0x6738,0x6747,0x6751
  .hword 0x6767,0x6771,0x6788,0x6798,0x67a1,0x67b1,0x67c1,0x67d1
  .hword 0x67e1,0x0003,0x61c8,0x0008,0x61d8,0x61e7,0x61f1,0x6207
  .hword 0x6211,0x6228,0x6238,0x6241,0x6251,0x6261,0x6271,0x6281
  .hword 0x0003,0x629f,0x62a8,0x62b7,0x62c1,0x62d7,0x62e1,0x62f8
  .hword 0x6308,0x6311,0x6321,0x6331,0x6341,0x6351,0x0003,0x636f
  .hword 0x6378,0x6387,0x6391,0x63a7,0x63b1,0x63c8,0x63d8,0x63e1
  .hword 0x63f1,0x6401,0x6411,0x6421,0x0003,0x643f,0x6448,0x6457
  .hword 0x6461,0x6477,0x6481,0x6498,0x64a8,0x64b1,0x64c1,0x64d1
  .hword 0x64e1,0x64f1,0x0003,0x6508,0x6517,0x67f1,0x6538,0x6547
  .hword 0x6551,0x6567,0x6571,0x6588,0x6598,0x65a1,0x65b1,0x0006
  .hword 0x65c8,0x65d8,0x65e8,0x65f7,0x6601,0x6617,0x6621,0x6638
  .hword 0x6648,0x6651,0x6661,0x0006,0x6678,0x6688,0x6698,0x66a7
  .hword 0x66b1,0x66c7,0x66d1,0x66e8,0x66f8,0x6701,0x6711,0x0006
  .hword 0x672f,0x6738,0x6747,0x6751,0x6767,0x6771,0x6788,0x6798
  .hword 0x67a1,0x67b1,0x67c1,0x67d1,0x67e1,0x0003,0x61c8,0x0008
  .hword 0x61d8,0x61e7,0x61f1,0x6207,0x6211,0x6228,0x6238,0x6241
  .hword 0x6251,0x6261,0x6271,0x6281,0x0003,0x629f,0x62a8,0x62b7
  .hword 0x62c1,0x62d7,0x62e1,0x62f8,0x6308,0x6311,0x6321,0x6331
  .hword 0x6341,0x6351,0x0003,0x636f,0x6378,0x6387,0x6391,0x63a7
  .hword 0x63b1,0x63c8,0x63d8,0x63e1,0x63f1,0x6401,0x6411,0x6421
  .hword 0x0003,0x643f,0x6448,0x6457,0x6461,0x6477,0x6481,0x6498
  .hword 0x64a8,0x64b1,0x64c1,0x64d1,0x64e1,0x64f1,0x0003,0x6508
  .hword 0x6517,0x6801,0x6538,0x6547,0x6551,0x6567,0x6571,0x6588
  .hword 0x6598,0x65a1,0x65b1,0x0006,0x65c8,0x65d8,0x65e8,0x65f7
  .hword 0x6601,0x6617,0x6621,0x6638,0x6648,0x6651,0x6661,0x0006
  .hword 0x6678,0x6688,0x6698,0x66a7,0x66b1,0x66c7,0x66d1,0x66e8
  .hword 0x66f8,0x6701,0x6711,0x0006,0x672f,0x6738,0x6747,0x6751
  .hword 0x6767,0x6771,0x6788,0x6798,0x67a1,0x67b1,0x67c1,0x67d1
  .hword 0x67e1,0x0003,0x61c8,0x0008,0x61d8,0x61e7,0x61f1,0x6207
  .hword 0x6211,0x6228,0x6238,0x6241,0x6251,0x6261,0x6271,0x6281
  .hword 0x0003,0x629f,0x62a8,0x62b7,0x62c1,0x62d7,0x62e1,0x62f8
  .hword 0x6308,0x6311,0x6321,0x6331,0x6341,0x6351,0x0003,0x636f
  .hword 0x6378,0x6387,0x6391,0x63a7,0x63b1,0x63c8,0x63d8,0x63e1
  .hword 0x63f1,0x6401,0x6411,0x6421,0x0003,0x643f,0x6448,0x6457
  .hword 0x6461,0x6477,0x6481,0x6498,0x64a8,0x64b1,0x64c1,0x64d1
  .hword 0x64e1,0x64f1,0x0003,0x6508,0x6517,0x6811,0x6538,0x6547
  .hword 0x6551,0x6567,0x6571,0x6588,0x6598,0x65a1,0x65b1,0x0006
  .hword 0x65c8,0x65d8,0x65e8,0x65f7,0x6601,0x6617,0x6621,0x6638
  .hword 0x6648,0x6651,0x6661,0x0006,0x6678,0x6688,0x6698,0x66a7
  .hword 0x66b1,0x66c7,0x66d1,0x66e8,0x66f8,0x6701,0x6711,0x0006
  .hword 0x672f,0x6738,0x6747,0x6751,0x6767,0x6771,0x6788,0x6798
  .hword 0x67a1,0x67b1,0x67c1,0x67d1,0x67e1,0x0003,0x61c8,0x0008
  .hword 0x61d8,0x61e7,0x61f1,0x6207,0x6211,0x6228,0x6238,0x6241
  .hword 0x6251,0x6261,0x6271,0x6281,0x0003,0x629f,0x62a8,0x62b7
  .hword 0x62c1,0x62d7,0x62e1,0x62f8,0x6308,0x6311,0x6321,0x6331
  .hword 0x6341,0x6351,0x0003,0x636f,0x6378,0x6387,0x6391,0x63a7
  .hword 0x63b1,0x63c8,0x63d8,0x63e1,0x63f1,0x6401,0x6411,0x6421
  .hword 0x0003,0x643f,0x6448,0x6457,0x6461,0x6477,0x6481,0x6498
  .hword 0x64a8,0x64b1,0x64c1,0x64d1,0x64e1,0x64f1,0x0003,0x6508
  .hword 0x6517,0x6821,0x6538,0x6547,0x6551,0x6567,0x6571,0x6588
  .hword 0x6598,0x65a1,0x65b1,0x0006,0x65c8,0x65d8,0x65e8,0x65f7
  .hword 0x6601,0x6617,0x6621,0x6638,0x6648,0x6651,0x6661,0x0006
  .hword 0x6678,0x6688,0x6698,0x66a7,0x66b1,0x66c7,0x66d1,0x66e8
  .hword 0x66f8,0x6701,0x6711,0x0006,0x672f,0x6738,0x6747,0x6751
  .hword 0x6767,0x6771,0x6788,0x6798,0x67a1,0x67b1,0x67c1,0x67d1
  .hword 0x67e1,0x0003,0x61c8,0x0008,0x61d8,0x61e7,0x61f1,0x6207
  .hword 0x6211,0x6228,0x6238,0x6241,0x6251,0x6261,0x6271,0x6281
  .hword 0x0003,0x629f,0x62a8,0x62b7,0x62c1,0x62d7,0x62e1,0x62f8
  .hword 0x6308,0x6311,0x6321,0x6331,0x6341,0x6351,0x0003,0x636f
  .hword 0x6378,0x6387,0x6391,0x63a7,0x63b1,0x63c8,0x63d8,0x63e1
  .hword 0x63f1,0x6401,0x6411,0x6421,0x0003,0x643f,0x6448,0x6457
  .hword 0x6461,0x6477,0x6481,0x6498,0x64a8,0x64b1,0x64c1,0x64d1
  .hword 0x64e1,0x64f1,0x0003,0x6508,0x6517,0x6831,0x6538,0x6547
  .hword 0x6551,0x6567,0x6571,0x6588,0x6598,0x65a1,0x65b1,0x0006
  .hword 0x65c8,0x65d8,0x65e8,0x65f7,0x6601,0x6617,0x6621,0x6638
  .hword 0x6648,0x6651,0x6661,0x0006,0x6678,0x6688,0x6698,0x66a7
  .hword 0x66b1,0x66c7,0x66d1,0x66e8,0x66f8,0x6701,0x6711,0x0006
  .hword 0x672f,0x6738,0x6747,0x6751,0x6767,0x6771,0x6788,0x6798
  .hword 0x67a1,0x67b1,0x67c1,0x67d1,0x67e1,0x0003,0x61c8,0x0008
  .hword 0x61d8,0x61e7,0x61f1,0x6207,0x6211,0x6228,0x6238,0x6241
  .hword 0x6251,0x6261,0x6271,0x6281,0x0003,0x629f,0x62a8,0x62b7
  .hword 0x62c1,0x62d7,0x62e1,0x62f8,0x6308,0x6311,0x6321,0x6331
  .hword 0x6341,0x6351,0x0003,0x636f,0x6378,0x6387,0x6391,0x63a7
  .hword 0x63b1,0x63c8,0x63d8,0x63e1,0x63f1,0x6401,0x6411,0x6421
  .hword 0x0003,0x643f,0x6448,0x6457,0x6461,0x6477,0x6481,0x6498
  .hword 0x64a8,0x64b1,0x64c1,0x64d1,0x64e1,0x64f1,0x0003,0x6508
  .hword 0x6517,0x6841,0x6538,0x6547,0x6551,0x6567,0x6571,0x6588
  .hword 0x6598,0x65a1,0x65b1,0x0006,0x65c8,0x65d8,0x65e8,0x65f7
  .hword 0x6601,0x6617,0x6621,0x6638,0x6648,0x6651,0x6661,0x0006
  .hword 0x6678,0x6688,0x6698,0x66a7,0x66b1,0x66c7,0x66d1,0x66e8
  .hword 0x66f8,0x6701,0x6711,0x0006,0x672f,0x6738,0x6747,0x6751
  .hword 0x6767,0x6771,0x6788,0x6798,0x67a1,0x67b1,0x67c1,0x67d1
  .hword 0x67e1,0x0003,0x61c8,0x0008,0x61d8,0x61e7,0x61f1,0x6207
  .hword 0x6211,0x6228,0x6238,0x6241,0x6251,0x6261,0x6271,0x6281
  .hword 0x0003,0x629f,0x62a8,0x62b7,0x62c1,0x62d7,0x62e1,0x62f8
  .hword 0x6308,0x6311,0x6321,0x6331,0x6341,0x6351,0x0003,0x636f
  .hword 0x6378,0x6387,0x6391,0x63a7,0x63b1,0x63c8,0x63d8,0x63e1
  .hword 0x63f1,0x6401,0x6411,0x6421,0x0003,0x643f,0x6448,0x6457
  .hword 0x6461,0x6477,0x6481,0x6498,0x64a8,0x64b1,0x64c1,0x64d1
  .hword 0x64e1,0x64f1,0x0003,0x6508,0x6851,0x6861,0x6871,0x6881
  .hword 0x6891,0x68a1,0x68b1,0x68c1,0x6538,0x6547,0x6551,0x6567
  .hword 0x6571,0x6588,0x6598,0x65a1,0x65b1,0x0006,0x65c8,0x65d8
  .hword 0x65e8,0x65f7,0x6601,0x6617,0x6621,0x6638,0x6648,0x6651
  .hword 0x6661,0x0006,0x6678,0x6688,0x6698,0x66a7,0x66b1,0x66c7
  .hword 0x66d1,0x66e8,0x66f8,0x6701,0x6711,0x0006,0x672f,0x6738
  .hword 0x6747,0x6751,0x6767,0x6771,0x6788,0x6798,0x67a1,0x67b1
  .hword 0x67c1,0x67d1,0x67e1,0x0003,0x68d8,0x0008,0x68e8,0x68f7
  .hword 0x6901,0x6917,0x6921,0x6938,0x6948,0x6951,0x6961,0x6971
  .hword 0x6981,0x6991,0x0003,0x69a8,0x0008,0x69b8,0x69c7,0x69d1
  .hword 0x69e7,0x69f1,0x6a08,0x6a18,0x6a21,0x6a31,0x6a41,0x6a51
  .hword 0x6a61,0x0003,0x6a78,0x0008,0x6a88,0x6a97,0x6aa1,0x6ab7
  .hword 0x6ac1,0x6ad8,0x6ae8,0x6af1,0x6b01,0x6b11,0x6b21,0x6b31
  .hword 0x0003,0x6b48,0x0008,0x6b58,0x6b67,0x6b71,0x6b87,0x6b91
  .hword 0x6ba8,0x6bb8,0x6bc1,0x6bd1,0x6be1,0x6bf1,0x6c01,0x0003
  .hword 0x6c18,0x6c27,0x6c31,0x6c48,0x6c57,0x6c61,0x6c77,0x6c81
  .hword 0x6c98,0x6ca8,0x6cb1,0x6cc1,0x0006,0x6cd8,0x6ce8,0x6cf8
  .hword 0x6d07,0x6d11,0x6d27,0x6d31,0x6d48,0x6d58,0x6d61,0x6d71
  .hword 0x000e,0x6d88,0x6d98,0x6da7,0x6db1,0x6dc7,0x6dd1,0x6de8
  .hword 0x6df8,0x6e01,0x6e11,0x0006,0x6e28,0x0008,0x6e38,0x6e47
  .hword 0x6e51,0x6e67,0x6e71,0x6e88,0x6e98,0x6ea1,0x6eb1,0x6ec1
  .hword 0x6ed1,0x6ee1,0x0003,0x68d8,0x0008,0x68e8,0x68f7,0x6901
  .hword 0x6917,0x6921,0x6938,0x6948,0x6951,0x6961,0x6971,0x6981
  .hword 0x6991,0x0003,0x69a8,0x0008,0x69b8,0x69c7,0x69d1,0x69e7
  .hword 0x69f1,0x6a08,0x6a18,0x6a21,0x6a31,0x6a41,0x6a51,0x6a61
  .hword 0x0003,0x6a78,0x0008,0x6a88,0x6a97,0x6aa1,0x6ab7,0x6ac1
  .hword 0x6ad8,0x6ae8,0x6af1,0x6b01,0x6b11,0x6b21,0x6b31,0x0003
  .hword 0x6b48,0x0008,0x6b58,0x6b67,0x6b71,0x6b87,0x6b91,0x6ba8
  .hword 0x6bb8,0x6bc1,0x6bd1,0x6be1,0x6bf1,0x6c01,0x0003,0x6c18
  .hword 0x6c27,0x6ef1,0x6c48,0x6c57,0x6c61,0x6c77,0x6c81,0x6c98
  .hword 0x6ca8,0x6cb1,0x6cc1,0x0006,0x6cd8,0x6ce8,0x6cf8,0x6d07
  .hword 0x6d11,0x6d27,0x6d31,0x6d48,0x6d58,0x6d61,0x6d71,0x000e
  .hword 0x6d88,0x6d98,0x6da7,0x6db1,0x6dc7,0x6dd1,0x6de8,0x6df8
  .hword 0x6e01,0x6e11,0x0006,0x6e28,0x0008,0x6e38,0x6e47,0x6e51
  .hword 0x6e67,0x6e71,0x6e88,0x6e98,0x6ea1,0x6eb1,0x6ec1,0x6ed1
  .hword 0x6ee1,0x0003,0x68d8,0x0008,0x68e8,0x68f7,0x6901,0x6917
  .hword 0x6921,0x6938,0x6948,0x6951,0x6961,0x6971,0x6981,0x6991
  .hword 0x0003,0x69a8,0x0008,0x69b8,0x69c7,0x69d1,0x69e7,0x69f1
  .hword 0x6a08,0x6a18,0x6a21,0x6a31,0x6a41,0x6a51,0x6a61,0x0003
  .hword 0x6a78,0x0008,0x6a88,0x6a97,0x6aa1,0x6ab7,0x6ac1,0x6ad8
  .hword 0x6ae8,0x6af1,0x6b01,0x6b11,0x6b21,0x6b31,0x0003,0x6b48
  .hword 0x0008,0x6b58,0x6b67,0x6b71,0x6b87,0x6b91,0x6ba8,0x6bb8
  .hword 0x6bc1,0x6bd1,0x6be1,0x6bf1,0x6c01,0x0003,0x6c18,0x6c27
  .hword 0x6f01,0x6c48,0x6c57,0x6c61,0x6c77,0x6c81,0x6c98,0x6ca8
  .hword 0x6cb1,0x6cc1,0x0006,0x6cd8,0x6ce8,0x6cf8,0x6d07,0x6d11
  .hword 0x6d27,0x6d31,0x6d48,0x6d58,0x6d61,0x6d71,0x000e,0x6d88
  .hword 0x6d98,0x6da7,0x6db1,0x6dc7,0x6dd1,0x6de8,0x6df8,0x6e01
  .hword 0x6e11,0x0006,0x6e28,0x0008,0x6e38,0x6e47,0x6e51,0x6e67
  .hword 0x6e71,0x6e88,0x6e98,0x6ea1,0x6eb1,0x6ec1,0x6ed1,0x6ee1
  .hword 0x0003,0x68d8,0x0008,0x68e8,0x68f7,0x6901,0x6917,0x6921
  .hword 0x6938,0x6948,0x6951,0x6961,0x6971,0x6981,0x6991,0x0003
  .hword 0x69a8,0x0008,0x69b8,0x69c7,0x69d1,0x69e7,0x69f1,0x6a08
  .hword 0x6a18,0x6a21,0x6a31,0x6a41,0x6a51,0x6a61,0x0003,0x6a78
  .hword 0x0008,0x6a88,0x6a97,0x6aa1,0x6ab7,0x6ac1,0x6ad8,0x6ae8
  .hword 0x6af1,0x6b01,0x6b11,0x6b21,0x6b31,0x0003,0x6b48,0x0008
  .hword 0x6b58,0x6b67,0x6b71,0x6b87,0x6b91,0x6ba8,0x6bb8,0x6bc1
  .hword 0x6bd1,0x6be1,0x6bf1,0x6c01,0x0003,0x6c18,0x6c27,0x6f11
  .hword 0x6c48,0x6c57,0x6c61,0x6c77,0x6c81,0x6c98,0x6ca8,0x6cb1
  .hword 0x6cc1,0x0006,0x6cd8,0x6ce8,0x6cf8,0x6d07,0x6d11,0x6d27
  .hword 0x6d31,0x6d48,0x6d58,0x6d61,0x6d71,0x000e,0x6d88,0x6d98
  .hword 0x6da7,0x6db1,0x6dc7,0x6dd1,0x6de8,0x6df8,0x6e01,0x6e11
  .hword 0x0006,0x6e28,0x0008,0x6e38,0x6e47,0x6e51,0x6e67,0x6e71
  .hword 0x6e88,0x6e98,0x6ea1,0x6eb1,0x6ec1,0x6ed1,0x6ee1,0x0003
  .hword 0x68d8,0x0008,0x68e8,0x68f7,0x6901,0x6917,0x6921,0x6938
  .hword 0x6948,0x6951,0x6961,0x6971,0x6981,0x6991,0x0003,0x69a8
  .hword 0x0008,0x69b8,0x69c7,0x69d1,0x69e7,0x69f1,0x6a08,0x6a18
  .hword 0x6a21,0x6a31,0x6a41,0x6a51,0x6a61,0x0003,0x6a78,0x0008
  .hword 0x6a88,0x6a97,0x6aa1,0x6ab7,0x6ac1,0x6ad8,0x6ae8,0x6af1
  .hword 0x6b01,0x6b11,0x6b21,0x6b31,0x0003,0x6b48,0x0008,0x6b58
  .hword 0x6b67,0x6b71,0x6b87,0x6b91,0x6ba8,0x6bb8,0x6bc1,0x6bd1
  .hword 0x6be1,0x6bf1,0x6c01,0x0003,0x6c18,0x6c27,0x6f21,0x6c48
  .hword 0x6c57,0x6c61,0x6c77,0x6c81,0x6c98,0x6ca8,0x6cb1,0x6cc1
  .hword 0x0006,0x6cd8,0x6ce8,0x6cf8,0x6d07,0x6d11,0x6d27,0x6d31
  .hword 0x6d48,0x6d58,0x6d61,0x6d71,0x000e,0x6d88,0x6d98,0x6da7
  .hword 0x6db1,0x6dc7,0x6dd1,0x6de8,0x6df8,0x6e01,0x6e11,0x0006
  .hword 0x6e28,0x0008,0x6e38,0x6e47,0x6e51,0x6e67,0x6e71,0x6e88
  .hword 0x6e98,0x6ea1,0x6eb1,0x6ec1,0x6ed1,0x6ee1,0x0003,0x68d8
  .hword 0x0008,0x68e8,0x68f7,0x6901,0x6917,0x6921,0x6938,0x6948
  .hword 0x6951,0x6961,0x6971,0x6981,0x6991,0x0003,0x69a8,0x0008
  .hword 0x69b8,0x69c7,0x69d1,0x69e7,0x69f1,0x6a08,0x6a18,0x6a21
  .hword 0x6a31,0x6a41,0x6a51,0x6a61,0x0003,0x6a78,0x0008,0x6a88
  .hword 0x6a97,0x6aa1,0x6ab7,0x6ac1,0x6ad8,0x6ae8,0x6af1,0x6b01
  .hword 0x6b11,0x6b21,0x6b31,0x0003,0x6b48,0x0008,0x6b58,0x6b67
  .hword 0x6b71,0x6b87,0x6b91,0x6ba8,0x6bb8,0x6bc1,0x6bd1,0x6be1
  .hword 0x6bf1,0x6c01,0x0003,0x6c18,0x6c27,0x6f31,0x6c48,0x6c57
  .hword 0x6c61,0x6c77,0x6c81,0x6c98,0x6ca8,0x6cb1,0x6cc1,0x0006
  .hword 0x6cd8,0x6ce8,0x6cf8,0x6d07,0x6d11,0x6d27,0x6d31,0x6d48
  .hword 0x6d58,0x6d61,0x6d71,0x000e,0x6d88,0x6d98,0x6da7,0x6db1
  .hword 0x6dc7,0x6dd1,0x6de8,0x6df8,0x6e01,0x6e11,0x0006,0x6e28
  .hword 0x0008,0x6e38,0x6e47,0x6e51,0x6e67,0x6e71,0x6e88,0x6e98
  .hword 0x6ea1,0x6eb1,0x6ec1,0x6ed1,0x6ee1,0x0003,0x68d8,0x0008
  .hword 0x68e8,0x68f7,0x6901,0x6917,0x6921,0x6938,0x6948,0x6951
  .hword 0x6961,0x6971,0x6981,0x6991,0x0003,0x69a8,0x0008,0x69b8
  .hword 0x69c7,0x69d1,0x69e7,0x69f1,0x6a08,0x6a18,0x6a21,0x6a31
  .hword 0x6a41,0x6a51,0x6a61,0x0003,0x6a78,0x0008,0x6a88,0x6a97
  .hword 0x6aa1,0x6ab7,0x6ac1,0x6ad8,0x6ae8,0x6af1,0x6b01,0x6b11
  .hword 0x6b21,0x6b31,0x0003,0x6b48,0x0008,0x6b58,0x6b67,0x6b71
  .hword 0x6b87,0x6b91,0x6ba8,0x6bb8,0x6bc1,0x6bd1,0x6be1,0x6bf1
  .hword 0x6c01,0x0003,0x6c18,0x6c27,0x6f41,0x6c48,0x6c57,0x6c61
  .hword 0x6c77,0x6c81,0x6c98,0x6ca8,0x6cb1,0x6cc1,0x0006,0x6cd8
  .hword 0x6ce8,0x6cf8,0x6d07,0x6d11,0x6d27,0x6d31,0x6d48,0x6d58
  .hword 0x6d61,0x6d71,0x000e,0x6d88,0x6d98,0x6da7,0x6db1,0x6dc7
  .hword 0x6dd1,0x6de8,0x6df8,0x6e01,0x6e11,0x0006,0x6e28,0x0008
  .hword 0x6e38,0x6e47,0x6e51,0x6e67,0x6e71,0x6e88,0x6e98,0x6ea1
  .hword 0x6eb1,0x6ec1,0x6ed1,0x6ee1,0x0003,0x68d8,0x0008,0x68e8
  .hword 0x68f7,0x6901,0x6917,0x6921,0x6938,0x6948,0x6951,0x6961
  .hword 0x6971,0x6981,0x6991,0x0003,0x69a8,0x0008,0x69b8,0x69c7
  .hword 0x69d1,0x69e7,0x69f1,0x6a08,0x6a18,0x6a21,0x6a31,0x6a41
  .hword 0x6a51,0x6a61,0x0003,0x6a78,0x0008,0x6a88,0x6a97,0x6aa1
  .hword 0x6ab7,0x6ac1,0x6ad8,0x6ae8,0x6af1,0x6b01,0x6b11,0x6b21
  .hword 0x6b31,0x0003,0x6b48,0x0008,0x6b58,0x6b67,0x6b71,0x6b87
  .hword 0x6b91,0x6ba8,0x6bb8,0x6bc1,0x6bd1,0x6be1,0x6bf1,0x6c01
  .hword 0x0003,0x6c18,0x6f51,0x6f61,0x6f71,0x6f81,0x6f91,0x6fa1
  .hword 0x6fb1,0x6fc1,0x6c48,0x6c57,0x6c61,0x6c77,0x6c81,0x6c98
  .hword 0x6ca8,0x6cb1,0x6cc1,0x0006,0x6cd8,0x6ce8,0x6cf8,0x6d07
  .hword 0x6d11,0x6d27,0x6d31,0x6d48,0x6d58,0x6d61,0x6d71,0x000e
  .hword 0x6d88,0x6d98,0x6da7,0x6db1,0x6dc7,0x6dd1,0x6de8,0x6df8
  .hword 0x6e01,0x6e11,0x0006,0x6e28,0x0008,0x6e38,0x6e47,0x6e51
  .hword 0x6e67,0x6e71,0x6e88,0x6e98,0x6ea1,0x6eb1,0x6ec1,0x6ed1
  .hword 0x6ee1,0x0003,0x6fd8,0x0008,0x6fe8,0x6ff7,0x7001,0x7017
  .hword 0x7021,0x7038,0x7048,0x7051,0x7061,0x7071,0x7081,0x7091
  .hword 0x0003,0x70af,0x70b8,0x70c7,0x70d1,0x70e7,0x70f1,0x7108
  .hword 0x7118,0x7121,0x7131,0x7141,0x7151,0x7161,0x0003,0x717f
  .hword 0x7188,0x7197,0x71a1,0x71b7,0x71c1,0x71d8,0x71e8,0x71f1
  .hword 0x7201,0x7211,0x7221,0x7231,0x0003,0x724f,0x7258,0x7267
  .hword 0x7271,0x7287,0x7291,0x72a8,0x72b8,0x72c1,0x72d1,0x72e1
  .hword 0x72f1,0x7301,0x0003,0x7318,0x7327,0x7331,0x7348,0x7357
  .hword 0x7361,0x7377,0x7381,0x7398,0x73a8,0x73b1,0x73c1,0x0006
  .hword 0x73d8,0x73e8,0x73f8,0x7407,0x7411,0x7427,0x7431,0x7448
  .hword 0x7458,0x7461,0x7471,0x0006,0x7488,0x7498,0x74a8,0x74b7
  .hword 0x74c1,0x74d7,0x74e1,0x74f8,0x7508,0x7511,0x7521,0x0006
  .hword 0x753f,0x7548,0x7557,0x7561,0x7577,0x7581,0x7598,0x75a8
  .hword 0x75b1,0x75c1,0x75d1,0x75e1,0x75f1,0x0003,0x6fd8,0x0008
  .hword 0x6fe8,0x6ff7,0x7001,0x7017,0x7021,0x7038,0x7048,0x7051
  .hword 0x7061,0x7071,0x7081,0x7091,0x0003,0x70af,0x70b8,0x70c7
  .hword 0x70d1,0x70e7,0x70f1,0x7108,0x7118,0x7121,0x7131,0x7141
  .hword 0x7151,0x7161,0x0003,0x717f,0x7188,0x7197,0x71a1,0x71b7
  .hword 0x71c1,0x71d8,0x71e8,0x71f1,0x7201,0x7211,0x7221,0x7231
  .hword 0x0003,0x724f,0x7258,0x7267,0x7271,0x7287,0x7291,0x72a8
  .hword 0x72b8,0x72c1,0x72d1,0x72e1,0x72f1,0x7301,0x0003,0x7318
  .hword 0x7327,0x7601,0x7348,0x7357,0x7361,0x7377,0x7381,0x7398
  .hword 0x73a8,0x73b1,0x73c1,0x0006,0x73d8,0x73e8,0x73f8,0x7407
  .hword 0x7411,0x7427,0x7431,0x7448,0x7458,0x7461,0x7471,0x0006
  .hword 0x7488,0x7498,0x74a8,0x74b7,0x74c1,0x74d7,0x74e1,0x74f8
  .hword 0x7508,0x7511,0x7521,0x0006,0x753f,0x7548,0x7557,0x7561
  .hword 0x7577,0x7581,0x7598,0x75a8,0x75b1,0x75c1,0x75d1,0x75e1
  .hword 0x75f1,0x0003,0x6fd8,0x0008,0x6fe8,0x6ff7,0x7001,0x7017
  .hword 0x7021,0x7038,0x7048,0x7051,0x7061,0x7071,0x7081,0x7091
  .hword 0x0003,0x70af,0x70b8,0x70c7,0x70d1,0x70e7,0x70f1,0x7108
  .hword 0x7118,0x7121,0x7131,0x7141,0x7151,0x7161,0x0003,0x717f
  .hword 0x7188,0x7197,0x71a1,0x71b7,0x71c1,0x71d8,0x71e8,0x71f1
  .hword 0x7201,0x7211,0x7221,0x7231,0x0003,0x724f,0x7258,0x7267
  .hword 0x7271,0x7287,0x7291,0x72a8,0x72b8,0x72c1,0x72d1,0x72e1
  .hword 0x72f1,0x7301,0x0003,0x7318,0x7327,0x7611,0x7348,0x7357
  .hword 0x7361,0x7377,0x7381,0x7398,0x73a8,0x73b1,0x73c1,0x0006
  .hword 0x73d8,0x73e8,0x73f8,0x7407,0x7411,0x7427,0x7431,0x7448
  .hword 0x7458,0x7461,0x7471,0x0006,0x7488,0x7498,0x74a8,0x74b7
  .hword 0x74c1,0x74d7,0x74e1,0x74f8,0x7508,0x7511,0x7521,0x0006
  .hword 0x753f,0x7548,0x7557,0x7561,0x7577,0x7581,0x7598,0x75a8
  .hword 0x75b1,0x75c1,0x75d1,0x75e1,0x75f1,0x0003,0x6fd8,0x0008
  .hword 0x6fe8,0x6ff7,0x7001,0x7017,0x7021,0x7038,0x7048,0x7051
  .hword 0x7061,0x7071,0x7081,0x7091,0x0003,0x70af,0x70b8,0x70c7
  .hword 0x70d1,0x70e7,0x70f1,0x7108,0x7118,0x7121,0x7131,0x7141
  .hword 0x7151,0x7161,0x0003,0x717f,0x7188,0x7197,0x71a1,0x71b7
  .hword 0x71c1,0x71d8,0x71e8,0x71f1,0x7201,0x7211,0x7221,0x7231
  .hword 0x0003,0x724f,0x7258,0x7267,0x7271,0x7287,0x7291,0x72a8
  .hword 0x72b8,0x72c1,0x72d1,0x72e1,0x72f1,0x7301,0x0003,0x7318
  .hword 0x7327,0x7621,0x7348,0x7357,0x7361,0x7377,0x7381,0x7398
  .hword 0x73a8,0x73b1,0x73c1,0x0006,0x73d8,0x73e8,0x73f8,0x7407
  .hword 0x7411,0x7427,0x7431,0x7448,0x7458,0x7461,0x7471,0x0006
  .hword 0x7488,0x7498,0x74a8,0x74b7,0x74c1,0x74d7,0x74e1,0x74f8
  .hword 0x7508,0x7511,0x7521,0x0006,0x753f,0x7548,0x7557,0x7561
  .hword 0x7577,0x7581,0x7598,0x75a8,0x75b1,0x75c1,0x75d1,0x75e1
  .hword 0x75f1,0x0003,0x6fd8,0x0008,0x6fe8,0x6ff7,0x7001,0x7017
  .hword 0x7021,0x7038,0x7048,0x7051,0x7061,0x7071,0x7081,0x7091
  .hword 0x0003,0x70af,0x70b8,0x70c7,0x70d1,0x70e7,0x70f1,0x7108
  .hword 0x7118,0x7121,0x7131,0x7141,0x7151,0x7161,0x0003,0x717f
  .hword 0x7188,0x7197,0x71a1,0x71b7,0x71c1,0x71d8,0x71e8,0x71f1
  .hword 0x7201,0x7211,0x7221,0x7231,0x0003,0x724f,0x7258,0x7267
  .hword 0x7271,0x7287,0x7291,0x72a8,0x72b8,0x72c1,0x72d1,0x72e1
  .hword 0x72f1,0x7301,0x0003,0x7318,0x7327,0x7631,0x7348,0x7357
  .hword 0x7361,0x7377,0x7381,0x7398,0x73a8,0x73b1,0x73c1,0x0006
  .hword 0x73d8,0x73e8,0x73f8,0x7407,0x7411,0x7427,0x7431,0x7448
  .hword 0x7458,0x7461,0x7471,0x0006,0x7488,0x7498,0x74a8,0x74b7
  .hword 0x74c1,0x74d7,0x74e1,0x74f8,0x7508,0x7511,0x7521,0x0006
  .hword 0x753f,0x7548,0x7557,0x7561,0x7577,0x7581,0x7598,0x75a8
  .hword 0x75b1,0x75c1,0x75d1,0x75e1,0x75f1,0x0003,0x6fd8,0x0008
  .hword 0x6fe8,0x6ff7,0x7001,0x7017,0x7021,0x7038,0x7048,0x7051
  .hword 0x7061,0x7071,0x7081,0x7091,0x0003,0x70af,0x70b8,0x70c7
  .hword 0x70d1,0x70e7,0x70f1,0x7108,0x7118,0x7121,0x7131,0x7141
  .hword 0x7151,0x7161,0x0003,0x717f,0x7188,0x7197,0x71a1,0x71b7
  .hword 0x71c1,0x71d8,0x71e8,0x71f1,0x7201,0x7211,0x7221,0x7231
  .hword 0x0003,0x724f,0x7258,0x7267,0x7271,0x7287,0x7291,0x72a8
  .hword 0x72b8,0x72c1,0x72d1,0x72e1,0x72f1,0x7301,0x0003,0x7318
  .hword 0x7327,0x7641,0x7348,0x7357,0x7361,0x7377,0x7381,0x7398
  .hword 0x73a8,0x73b1,0x73c1,0x0006,0x73d8,0x73e8,0x73f8,0x7407
  .hword 0x7411,0x7427,0x7431,0x7448,0x7458,0x7461,0x7471,0x0006
  .hword 0x7488,0x7498,0x74a8,0x74b7,0x74c1,0x74d7,0x74e1,0x74f8
  .hword 0x7508,0x7511,0x7521,0x0006,0x753f,0x7548,0x7557,0x7561
  .hword 0x7577,0x7581,0x7598,0x75a8,0x75b1,0x75c1,0x75d1,0x75e1
  .hword 0x75f1,0x0003,0x6fd8,0x0008,0x6fe8,0x6ff7,0x7001,0x7017
  .hword 0x7021,0x7038,0x7048,0x7051,0x7061,0x7071,0x7081,0x7091
  .hword 0x0003,0x70af,0x70b8,0x70c7,0x70d1,0x70e7,0x70f1,0x7108
  .hword 0x7118,0x7121,0x7131,0x7141,0x7151,0x7161,0x0003,0x717f
  .hword 0x7188,0x7197,0x71a1,0x71b7,0x71c1,0x71d8,0x71e8,0x71f1
  .hword 0x7201,0x7211,0x7221,0x7231,0x0003,0x724f,0x7258,0x7267
  .hword 0x7271,0x7287,0x7291,0x72a8,0x72b8,0x72c1,0x72d1,0x72e1
  .hword 0x72f1,0x7301,0x0003,0x7318,0x7327,0x7651,0x7348,0x7357
  .hword 0x7361,0x7377,0x7381,0x7398,0x73a8,0x73b1,0x73c1,0x0006
  .hword 0x73d8,0x73e8,0x73f8,0x7407,0x7411,0x7427,0x7431,0x7448
  .hword 0x7458,0x7461,0x7471,0x0006,0x7488,0x7498,0x74a8,0x74b7
  .hword 0x74c1,0x74d7,0x74e1,0x74f8,0x7508,0x7511,0x7521,0x0006
  .hword 0x753f,0x7548,0x7557,0x7561,0x7577,0x7581,0x7598,0x75a8
  .hword 0x75b1,0x75c1,0x75d1,0x75e1,0x75f1,0x0003,0x6fd8,0x0008
  .hword 0x6fe8,0x6ff7,0x7001,0x7017,0x7021,0x7038,0x7048,0x7051
  .hword 0x7061,0x7071,0x7081,0x7091,0x0003,0x70af,0x70b8,0x70c7
  .hword 0x70d1,0x70e7,0x70f1,0x7108,0x7118,0x7121,0x7131,0x7141
  .hword 0x7151,0x7161,0x0003,0x717f,0x7188,0x7197,0x71a1,0x71b7
  .hword 0x71c1,0x71d8,0x71e8,0x71f1,0x7201,0x7211,0x7221,0x7231
  .hword 0x0003,0x724f,0x7258,0x7267,0x7271,0x7287,0x7291,0x72a8
  .hword 0x72b8,0x72c1,0x72d1,0x72e1,0x72f1,0x7301,0x0003,0x7318
  .hword 0x7661,0x7671,0x7681,0x7691,0x76a1,0x76b1,0x76c1,0x76d1
  .hword 0x7348,0x7357,0x7361,0x7377,0x7381,0x7398,0x73a8,0x73b1
  .hword 0x73c1,0x0006,0x73d8,0x73e8,0x73f8,0x7407,0x7411,0x7427
  .hword 0x7431,0x7448,0x7458,0x7461,0x7471,0x0006,0x7488,0x7498
  .hword 0x74a8,0x74b7,0x74c1,0x74d7,0x74e1,0x74f8,0x7508,0x7511
  .hword 0x7521,0x0006,0x753f,0x7548,0x7557,0x7561,0x7577,0x7581
  .hword 0x7598,0x75a8,0x75b1,0x75c1,0x75d1,0x75e1,0x75f1,0x0003
  .hword 0x76e8,0x76f8,0x7708,0x7718,0x7728,0x7738,0x7748,0x7758
  .hword 0x7768,0x7778,0x7788,0x7798,0x77a8,0x77b8,0x77c8,0x77d8
  .hword 0x77e8,0x77f8,0x7808,0x7818,0x7828,0x7838,0x7848,0x7858
  .hword 0x000f,0x7868,0x7877,0x7881,0x7897,0x78a1,0x78b8,0x78c8
  .hword 0x78d1,0x78e1,0x0006,0x78f8,0x7908,0x7918,0x7928,0x7938
  .hword 0x7948,0x7958,0x7968,0x7978,0x7988,0x7998,0x79a8,0x79b8
  .hword 0x79c8,0x79d8,0x79e8,0x79f8,0x7a08,0x7a18,0x7a28,0x7a38
  .hword 0x7a48,0x7a58,0x7a68,0x000f,0x7a78,0x7a87,0x7a91,0x7aa7
  .hword 0x7ab1,0x7ac8,0x7ad8,0x7ae1,0x7af1,0x0006,0x7b08,0x7b18
  .hword 0x7b28,0x7b38,0x7728,0x7738,0x7748,0x7758,0x7b48,0x7b58
  .hword 0x7b68,0x7b78,0x77a8,0x77b8,0x77c8,0x77d8,0x7b88,0x7b98
  .hword 0x7ba8,0x7bb8,0x7828,0x7838,0x7848,0x7858,0x000f,0x7bc8
  .hword 0x7bd7,0x7be1,0x7bf7,0x7c01,0x7c18,0x7c28,0x7c31,0x7c41
  .hword 0x0006,0x7c58,0x7c68,0x7c78,0x7c88,0x7938,0x7948,0x7958
  .hword 0x7968,0x7c98,0x7ca8,0x7cb8,0x7cc8,0x79b8,0x79c8,0x79d8
  .hword 0x79e8,0x7cd8,0x7ce8,0x7cf8,0x7d08,0x7a38,0x7a48,0x7a58
  .hword 0x7a68,0x000f,0x7d18,0x7d27,0x7d31,0x7d47,0x7d51,0x7d68
  .hword 0x7d78,0x7d81,0x7d91,0x0006,0x7b08,0x7b18,0x7da8,0x7b38
  .hword 0x7728,0x7738,0x7748,0x7758,0x7b48,0x7b58,0x7db8,0x7b78
  .hword 0x77a8,0x77b8,0x77c8,0x77d8,0x7b88,0x7b98,0x7dc8,0x7bb8
  .hword 0x7828,0x7838,0x7848,0x7858,0x000f,0x7dd8,0x7de7,0x7df1
  .hword 0x7e07,0x7e11,0x7e28,0x7e38,0x7e41,0x7e51,0x0006,0x7c58
  .hword 0x7c68,0x7e68,0x7c88,0x7938,0x7948,0x7958,0x7968,0x7c98
  .hword 0x7ca8,0x7e78,0x7cc8,0x79b8,0x79c8,0x79d8,0x79e8,0x7cd8
  .hword 0x7ce8,0x7e88,0x7d08,0x7a38,0x7a48,0x7a58,0x7a68,0x000f
  .hword 0x7e98,0x7ea7,0x7eb1,0x7ec7,0x7ed1,0x7ee8,0x7ef8,0x7f01
  .hword 0x7f11,0x0006,0x7b08,0x7b18,0x7da8,0x7b38,0x7728,0x7738
  .hword 0x7748,0x7758,0x7b48,0x7b58,0x7db8,0x7b78,0x77a8,0x77b8
  .hword 0x77c8,0x77d8,0x7b88,0x7b98,0x7dc8,0x7bb8,0x7828,0x7838
  .hword 0x7848,0x7858,0x000f,0x7f28,0x7f37,0x7f41,0x7f57,0x7f61
  .hword 0x7f78,0x7f88,0x7f91,0x7fa1,0x0006,0x7c58,0x7c68,0x7e68
  .hword 0x7c88,0x7938,0x7948,0x7958,0x7968,0x7c98,0x7ca8,0x7e78
  .hword 0x7cc8,0x79b8,0x79c8,0x79d8,0x79e8,0x7cd8,0x7ce8,0x7e88
  .hword 0x7d08,0x7a38,0x7a48,0x7a58,0x7a68,0x000f,0x7fb8,0x7fc7
  .hword 0x7fd1,0x7fe7,0x7ff1,0x8008,0x8018,0x8021,0x8031,0x0006
  .hword 0x7b08,0x7b18,0x7da8,0x7b38,0x7728,0x7738,0x7748,0x7758
  .hword 0x7b48,0x7b58,0x7db8,0x7b78,0x77a8,0x77b8,0x77c8,0x77d8
  .hword 0x7b88,0x7b98,0x7dc8,0x7bb8,0x7828,0x7838,0x7848,0x7858
  .hword 0x0000,0x0040,0x7c58,0x7c68,0x7e68,0x7c88,0x7938,0x7948
  .hword 0x7958,0x7968,0x7c98,0x7ca8,0x7e78,0x7cc8,0x79b8,0x79c8
  .hword 0x79d8,0x79e8,0x7cd8,0x7ce8,0x7e88,0x7d08,0x7a38,0x7a48
  .hword 0x7a58,0x7a68,0x0000,0x0040,0x7b08,0x7b18,0x7da8,0x7b38
  .hword 0x7728,0x7738,0x7748,0x7758,0x7b48,0x7b58,0x7db8,0x7b78
  .hword 0x77a8,0x77b8,0x77c8,0x77d8,0x7b88,0x7b98,0x7dc8,0x7bb8
  .hword 0x7828,0x7838,0x7848,0x7858,0x0000,0x0040,0x7c58,0x7c68
  .hword 0x7e68,0x7c88,0x7938,0x7948,0x7958,0x7968,0x7c98,0x7ca8
  .hword 0x7e78,0x7cc8,0x79b8,0x79c8,0x79d8,0x79e8,0x7cd8,0x7ce8
  .hword 0x7e88,0x7d08,0x7a38,0x7a48,0x7a58,0x7a68,0x0000,0x0040
  .hword 0x7b08,0x7b18,0x7da8,0x7b38,0x7728,0x7738,0x7748,0x7758
  .hword 0x7b48,0x7b58,0x7db8,0x7b78,0x77a8,0x77b8,0x77c8,0x77d8
  .hword 0x7b88,0x7b98,0x7dc8,0x7bb8,0x7828,0x7838,0x7848,0x7858
  .hword 0x0000,0x0040,0x7c58,0x7c68,0x7e68,0x7c88,0x7938,0x7948
  .hword 0x7958,0x7968,0x7c98,0x7ca8,0x7e78,0x7cc8,0x79b8,0x79c8
  .hword 0x79d8,0x79e8,0x7cd8,0x7ce8,0x7e88,0x7d08,0x7a38,0x7a48
  .hword 0x7a58,0x7a68,0x0000,0x0040,0x7b08,0x7b18,0x7da8,0x7b38
  .hword 0x7728,0x7738,0x7748,0x7758,0x7b48,0x7b58,0x7db8,0x7b78
  .hword 0x77a8,0x77b8,0x77c8,0x77d8,0x7b88,0x7b98,0x7dc8,0x7bb8
  .hword 0x7828,0x7838,0x7848,0x7858,0x0000,0x0040,0x7c58,0x7c68
  .hword 0x7e68,0x7c88,0x7938,0x7948,0x7958,0x7968,0x7c98,0x7ca8
  .hword 0x7e78,0x7cc8,0x79b8,0x79c8,0x79d8,0x79e8,0x7cd8,0x7ce8
  .hword 0x7e88,0x7d08,0x7a38,0x7a48,0x7a58,0x7a68,0x0000,0x0040

  .rept 0x1b5
  .long 0,0,0,0,0,0,0,0
  .endr

