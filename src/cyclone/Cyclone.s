
;@ Dave's Cyclone 68000 Emulator v0.084 - Assembler Output

;@ (c) Copyright 2003 Dave, All rights reserved.
;@ Cyclone 68000 is free for non-commercial use.

;@ For commercial use, separate licencing terms must be obtained.

  .global CycloneRun
  .global CycloneVer
CycloneVer: .long 0x0084

;@ --------------------------- Framework --------------------------
CycloneRun:
  stmdb sp!,{r4-r11,lr}
  mov r7,r0          ;@ r7 = Pointer to Cpu Context
                     ;@ r0-3 = Temporary registers
  ldrb r9,[r7,#0x46] ;@ r9 = Flags (NZCV)
  ldr r6,=JumpTab    ;@ r6 = Opcode Jump table
  ldr r5,[r7,#0x5c]  ;@ r5 = Cycles
  ldr r4,[r7,#0x40]  ;@ r4 = Current PC + Memory Base
                     ;@ r8 = Current Opcode
  mov r9,r9,lsl #28  ;@ r9 = Flags 0xf0000000, cpsr format
                     ;@ r10 = Source value / Memory Base

;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

;@ Check if our processor is in stopped state
  ldr r0,[r7,#0x58]
  tst r0,r0 ;@ stopped?
  movne r0,#0
  strne r0,[r7,#0x5C]  ;@ eat all cycles
  ldmneia sp!,{r4-r11,pc} ;@ we are stopped, do nothing!
;@ Check if interrupt used up all the cycles:
  subs r5,r5,#0
  blt CycloneEndNoBack
  ldrh r8,[r4],#2 ;@ Fetch first opcode
  ldr pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  .ltorg

;@ We come back here after execution
CycloneEnd:
  sub r4,r4,#2
CycloneEndNoBack:
  mov r9,r9,lsr #28
  str r4,[r7,#0x40]  ;@ Save Current PC + Memory Base
  str r5,[r7,#0x5c]  ;@ Save Cycles
  strb r9,[r7,#0x46] ;@ Save Flags (NZCV)
  ldmia sp!,{r4-r11,pc}

;@ DoInterrupt - r0=IRQ number
DoInterrupt:

  ldrb r1,[r7,#0x44] ;@ Get SR high: T_S__III
  and r1,r1,#7 ;@ Get interrupt mask
  cmp r0,#6 ;@ irq>6 ?
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  movle pc,lr ;@ irq<=6 and mask, not allowed

  stmdb sp!,{lr} ;@ Push ARM return address
;@ Get IRQ Vector address:
  mov r0,r0,asl #2
  add r0,r0,#0x60
  bl Exception
  ldrb r0,[r7,#0x47] ;@ IRQ
  orr r1,r0,#0x20 ;@ Supervisor mode + IRQ number
  strb r1,[r7,#0x44] ;@ Put SR high

;@ Clear irq:
  ldr r11,[r7,#0x54] ;@ IrqCallback
  tst r11,r11
  movne lr,pc
  movne pc,r11 ;@ call IrqCallback if it is defined
  moveq r0,#0
  strb r0,[r7,#0x47]
;@ Clear stopped states:
  mov r0,#0
  str r0,[r7,#0x58]
  sub r5,r5,#46 ;@ Subtract cycles
  ldmia sp!,{pc} ;@ Return

Exception:

  stmdb sp!,{lr} ;@ Preserve ARM return address
  ;@ Cause an Exception - Vector address in r0
  mov r11,r0
;@ swap OSP <-> A7?
  ldrb r0,[r7,#0x44] ;@ Get SR high
  tst r0,#0x20
  bne no_sp_swap
;@ swap OSP and A7:
  ldr r0,[r7,#0x3C] ;@ Get A7
  ldr r1,[r7,#0x48] ;@ Get OSP
  str r1,[r7,#0x3C]
  str r0,[r7,#0x48]
no_sp_swap:
  ldr r10,[r7,#0x60] ;@ Get Memory base
  sub r1,r4,r10 ;@ r1 = Old PC
;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Push SR:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  ldr r0,[r7,#0x3c]
  sub r0,r0,#2 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  mov r0,r11
;@ Read IRQ Vector:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  add r0,r0,r10 ;@ r0 = Memory Base + New PC
  mov lr,pc
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrb r0,[r7,#0x44] ;@ Get SR high
  orr r0,r0,#0x20 ;@ set supervisor mode
  strb r0,[r7,#0x44]
  ldmia sp!,{pc} ;@ Return

;@ ---------------------------- Opcodes ---------------------------
Op____: ;@ Called if an opcode is not recognised
  ldr r1,[r7,#0x50] ;@ get invalid op call back
  tst r1,r1         ;@ see if address present
  movne r0,r8       ;@ get invalid opcode
  movne lr,pc       ;@ if so call function
  movne pc,r1
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op__al: ;@ Unrecognised a-line opcode
  sub r4,r4,#2
  mov r0,#0x28
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op__fl: ;@ Unrecognised f-line opcode
  sub r4,r4,#2
  mov r0,#0x2C
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0000] ori.b #$33, d0 uses Op0000 ----------
Op0000:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsb r0,[r7,r11]
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0010] ori.b #$33, (a0) uses Op0010 ----------
Op0010:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0018] ori.b #$33, (a0)+ uses Op0018 ----------
Op0018:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [001f] ori.b #$33, (a7)+ uses Op001f ----------
Op001f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0020] ori.b #$33, -(a0) uses Op0020 ----------
Op0020:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0027] ori.b #$33, -(a7) uses Op0027 ----------
Op0027:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0028] ori.b #$33, ($3333,a0) uses Op0028 ----------
Op0028:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0030] ori.b #$33, ($33,a0,d3.w*2) uses Op0030 ----------
Op0030:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0038] ori.b #$33, $3333.w uses Op0038 ----------
Op0038:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0039] ori.b #$33, $33333333.l uses Op0039 ----------
Op0039:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [003a] ori.b #$33, ($3333,pc); =3337 uses Op003a ----------
Op003a:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [003b] ori.b #$33, ($33,pc,d3.w*2); =37 uses Op003b ----------
Op003b:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [003c] ori.b #$33, ccr uses Op003c ----------
Op003c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r10:
  mov r10,r0,asl #0

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  orr r0,r1,r10
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0040] ori.w #$3333, d0 uses Op0040 ----------
Op0040:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsh r0,[r7,r11]
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0050] ori.w #$3333, (a0) uses Op0050 ----------
Op0050:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0058] ori.w #$3333, (a0)+ uses Op0058 ----------
Op0058:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [005f] ori.w #$3333, (a7)+ uses Op005f ----------
Op005f:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0060] ori.w #$3333, -(a0) uses Op0060 ----------
Op0060:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0067] ori.w #$3333, -(a7) uses Op0067 ----------
Op0067:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0068] ori.w #$3333, ($3333,a0) uses Op0068 ----------
Op0068:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0070] ori.w #$3333, ($33,a0,d3.w*2) uses Op0070 ----------
Op0070:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0078] ori.w #$3333, $3333.w uses Op0078 ----------
Op0078:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0079] ori.w #$3333, $33333333.l uses Op0079 ----------
Op0079:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [007a] ori.w #$3333, ($3333,pc); =3337 uses Op007a ----------
Op007a:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [007b] ori.w #$3333, ($33,pc,d3.w*2); =37 uses Op007b ----------
Op007b:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [007c] ori.w #$3333, sr uses Op007c ----------
Op007c:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode007c ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r10:
  mov r10,r0,asl #0

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  orr r0,r1,r10
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap007c
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap007c:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode007c:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0080] ori.l #$33333333, d0 uses Op0080 ----------
Op0080:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0090] ori.l #$33333333, (a0) uses Op0090 ----------
Op0090:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0098] ori.l #$33333333, (a0)+ uses Op0098 ----------
Op0098:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [009f] ori.l #$33333333, (a7)+ uses Op009f ----------
Op009f:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00a0] ori.l #$33333333, -(a0) uses Op00a0 ----------
Op00a0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00a7] ori.l #$33333333, -(a7) uses Op00a7 ----------
Op00a7:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00a8] ori.l #$33333333, ($3333,a0) uses Op00a8 ----------
Op00a8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00b0] ori.l #$33333333, ($33,a0,d3.w*2) uses Op00b0 ----------
Op00b0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00b8] ori.l #$33333333, $3333.w uses Op00b8 ----------
Op00b8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00b9] ori.l #$33333333, $33333333.l uses Op00b9 ----------
Op00b9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00ba] ori.l #$33333333, ($3333,pc); =3339 uses Op00ba ----------
Op00ba:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00bb] ori.l #$33333333, ($33,pc,d3.w*2); =39 uses Op00bb ----------
Op00bb:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Do arithmetic:
  orr r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0100] btst d0, d0 uses Op0100 ----------
Op0100:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#31 ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0108] movep.w ($3333,a0), d0 uses Op0108 ----------
Op0108:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x0007
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r0,r0,lsr #24
  mov r11,r0,lsl #8 ;@ save first byte from mem
  add r10,r10,#2
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r0,r0,lsr #24
  orr r11,r11,r0 ;@ second byte
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r11 into register[r0]:
  str r11,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0110] btst d0, (a0) uses Op0110 ----------
Op0110:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0118] btst d0, (a0)+ uses Op0118 ----------
Op0118:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [011f] btst d0, (a7)+ uses Op011f ----------
Op011f:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0120] btst d0, -(a0) uses Op0120 ----------
Op0120:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0127] btst d0, -(a7) uses Op0127 ----------
Op0127:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0128] btst d0, ($3333,a0) uses Op0128 ----------
Op0128:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0130] btst d0, ($33,a0,d3.w*2) uses Op0130 ----------
Op0130:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0138] btst d0, $3333.w uses Op0138 ----------
Op0138:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0139] btst d0, $33333333.l uses Op0139 ----------
Op0139:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [013a] btst d0, ($3333,pc); =3335 uses Op013a ----------
Op013a:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [013b] btst d0, ($33,pc,d3.w*2); =35 uses Op013b ----------
Op013b:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [013c] btst d0, #$33 uses Op013c ----------
Op013c:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '#$33' into r11:
  ldrsb r11,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r11) into r0:
  mov r0,r11,asl #0

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0140] bchg d0, d0 uses Op0140 ----------
Op0140:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#31 ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0148] movep.l ($3333,a0), d0 uses Op0148 ----------
Op0148:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x0007
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r0,r0,lsr #24
  mov r11,r0,lsl #8 ;@ save first byte from mem
  add r10,r10,#2
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r0,r0,lsr #24
  orr r11,r11,r0 ;@ second byte
  mov r11,r11,lsl #16
  add r10,r10,#2
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r0,r0,lsr #24
  orr r11,r11,r0,lsl #8 ;@ third byte
  add r10,r10,#2
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r0,r0,lsr #24
  orr r11,r11,r0 ;@ fourth byte
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r11 into register[r0]:
  str r11,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0150] bchg d0, (a0) uses Op0150 ----------
Op0150:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0158] bchg d0, (a0)+ uses Op0158 ----------
Op0158:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [015f] bchg d0, (a7)+ uses Op015f ----------
Op015f:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0160] bchg d0, -(a0) uses Op0160 ----------
Op0160:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0167] bchg d0, -(a7) uses Op0167 ----------
Op0167:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0168] bchg d0, ($3333,a0) uses Op0168 ----------
Op0168:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0170] bchg d0, ($33,a0,d3.w*2) uses Op0170 ----------
Op0170:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0178] bchg d0, $3333.w uses Op0178 ----------
Op0178:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0179] bchg d0, $33333333.l uses Op0179 ----------
Op0179:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [017a] bchg d0, ($3333,pc); =3335 uses Op017a ----------
Op017a:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [017b] bchg d0, ($33,pc,d3.w*2); =35 uses Op017b ----------
Op017b:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0180] bclr d0, d0 uses Op0180 ----------
Op0180:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#31 ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0188] movep.w d0, ($3333,a0) uses Op0188 ----------
Op0188:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x0007
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r11:
  ldr r11,[r7,r0,lsl #2]

  mov r1,r11,lsr #8 ;@ first or third byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  add r10,r10,#2
  mov r1,r11
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0190] bclr d0, (a0) uses Op0190 ----------
Op0190:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0198] bclr d0, (a0)+ uses Op0198 ----------
Op0198:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [019f] bclr d0, (a7)+ uses Op019f ----------
Op019f:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01a0] bclr d0, -(a0) uses Op01a0 ----------
Op01a0:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01a7] bclr d0, -(a7) uses Op01a7 ----------
Op01a7:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01a8] bclr d0, ($3333,a0) uses Op01a8 ----------
Op01a8:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01b0] bclr d0, ($33,a0,d3.w*2) uses Op01b0 ----------
Op01b0:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01b8] bclr d0, $3333.w uses Op01b8 ----------
Op01b8:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01b9] bclr d0, $33333333.l uses Op01b9 ----------
Op01b9:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01ba] bclr d0, ($3333,pc); =3335 uses Op01ba ----------
Op01ba:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01bb] bclr d0, ($33,pc,d3.w*2); =35 uses Op01bb ----------
Op01bb:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01c0] bset d0, d0 uses Op01c0 ----------
Op01c0:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#31 ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01c8] movep.l d0, ($3333,a0) uses Op01c8 ----------
Op01c8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x0007
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r11:
  ldr r11,[r7,r0,lsl #2]

  mov r1,r11,lsr #24 ;@ first byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  add r10,r10,#2
  mov r1,r11,lsr #16 ;@ second byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  add r10,r10,#2
  mov r1,r11,lsr #8 ;@ first or third byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  add r10,r10,#2
  mov r1,r11
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01d0] bset d0, (a0) uses Op01d0 ----------
Op01d0:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01d8] bset d0, (a0)+ uses Op01d8 ----------
Op01d8:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01df] bset d0, (a7)+ uses Op01df ----------
Op01df:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01e0] bset d0, -(a0) uses Op01e0 ----------
Op01e0:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01e7] bset d0, -(a7) uses Op01e7 ----------
Op01e7:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01e8] bset d0, ($3333,a0) uses Op01e8 ----------
Op01e8:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01f0] bset d0, ($33,a0,d3.w*2) uses Op01f0 ----------
Op01f0:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01f8] bset d0, $3333.w uses Op01f8 ----------
Op01f8:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01f9] bset d0, $33333333.l uses Op01f9 ----------
Op01f9:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01fa] bset d0, ($3333,pc); =3335 uses Op01fa ----------
Op01fa:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01fb] bset d0, ($33,pc,d3.w*2); =35 uses Op01fb ----------
Op01fb:
  mov r10,#1
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7  ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0200] andi.b #$33, d0 uses Op0200 ----------
Op0200:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsb r0,[r7,r11]
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0210] andi.b #$33, (a0) uses Op0210 ----------
Op0210:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0218] andi.b #$33, (a0)+ uses Op0218 ----------
Op0218:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [021f] andi.b #$33, (a7)+ uses Op021f ----------
Op021f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0220] andi.b #$33, -(a0) uses Op0220 ----------
Op0220:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0227] andi.b #$33, -(a7) uses Op0227 ----------
Op0227:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0228] andi.b #$33, ($3333,a0) uses Op0228 ----------
Op0228:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0230] andi.b #$33, ($33,a0,d3.w*2) uses Op0230 ----------
Op0230:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0238] andi.b #$33, $3333.w uses Op0238 ----------
Op0238:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0239] andi.b #$33, $33333333.l uses Op0239 ----------
Op0239:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [023a] andi.b #$33, ($3333,pc); =3337 uses Op023a ----------
Op023a:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [023b] andi.b #$33, ($33,pc,d3.w*2); =37 uses Op023b ----------
Op023b:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [023c] andi.b #$33, ccr uses Op023c ----------
Op023c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r10:
  mov r10,r0,asl #0

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  and r0,r1,r10
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0240] andi.w #$3333, d0 uses Op0240 ----------
Op0240:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsh r0,[r7,r11]
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0250] andi.w #$3333, (a0) uses Op0250 ----------
Op0250:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0258] andi.w #$3333, (a0)+ uses Op0258 ----------
Op0258:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [025f] andi.w #$3333, (a7)+ uses Op025f ----------
Op025f:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0260] andi.w #$3333, -(a0) uses Op0260 ----------
Op0260:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0267] andi.w #$3333, -(a7) uses Op0267 ----------
Op0267:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0268] andi.w #$3333, ($3333,a0) uses Op0268 ----------
Op0268:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0270] andi.w #$3333, ($33,a0,d3.w*2) uses Op0270 ----------
Op0270:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0278] andi.w #$3333, $3333.w uses Op0278 ----------
Op0278:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0279] andi.w #$3333, $33333333.l uses Op0279 ----------
Op0279:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [027a] andi.w #$3333, ($3333,pc); =3337 uses Op027a ----------
Op027a:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [027b] andi.w #$3333, ($33,pc,d3.w*2); =37 uses Op027b ----------
Op027b:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [027c] andi.w #$3333, sr uses Op027c ----------
Op027c:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode027c ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r10:
  mov r10,r0,asl #0

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  and r0,r1,r10
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap027c
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap027c:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode027c:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0280] andi.l #$33333333, d0 uses Op0280 ----------
Op0280:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0290] andi.l #$33333333, (a0) uses Op0290 ----------
Op0290:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0298] andi.l #$33333333, (a0)+ uses Op0298 ----------
Op0298:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [029f] andi.l #$33333333, (a7)+ uses Op029f ----------
Op029f:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02a0] andi.l #$33333333, -(a0) uses Op02a0 ----------
Op02a0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02a7] andi.l #$33333333, -(a7) uses Op02a7 ----------
Op02a7:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02a8] andi.l #$33333333, ($3333,a0) uses Op02a8 ----------
Op02a8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02b0] andi.l #$33333333, ($33,a0,d3.w*2) uses Op02b0 ----------
Op02b0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02b8] andi.l #$33333333, $3333.w uses Op02b8 ----------
Op02b8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02b9] andi.l #$33333333, $33333333.l uses Op02b9 ----------
Op02b9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02ba] andi.l #$33333333, ($3333,pc); =3339 uses Op02ba ----------
Op02ba:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02bb] andi.l #$33333333, ($33,pc,d3.w*2); =39 uses Op02bb ----------
Op02bb:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Do arithmetic:
  and r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0400] subi.b #$33, d0 uses Op0400 ----------
Op0400:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsb r0,[r7,r11]
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0410] subi.b #$33, (a0) uses Op0410 ----------
Op0410:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0418] subi.b #$33, (a0)+ uses Op0418 ----------
Op0418:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [041f] subi.b #$33, (a7)+ uses Op041f ----------
Op041f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0420] subi.b #$33, -(a0) uses Op0420 ----------
Op0420:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0427] subi.b #$33, -(a7) uses Op0427 ----------
Op0427:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0428] subi.b #$33, ($3333,a0) uses Op0428 ----------
Op0428:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0430] subi.b #$33, ($33,a0,d3.w*2) uses Op0430 ----------
Op0430:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0438] subi.b #$33, $3333.w uses Op0438 ----------
Op0438:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0439] subi.b #$33, $33333333.l uses Op0439 ----------
Op0439:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [043a] subi.b #$33, ($3333,pc); =3337 uses Op043a ----------
Op043a:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [043b] subi.b #$33, ($33,pc,d3.w*2); =37 uses Op043b ----------
Op043b:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0440] subi.w #$3333, d0 uses Op0440 ----------
Op0440:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsh r0,[r7,r11]
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0450] subi.w #$3333, (a0) uses Op0450 ----------
Op0450:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0458] subi.w #$3333, (a0)+ uses Op0458 ----------
Op0458:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [045f] subi.w #$3333, (a7)+ uses Op045f ----------
Op045f:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0460] subi.w #$3333, -(a0) uses Op0460 ----------
Op0460:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0467] subi.w #$3333, -(a7) uses Op0467 ----------
Op0467:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0468] subi.w #$3333, ($3333,a0) uses Op0468 ----------
Op0468:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0470] subi.w #$3333, ($33,a0,d3.w*2) uses Op0470 ----------
Op0470:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0478] subi.w #$3333, $3333.w uses Op0478 ----------
Op0478:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0479] subi.w #$3333, $33333333.l uses Op0479 ----------
Op0479:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [047a] subi.w #$3333, ($3333,pc); =3337 uses Op047a ----------
Op047a:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [047b] subi.w #$3333, ($33,pc,d3.w*2); =37 uses Op047b ----------
Op047b:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0480] subi.l #$33333333, d0 uses Op0480 ----------
Op0480:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0490] subi.l #$33333333, (a0) uses Op0490 ----------
Op0490:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0498] subi.l #$33333333, (a0)+ uses Op0498 ----------
Op0498:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [049f] subi.l #$33333333, (a7)+ uses Op049f ----------
Op049f:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04a0] subi.l #$33333333, -(a0) uses Op04a0 ----------
Op04a0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04a7] subi.l #$33333333, -(a7) uses Op04a7 ----------
Op04a7:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04a8] subi.l #$33333333, ($3333,a0) uses Op04a8 ----------
Op04a8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04b0] subi.l #$33333333, ($33,a0,d3.w*2) uses Op04b0 ----------
Op04b0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04b8] subi.l #$33333333, $3333.w uses Op04b8 ----------
Op04b8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04b9] subi.l #$33333333, $33333333.l uses Op04b9 ----------
Op04b9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04ba] subi.l #$33333333, ($3333,pc); =3339 uses Op04ba ----------
Op04ba:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04bb] subi.l #$33333333, ($33,pc,d3.w*2); =39 uses Op04bb ----------
Op04bb:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Do arithmetic:
  subs r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0600] addi.b #$33, d0 uses Op0600 ----------
Op0600:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsb r0,[r7,r11]
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0610] addi.b #$33, (a0) uses Op0610 ----------
Op0610:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0618] addi.b #$33, (a0)+ uses Op0618 ----------
Op0618:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [061f] addi.b #$33, (a7)+ uses Op061f ----------
Op061f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0620] addi.b #$33, -(a0) uses Op0620 ----------
Op0620:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0627] addi.b #$33, -(a7) uses Op0627 ----------
Op0627:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0628] addi.b #$33, ($3333,a0) uses Op0628 ----------
Op0628:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0630] addi.b #$33, ($33,a0,d3.w*2) uses Op0630 ----------
Op0630:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0638] addi.b #$33, $3333.w uses Op0638 ----------
Op0638:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0639] addi.b #$33, $33333333.l uses Op0639 ----------
Op0639:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [063a] addi.b #$33, ($3333,pc); =3337 uses Op063a ----------
Op063a:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [063b] addi.b #$33, ($33,pc,d3.w*2); =37 uses Op063b ----------
Op063b:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0640] addi.w #$3333, d0 uses Op0640 ----------
Op0640:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsh r0,[r7,r11]
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0650] addi.w #$3333, (a0) uses Op0650 ----------
Op0650:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0658] addi.w #$3333, (a0)+ uses Op0658 ----------
Op0658:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [065f] addi.w #$3333, (a7)+ uses Op065f ----------
Op065f:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0660] addi.w #$3333, -(a0) uses Op0660 ----------
Op0660:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0667] addi.w #$3333, -(a7) uses Op0667 ----------
Op0667:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0668] addi.w #$3333, ($3333,a0) uses Op0668 ----------
Op0668:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0670] addi.w #$3333, ($33,a0,d3.w*2) uses Op0670 ----------
Op0670:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0678] addi.w #$3333, $3333.w uses Op0678 ----------
Op0678:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0679] addi.w #$3333, $33333333.l uses Op0679 ----------
Op0679:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [067a] addi.w #$3333, ($3333,pc); =3337 uses Op067a ----------
Op067a:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [067b] addi.w #$3333, ($33,pc,d3.w*2); =37 uses Op067b ----------
Op067b:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0680] addi.l #$33333333, d0 uses Op0680 ----------
Op0680:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0690] addi.l #$33333333, (a0) uses Op0690 ----------
Op0690:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0698] addi.l #$33333333, (a0)+ uses Op0698 ----------
Op0698:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [069f] addi.l #$33333333, (a7)+ uses Op069f ----------
Op069f:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06a0] addi.l #$33333333, -(a0) uses Op06a0 ----------
Op06a0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06a7] addi.l #$33333333, -(a7) uses Op06a7 ----------
Op06a7:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06a8] addi.l #$33333333, ($3333,a0) uses Op06a8 ----------
Op06a8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06b0] addi.l #$33333333, ($33,a0,d3.w*2) uses Op06b0 ----------
Op06b0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06b8] addi.l #$33333333, $3333.w uses Op06b8 ----------
Op06b8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06b9] addi.l #$33333333, $33333333.l uses Op06b9 ----------
Op06b9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06ba] addi.l #$33333333, ($3333,pc); =3339 uses Op06ba ----------
Op06ba:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06bb] addi.l #$33333333, ($33,pc,d3.w*2); =39 uses Op06bb ----------
Op06bb:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Do arithmetic:
  adds r1,r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0800] btst #$33, d0 uses Op0800 ----------
Op0800:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0810] btst #$33, (a0) uses Op0810 ----------
Op0810:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0818] btst #$33, (a0)+ uses Op0818 ----------
Op0818:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [081f] btst #$33, (a7)+ uses Op081f ----------
Op081f:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0820] btst #$33, -(a0) uses Op0820 ----------
Op0820:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0827] btst #$33, -(a7) uses Op0827 ----------
Op0827:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0828] btst #$33, ($3333,a0) uses Op0828 ----------
Op0828:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0830] btst #$33, ($33,a0,d3.w*2) uses Op0830 ----------
Op0830:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0838] btst #$33, $3333.w uses Op0838 ----------
Op0838:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0839] btst #$33, $33333333.l uses Op0839 ----------
Op0839:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [083a] btst #$33, ($3333,pc); =3337 uses Op083a ----------
Op083a:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [083b] btst #$33, ($33,pc,d3.w*2); =37 uses Op083b ----------
Op083b:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [083c] btst #$33, #$33 uses Op083c ----------
Op083c:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '#$33' into r11:
  ldrsb r11,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r11) into r0:
  mov r0,r11,asl #0

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0840] bchg #$33, d0 uses Op0840 ----------
Op0840:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0850] bchg #$33, (a0) uses Op0850 ----------
Op0850:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0858] bchg #$33, (a0)+ uses Op0858 ----------
Op0858:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [085f] bchg #$33, (a7)+ uses Op085f ----------
Op085f:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0860] bchg #$33, -(a0) uses Op0860 ----------
Op0860:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0867] bchg #$33, -(a7) uses Op0867 ----------
Op0867:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0868] bchg #$33, ($3333,a0) uses Op0868 ----------
Op0868:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0870] bchg #$33, ($33,a0,d3.w*2) uses Op0870 ----------
Op0870:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0878] bchg #$33, $3333.w uses Op0878 ----------
Op0878:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0879] bchg #$33, $33333333.l uses Op0879 ----------
Op0879:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [087a] bchg #$33, ($3333,pc); =3337 uses Op087a ----------
Op087a:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [087b] bchg #$33, ($33,pc,d3.w*2); =37 uses Op087b ----------
Op087b:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0880] bclr #$33, d0 uses Op0880 ----------
Op0880:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0890] bclr #$33, (a0) uses Op0890 ----------
Op0890:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0898] bclr #$33, (a0)+ uses Op0898 ----------
Op0898:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [089f] bclr #$33, (a7)+ uses Op089f ----------
Op089f:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08a0] bclr #$33, -(a0) uses Op08a0 ----------
Op08a0:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08a7] bclr #$33, -(a7) uses Op08a7 ----------
Op08a7:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08a8] bclr #$33, ($3333,a0) uses Op08a8 ----------
Op08a8:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08b0] bclr #$33, ($33,a0,d3.w*2) uses Op08b0 ----------
Op08b0:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08b8] bclr #$33, $3333.w uses Op08b8 ----------
Op08b8:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08b9] bclr #$33, $33333333.l uses Op08b9 ----------
Op08b9:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08ba] bclr #$33, ($3333,pc); =3337 uses Op08ba ----------
Op08ba:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08bb] bclr #$33, ($33,pc,d3.w*2); =37 uses Op08bb ----------
Op08bb:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08c0] bset #$33, d0 uses Op08c0 ----------
Op08c0:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08d0] bset #$33, (a0) uses Op08d0 ----------
Op08d0:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08d8] bset #$33, (a0)+ uses Op08d8 ----------
Op08d8:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08df] bset #$33, (a7)+ uses Op08df ----------
Op08df:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08e0] bset #$33, -(a0) uses Op08e0 ----------
Op08e0:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08e7] bset #$33, -(a7) uses Op08e7 ----------
Op08e7:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08e8] bset #$33, ($3333,a0) uses Op08e8 ----------
Op08e8:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08f0] bset #$33, ($33,a0,d3.w*2) uses Op08f0 ----------
Op08f0:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08f8] bset #$33, $3333.w uses Op08f8 ----------
Op08f8:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08f9] bset #$33, $33333333.l uses Op08f9 ----------
Op08f9:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08fa] bset #$33, ($3333,pc); =3337 uses Op08fa ----------
Op08fa:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08fb] bset #$33, ($33,pc,d3.w*2); =37 uses Op08fb ----------
Op08fb:
  mov r10,#1

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7 ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a00] eori.b #$33, d0 uses Op0a00 ----------
Op0a00:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsb r0,[r7,r11]
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a10] eori.b #$33, (a0) uses Op0a10 ----------
Op0a10:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a18] eori.b #$33, (a0)+ uses Op0a18 ----------
Op0a18:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a1f] eori.b #$33, (a7)+ uses Op0a1f ----------
Op0a1f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a20] eori.b #$33, -(a0) uses Op0a20 ----------
Op0a20:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a27] eori.b #$33, -(a7) uses Op0a27 ----------
Op0a27:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a28] eori.b #$33, ($3333,a0) uses Op0a28 ----------
Op0a28:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a30] eori.b #$33, ($33,a0,d3.w*2) uses Op0a30 ----------
Op0a30:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a38] eori.b #$33, $3333.w uses Op0a38 ----------
Op0a38:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a39] eori.b #$33, $33333333.l uses Op0a39 ----------
Op0a39:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a3a] eori.b #$33, ($3333,pc); =3337 uses Op0a3a ----------
Op0a3a:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a3b] eori.b #$33, ($33,pc,d3.w*2); =37 uses Op0a3b ----------
Op0a3b:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a3c] eori.b #$33, ccr uses Op0a3c ----------
Op0a3c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r10:
  mov r10,r0,asl #0

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  eor r0,r1,r10
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a40] eori.w #$3333, d0 uses Op0a40 ----------
Op0a40:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsh r0,[r7,r11]
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a50] eori.w #$3333, (a0) uses Op0a50 ----------
Op0a50:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a58] eori.w #$3333, (a0)+ uses Op0a58 ----------
Op0a58:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a5f] eori.w #$3333, (a7)+ uses Op0a5f ----------
Op0a5f:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a60] eori.w #$3333, -(a0) uses Op0a60 ----------
Op0a60:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a67] eori.w #$3333, -(a7) uses Op0a67 ----------
Op0a67:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a68] eori.w #$3333, ($3333,a0) uses Op0a68 ----------
Op0a68:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a70] eori.w #$3333, ($33,a0,d3.w*2) uses Op0a70 ----------
Op0a70:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a78] eori.w #$3333, $3333.w uses Op0a78 ----------
Op0a78:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a79] eori.w #$3333, $33333333.l uses Op0a79 ----------
Op0a79:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a7a] eori.w #$3333, ($3333,pc); =3337 uses Op0a7a ----------
Op0a7a:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a7b] eori.w #$3333, ($33,pc,d3.w*2); =37 uses Op0a7b ----------
Op0a7b:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a7c] eori.w #$3333, sr uses Op0a7c ----------
Op0a7c:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode0a7c ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r10:
  mov r10,r0,asl #0

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

  eor r0,r1,r10
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap0a7c
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap0a7c:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode0a7c:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a80] eori.l #$33333333, d0 uses Op0a80 ----------
Op0a80:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a90] eori.l #$33333333, (a0) uses Op0a90 ----------
Op0a90:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a98] eori.l #$33333333, (a0)+ uses Op0a98 ----------
Op0a98:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a9f] eori.l #$33333333, (a7)+ uses Op0a9f ----------
Op0a9f:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0aa0] eori.l #$33333333, -(a0) uses Op0aa0 ----------
Op0aa0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0aa7] eori.l #$33333333, -(a7) uses Op0aa7 ----------
Op0aa7:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0aa8] eori.l #$33333333, ($3333,a0) uses Op0aa8 ----------
Op0aa8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ab0] eori.l #$33333333, ($33,a0,d3.w*2) uses Op0ab0 ----------
Op0ab0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ab8] eori.l #$33333333, $3333.w uses Op0ab8 ----------
Op0ab8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ab9] eori.l #$33333333, $33333333.l uses Op0ab9 ----------
Op0ab9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0aba] eori.l #$33333333, ($3333,pc); =3339 uses Op0aba ----------
Op0aba:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0abb] eori.l #$33333333, ($33,pc,d3.w*2); =39 uses Op0abb ----------
Op0abb:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Do arithmetic:
  eor r1,r0,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r11):
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c00] cmpi.b #$33, d0 uses Op0c00 ----------
Op0c00:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsb r0,[r7,r11]
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c10] cmpi.b #$33, (a0) uses Op0c10 ----------
Op0c10:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c18] cmpi.b #$33, (a0)+ uses Op0c18 ----------
Op0c18:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c1f] cmpi.b #$33, (a7)+ uses Op0c1f ----------
Op0c1f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c20] cmpi.b #$33, -(a0) uses Op0c20 ----------
Op0c20:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c27] cmpi.b #$33, -(a7) uses Op0c27 ----------
Op0c27:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c28] cmpi.b #$33, ($3333,a0) uses Op0c28 ----------
Op0c28:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c30] cmpi.b #$33, ($33,a0,d3.w*2) uses Op0c30 ----------
Op0c30:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c38] cmpi.b #$33, $3333.w uses Op0c38 ----------
Op0c38:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c39] cmpi.b #$33, $33333333.l uses Op0c39 ----------
Op0c39:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c3a] cmpi.b #$33, ($3333,pc); =3337 uses Op0c3a ----------
Op0c3a:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c3b] cmpi.b #$33, ($33,pc,d3.w*2); =37 uses Op0c3b ----------
Op0c3b:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c3c]  uses Op0c3c ----------
Op0c3c:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:
  mov r10,r10,asl #24

;@ EaCalc : Get '#$33' into r11:
  ldrsb r11,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r11) into r0:
  mov r0,r11,asl #24

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c40] cmpi.w #$3333, d0 uses Op0c40 ----------
Op0c40:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldrsh r0,[r7,r11]
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c50] cmpi.w #$3333, (a0) uses Op0c50 ----------
Op0c50:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c58] cmpi.w #$3333, (a0)+ uses Op0c58 ----------
Op0c58:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c5f] cmpi.w #$3333, (a7)+ uses Op0c5f ----------
Op0c5f:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c60] cmpi.w #$3333, -(a0) uses Op0c60 ----------
Op0c60:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c67] cmpi.w #$3333, -(a7) uses Op0c67 ----------
Op0c67:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c68] cmpi.w #$3333, ($3333,a0) uses Op0c68 ----------
Op0c68:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c70] cmpi.w #$3333, ($33,a0,d3.w*2) uses Op0c70 ----------
Op0c70:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c78] cmpi.w #$3333, $3333.w uses Op0c78 ----------
Op0c78:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c79] cmpi.w #$3333, $33333333.l uses Op0c79 ----------
Op0c79:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c7a] cmpi.w #$3333, ($3333,pc); =3337 uses Op0c7a ----------
Op0c7a:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c7b] cmpi.w #$3333, ($33,pc,d3.w*2); =37 uses Op0c7b ----------
Op0c7b:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c7c]  uses Op0c7c ----------
Op0c7c:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:
  mov r10,r10,asl #16

;@ EaCalc : Get '#$3333' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r11) into r0:
  mov r0,r11,asl #16

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c80] cmpi.l #$33333333, d0 uses Op0c80 ----------
Op0c80:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c90] cmpi.l #$33333333, (a0) uses Op0c90 ----------
Op0c90:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c98] cmpi.l #$33333333, (a0)+ uses Op0c98 ----------
Op0c98:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c9f] cmpi.l #$33333333, (a7)+ uses Op0c9f ----------
Op0c9f:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r11,[r7,r2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ca0] cmpi.l #$33333333, -(a0) uses Op0ca0 ----------
Op0ca0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ca7] cmpi.l #$33333333, -(a7) uses Op0ca7 ----------
Op0ca7:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ca8] cmpi.l #$33333333, ($3333,a0) uses Op0ca8 ----------
Op0ca8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cb0] cmpi.l #$33333333, ($33,a0,d3.w*2) uses Op0cb0 ----------
Op0cb0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cb8] cmpi.l #$33333333, $3333.w uses Op0cb8 ----------
Op0cb8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cb9] cmpi.l #$33333333, $33333333.l uses Op0cb9 ----------
Op0cb9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cba] cmpi.l #$33333333, ($3333,pc); =3339 uses Op0cba ----------
Op0cba:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r11,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cbb] cmpi.l #$33333333, ($33,pc,d3.w*2); =39 uses Op0cbb ----------
Op0cbb:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r11,r2,r0 ;@ r11=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cbc]  uses Op0cbc ----------
Op0cbc:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '#$33333333' into r11:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r11) into r0:
  mov r0,r11,asl #0

;@ Do arithmetic:
  cmp r0,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1000] move.b d0, d0 uses Op1000 ----------
Op1000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1010] move.b (a0), d0 uses Op1010 ----------
Op1010:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1018] move.b (a0)+, d0 uses Op1018 ----------
Op1018:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [101f] move.b (a7)+, d0 uses Op101f ----------
Op101f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1020] move.b -(a0), d0 uses Op1020 ----------
Op1020:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1027] move.b -(a7), d0 uses Op1027 ----------
Op1027:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1028] move.b ($3333,a0), d0 uses Op1028 ----------
Op1028:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1030] move.b ($33,a0,d3.w*2), d0 uses Op1030 ----------
Op1030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1038] move.b $3333.w, d0 uses Op1038 ----------
Op1038:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1039] move.b $33333333.l, d0 uses Op1039 ----------
Op1039:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [103a] move.b ($3333,pc), d0; =3335 uses Op103a ----------
Op103a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [103b] move.b ($33,pc,d3.w*2), d0; =35 uses Op103b ----------
Op103b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [103c] move.b #$33, d0 uses Op103c ----------
Op103c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1080] move.b d0, (a0) uses Op1080 ----------
Op1080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1090] move.b (a0), (a0) uses Op1090 ----------
Op1090:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1098] move.b (a0)+, (a0) uses Op1098 ----------
Op1098:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [109f] move.b (a7)+, (a0) uses Op109f ----------
Op109f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10a0] move.b -(a0), (a0) uses Op10a0 ----------
Op10a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10a7] move.b -(a7), (a0) uses Op10a7 ----------
Op10a7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10a8] move.b ($3333,a0), (a0) uses Op10a8 ----------
Op10a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10b0] move.b ($33,a0,d3.w*2), (a0) uses Op10b0 ----------
Op10b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10b8] move.b $3333.w, (a0) uses Op10b8 ----------
Op10b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10b9] move.b $33333333.l, (a0) uses Op10b9 ----------
Op10b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10ba] move.b ($3333,pc), (a0); =3335 uses Op10ba ----------
Op10ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10bb] move.b ($33,pc,d3.w*2), (a0); =35 uses Op10bb ----------
Op10bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10bc] move.b #$33, (a0) uses Op10bc ----------
Op10bc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10c0] move.b d0, (a0)+ uses Op10c0 ----------
Op10c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10d0] move.b (a0), (a0)+ uses Op10d0 ----------
Op10d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10d8] move.b (a0)+, (a0)+ uses Op10d8 ----------
Op10d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10df] move.b (a7)+, (a0)+ uses Op10df ----------
Op10df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10e0] move.b -(a0), (a0)+ uses Op10e0 ----------
Op10e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10e7] move.b -(a7), (a0)+ uses Op10e7 ----------
Op10e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10e8] move.b ($3333,a0), (a0)+ uses Op10e8 ----------
Op10e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10f0] move.b ($33,a0,d3.w*2), (a0)+ uses Op10f0 ----------
Op10f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10f8] move.b $3333.w, (a0)+ uses Op10f8 ----------
Op10f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10f9] move.b $33333333.l, (a0)+ uses Op10f9 ----------
Op10f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10fa] move.b ($3333,pc), (a0)+; =3335 uses Op10fa ----------
Op10fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10fb] move.b ($33,pc,d3.w*2), (a0)+; =35 uses Op10fb ----------
Op10fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10fc] move.b #$33, (a0)+ uses Op10fc ----------
Op10fc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1100] move.b d0, -(a0) uses Op1100 ----------
Op1100:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1110] move.b (a0), -(a0) uses Op1110 ----------
Op1110:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1118] move.b (a0)+, -(a0) uses Op1118 ----------
Op1118:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [111f] move.b (a7)+, -(a0) uses Op111f ----------
Op111f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1120] move.b -(a0), -(a0) uses Op1120 ----------
Op1120:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1127] move.b -(a7), -(a0) uses Op1127 ----------
Op1127:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1128] move.b ($3333,a0), -(a0) uses Op1128 ----------
Op1128:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1130] move.b ($33,a0,d3.w*2), -(a0) uses Op1130 ----------
Op1130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1138] move.b $3333.w, -(a0) uses Op1138 ----------
Op1138:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1139] move.b $33333333.l, -(a0) uses Op1139 ----------
Op1139:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [113a] move.b ($3333,pc), -(a0); =3335 uses Op113a ----------
Op113a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [113b] move.b ($33,pc,d3.w*2), -(a0); =35 uses Op113b ----------
Op113b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [113c] move.b #$33, -(a0) uses Op113c ----------
Op113c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1140] move.b d0, ($3333,a0) uses Op1140 ----------
Op1140:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1150] move.b (a0), ($3333,a0) uses Op1150 ----------
Op1150:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1158] move.b (a0)+, ($3333,a0) uses Op1158 ----------
Op1158:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [115f] move.b (a7)+, ($3333,a0) uses Op115f ----------
Op115f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1160] move.b -(a0), ($3333,a0) uses Op1160 ----------
Op1160:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1167] move.b -(a7), ($3333,a0) uses Op1167 ----------
Op1167:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1168] move.b ($3333,a0), ($3333,a0) uses Op1168 ----------
Op1168:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1170] move.b ($33,a0,d3.w*2), ($3333,a0) uses Op1170 ----------
Op1170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1178] move.b $3333.w, ($3333,a0) uses Op1178 ----------
Op1178:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1179] move.b $33333333.l, ($3333,a0) uses Op1179 ----------
Op1179:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [117a] move.b ($3333,pc), ($3333,a0); =3335 uses Op117a ----------
Op117a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [117b] move.b ($33,pc,d3.w*2), ($3333,a0); =35 uses Op117b ----------
Op117b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [117c] move.b #$33, ($3333,a0) uses Op117c ----------
Op117c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1180] move.b d0, ($33,a0,d3.w*2) uses Op1180 ----------
Op1180:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1190] move.b (a0), ($33,a0,d3.w*2) uses Op1190 ----------
Op1190:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1198] move.b (a0)+, ($33,a0,d3.w*2) uses Op1198 ----------
Op1198:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [119f] move.b (a7)+, ($33,a0,d3.w*2) uses Op119f ----------
Op119f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11a0] move.b -(a0), ($33,a0,d3.w*2) uses Op11a0 ----------
Op11a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11a7] move.b -(a7), ($33,a0,d3.w*2) uses Op11a7 ----------
Op11a7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11a8] move.b ($3333,a0), ($33,a0,d3.w*2) uses Op11a8 ----------
Op11a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11b0] move.b ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op11b0 ----------
Op11b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11b8] move.b $3333.w, ($33,a0,d3.w*2) uses Op11b8 ----------
Op11b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11b9] move.b $33333333.l, ($33,a0,d3.w*2) uses Op11b9 ----------
Op11b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11ba] move.b ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op11ba ----------
Op11ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11bb] move.b ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op11bb ----------
Op11bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11bc] move.b #$33, ($33,a0,d3.w*2) uses Op11bc ----------
Op11bc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11c0] move.b d0, $3333.w uses Op11c0 ----------
Op11c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11d0] move.b (a0), $3333.w uses Op11d0 ----------
Op11d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11d8] move.b (a0)+, $3333.w uses Op11d8 ----------
Op11d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11df] move.b (a7)+, $3333.w uses Op11df ----------
Op11df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11e0] move.b -(a0), $3333.w uses Op11e0 ----------
Op11e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11e7] move.b -(a7), $3333.w uses Op11e7 ----------
Op11e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11e8] move.b ($3333,a0), $3333.w uses Op11e8 ----------
Op11e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11f0] move.b ($33,a0,d3.w*2), $3333.w uses Op11f0 ----------
Op11f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11f8] move.b $3333.w, $3333.w uses Op11f8 ----------
Op11f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11f9] move.b $33333333.l, $3333.w uses Op11f9 ----------
Op11f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11fa] move.b ($3333,pc), $3333.w; =3335 uses Op11fa ----------
Op11fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11fb] move.b ($33,pc,d3.w*2), $3333.w; =35 uses Op11fb ----------
Op11fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11fc] move.b #$33, $3333.w uses Op11fc ----------
Op11fc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13c0] move.b d0, $33333333.l uses Op13c0 ----------
Op13c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13d0] move.b (a0), $33333333.l uses Op13d0 ----------
Op13d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13d8] move.b (a0)+, $33333333.l uses Op13d8 ----------
Op13d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13df] move.b (a7)+, $33333333.l uses Op13df ----------
Op13df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13e0] move.b -(a0), $33333333.l uses Op13e0 ----------
Op13e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13e7] move.b -(a7), $33333333.l uses Op13e7 ----------
Op13e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13e8] move.b ($3333,a0), $33333333.l uses Op13e8 ----------
Op13e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13f0] move.b ($33,a0,d3.w*2), $33333333.l uses Op13f0 ----------
Op13f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13f8] move.b $3333.w, $33333333.l uses Op13f8 ----------
Op13f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13f9] move.b $33333333.l, $33333333.l uses Op13f9 ----------
Op13f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13fa] move.b ($3333,pc), $33333333.l; =3335 uses Op13fa ----------
Op13fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13fb] move.b ($33,pc,d3.w*2), $33333333.l; =35 uses Op13fb ----------
Op13fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13fc] move.b #$33, $33333333.l uses Op13fc ----------
Op13fc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [15c0] move.b d0, ($3333,pc); =3335 uses Op15c0 ----------
Op15c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [15d0] move.b (a0), ($3333,pc); =3335 uses Op15d0 ----------
Op15d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [15d8] move.b (a0)+, ($3333,pc); =3335 uses Op15d8 ----------
Op15d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [15df] move.b (a7)+, ($3333,pc); =3335 uses Op15df ----------
Op15df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [15e0] move.b -(a0), ($3333,pc); =3335 uses Op15e0 ----------
Op15e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [15e7] move.b -(a7), ($3333,pc); =3335 uses Op15e7 ----------
Op15e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [15e8] move.b ($3333,a0), ($3333,pc); =3337 uses Op15e8 ----------
Op15e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [15f0] move.b ($33,a0,d3.w*2), ($3333,pc); =3337 uses Op15f0 ----------
Op15f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [15f8] move.b $3333.w, ($3333,pc); =3337 uses Op15f8 ----------
Op15f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [15f9] move.b $33333333.l, ($3333,pc); =3339 uses Op15f9 ----------
Op15f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [15fa] move.b ($3333,pc), ($3333,pc); =3337 uses Op15fa ----------
Op15fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [15fb] move.b ($33,pc,d3.w*2), ($3333,pc); =3337 uses Op15fb ----------
Op15fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [15fc] move.b #$33, ($3333,pc); =3337 uses Op15fc ----------
Op15fc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [17c0] move.b d0, ($33,pc,d3.w*2); =35 uses Op17c0 ----------
Op17c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [17d0] move.b (a0), ($33,pc,d3.w*2); =35 uses Op17d0 ----------
Op17d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [17d8] move.b (a0)+, ($33,pc,d3.w*2); =35 uses Op17d8 ----------
Op17d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [17df] move.b (a7)+, ($33,pc,d3.w*2); =35 uses Op17df ----------
Op17df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [17e0] move.b -(a0), ($33,pc,d3.w*2); =35 uses Op17e0 ----------
Op17e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [17e7] move.b -(a7), ($33,pc,d3.w*2); =35 uses Op17e7 ----------
Op17e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [17e8] move.b ($3333,a0), ($33,pc,d3.w*2); =37 uses Op17e8 ----------
Op17e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [17f0] move.b ($33,a0,d3.w*2), ($33,pc,d3.w*2); =37 uses Op17f0 ----------
Op17f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [17f8] move.b $3333.w, ($33,pc,d3.w*2); =37 uses Op17f8 ----------
Op17f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [17f9] move.b $33333333.l, ($33,pc,d3.w*2); =39 uses Op17f9 ----------
Op17f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [17fa] move.b ($3333,pc), ($33,pc,d3.w*2); =37 uses Op17fa ----------
Op17fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [17fb] move.b ($33,pc,d3.w*2), ($33,pc,d3.w*2); =37 uses Op17fb ----------
Op17fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [17fc] move.b #$33, ($33,pc,d3.w*2); =37 uses Op17fc ----------
Op17fc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ec0] move.b d0, (a7)+ uses Op1ec0 ----------
Op1ec0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ed0] move.b (a0), (a7)+ uses Op1ed0 ----------
Op1ed0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ed8] move.b (a0)+, (a7)+ uses Op1ed8 ----------
Op1ed8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1edf] move.b (a7)+, (a7)+ uses Op1edf ----------
Op1edf:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ee0] move.b -(a0), (a7)+ uses Op1ee0 ----------
Op1ee0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ee7] move.b -(a7), (a7)+ uses Op1ee7 ----------
Op1ee7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ee8] move.b ($3333,a0), (a7)+ uses Op1ee8 ----------
Op1ee8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ef0] move.b ($33,a0,d3.w*2), (a7)+ uses Op1ef0 ----------
Op1ef0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ef8] move.b $3333.w, (a7)+ uses Op1ef8 ----------
Op1ef8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ef9] move.b $33333333.l, (a7)+ uses Op1ef9 ----------
Op1ef9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1efa] move.b ($3333,pc), (a7)+; =3335 uses Op1efa ----------
Op1efa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1efb] move.b ($33,pc,d3.w*2), (a7)+; =35 uses Op1efb ----------
Op1efb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1efc] move.b #$33, (a7)+ uses Op1efc ----------
Op1efc:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f00] move.b d0, -(a7) uses Op1f00 ----------
Op1f00:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f10] move.b (a0), -(a7) uses Op1f10 ----------
Op1f10:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f18] move.b (a0)+, -(a7) uses Op1f18 ----------
Op1f18:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f1f] move.b (a7)+, -(a7) uses Op1f1f ----------
Op1f1f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f20] move.b -(a0), -(a7) uses Op1f20 ----------
Op1f20:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f27] move.b -(a7), -(a7) uses Op1f27 ----------
Op1f27:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f28] move.b ($3333,a0), -(a7) uses Op1f28 ----------
Op1f28:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f30] move.b ($33,a0,d3.w*2), -(a7) uses Op1f30 ----------
Op1f30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f38] move.b $3333.w, -(a7) uses Op1f38 ----------
Op1f38:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f39] move.b $33333333.l, -(a7) uses Op1f39 ----------
Op1f39:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f3a] move.b ($3333,pc), -(a7); =3335 uses Op1f3a ----------
Op1f3a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f3b] move.b ($33,pc,d3.w*2), -(a7); =35 uses Op1f3b ----------
Op1f3b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f3c] move.b #$33, -(a7) uses Op1f3c ----------
Op1f3c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2000] move.l d0, d0 uses Op2000 ----------
Op2000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2010] move.l (a0), d0 uses Op2010 ----------
Op2010:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2018] move.l (a0)+, d0 uses Op2018 ----------
Op2018:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [201f] move.l (a7)+, d0 uses Op201f ----------
Op201f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2020] move.l -(a0), d0 uses Op2020 ----------
Op2020:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2027] move.l -(a7), d0 uses Op2027 ----------
Op2027:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2028] move.l ($3333,a0), d0 uses Op2028 ----------
Op2028:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2030] move.l ($33,a0,d3.w*2), d0 uses Op2030 ----------
Op2030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2038] move.l $3333.w, d0 uses Op2038 ----------
Op2038:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2039] move.l $33333333.l, d0 uses Op2039 ----------
Op2039:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [203a] move.l ($3333,pc), d0; =3335 uses Op203a ----------
Op203a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [203b] move.l ($33,pc,d3.w*2), d0; =35 uses Op203b ----------
Op203b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [203c] move.l #$33333333, d0 uses Op203c ----------
Op203c:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2040] movea.l d0, a0 uses Op2040 ----------
Op2040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2050] movea.l (a0), a0 uses Op2050 ----------
Op2050:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2058] movea.l (a0)+, a0 uses Op2058 ----------
Op2058:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [205f] movea.l (a7)+, a0 uses Op205f ----------
Op205f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2060] movea.l -(a0), a0 uses Op2060 ----------
Op2060:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2067] movea.l -(a7), a0 uses Op2067 ----------
Op2067:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2068] movea.l ($3333,a0), a0 uses Op2068 ----------
Op2068:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2070] movea.l ($33,a0,d3.w*2), a0 uses Op2070 ----------
Op2070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2078] movea.l $3333.w, a0 uses Op2078 ----------
Op2078:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2079] movea.l $33333333.l, a0 uses Op2079 ----------
Op2079:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [207a] movea.l ($3333,pc), a0; =3335 uses Op207a ----------
Op207a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [207b] movea.l ($33,pc,d3.w*2), a0; =35 uses Op207b ----------
Op207b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [207c] movea.l #$33333333, a0 uses Op207c ----------
Op207c:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2080] move.l d0, (a0) uses Op2080 ----------
Op2080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2090] move.l (a0), (a0) uses Op2090 ----------
Op2090:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2098] move.l (a0)+, (a0) uses Op2098 ----------
Op2098:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [209f] move.l (a7)+, (a0) uses Op209f ----------
Op209f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20a0] move.l -(a0), (a0) uses Op20a0 ----------
Op20a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20a7] move.l -(a7), (a0) uses Op20a7 ----------
Op20a7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20a8] move.l ($3333,a0), (a0) uses Op20a8 ----------
Op20a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20b0] move.l ($33,a0,d3.w*2), (a0) uses Op20b0 ----------
Op20b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20b8] move.l $3333.w, (a0) uses Op20b8 ----------
Op20b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20b9] move.l $33333333.l, (a0) uses Op20b9 ----------
Op20b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20ba] move.l ($3333,pc), (a0); =3335 uses Op20ba ----------
Op20ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20bb] move.l ($33,pc,d3.w*2), (a0); =35 uses Op20bb ----------
Op20bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20bc] move.l #$33333333, (a0) uses Op20bc ----------
Op20bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20c0] move.l d0, (a0)+ uses Op20c0 ----------
Op20c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20d0] move.l (a0), (a0)+ uses Op20d0 ----------
Op20d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20d8] move.l (a0)+, (a0)+ uses Op20d8 ----------
Op20d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20df] move.l (a7)+, (a0)+ uses Op20df ----------
Op20df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20e0] move.l -(a0), (a0)+ uses Op20e0 ----------
Op20e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20e7] move.l -(a7), (a0)+ uses Op20e7 ----------
Op20e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20e8] move.l ($3333,a0), (a0)+ uses Op20e8 ----------
Op20e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20f0] move.l ($33,a0,d3.w*2), (a0)+ uses Op20f0 ----------
Op20f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20f8] move.l $3333.w, (a0)+ uses Op20f8 ----------
Op20f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20f9] move.l $33333333.l, (a0)+ uses Op20f9 ----------
Op20f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20fa] move.l ($3333,pc), (a0)+; =3335 uses Op20fa ----------
Op20fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20fb] move.l ($33,pc,d3.w*2), (a0)+; =35 uses Op20fb ----------
Op20fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20fc] move.l #$33333333, (a0)+ uses Op20fc ----------
Op20fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2100] move.l d0, -(a0) uses Op2100 ----------
Op2100:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2110] move.l (a0), -(a0) uses Op2110 ----------
Op2110:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2118] move.l (a0)+, -(a0) uses Op2118 ----------
Op2118:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [211f] move.l (a7)+, -(a0) uses Op211f ----------
Op211f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2120] move.l -(a0), -(a0) uses Op2120 ----------
Op2120:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2127] move.l -(a7), -(a0) uses Op2127 ----------
Op2127:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2128] move.l ($3333,a0), -(a0) uses Op2128 ----------
Op2128:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2130] move.l ($33,a0,d3.w*2), -(a0) uses Op2130 ----------
Op2130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2138] move.l $3333.w, -(a0) uses Op2138 ----------
Op2138:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2139] move.l $33333333.l, -(a0) uses Op2139 ----------
Op2139:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [213a] move.l ($3333,pc), -(a0); =3335 uses Op213a ----------
Op213a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [213b] move.l ($33,pc,d3.w*2), -(a0); =35 uses Op213b ----------
Op213b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [213c] move.l #$33333333, -(a0) uses Op213c ----------
Op213c:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2140] move.l d0, ($3333,a0) uses Op2140 ----------
Op2140:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2150] move.l (a0), ($3333,a0) uses Op2150 ----------
Op2150:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2158] move.l (a0)+, ($3333,a0) uses Op2158 ----------
Op2158:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [215f] move.l (a7)+, ($3333,a0) uses Op215f ----------
Op215f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2160] move.l -(a0), ($3333,a0) uses Op2160 ----------
Op2160:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2167] move.l -(a7), ($3333,a0) uses Op2167 ----------
Op2167:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2168] move.l ($3333,a0), ($3333,a0) uses Op2168 ----------
Op2168:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2170] move.l ($33,a0,d3.w*2), ($3333,a0) uses Op2170 ----------
Op2170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2178] move.l $3333.w, ($3333,a0) uses Op2178 ----------
Op2178:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2179] move.l $33333333.l, ($3333,a0) uses Op2179 ----------
Op2179:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [217a] move.l ($3333,pc), ($3333,a0); =3335 uses Op217a ----------
Op217a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [217b] move.l ($33,pc,d3.w*2), ($3333,a0); =35 uses Op217b ----------
Op217b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [217c] move.l #$33333333, ($3333,a0) uses Op217c ----------
Op217c:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2180] move.l d0, ($33,a0,d3.w*2) uses Op2180 ----------
Op2180:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2190] move.l (a0), ($33,a0,d3.w*2) uses Op2190 ----------
Op2190:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2198] move.l (a0)+, ($33,a0,d3.w*2) uses Op2198 ----------
Op2198:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [219f] move.l (a7)+, ($33,a0,d3.w*2) uses Op219f ----------
Op219f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21a0] move.l -(a0), ($33,a0,d3.w*2) uses Op21a0 ----------
Op21a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21a7] move.l -(a7), ($33,a0,d3.w*2) uses Op21a7 ----------
Op21a7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21a8] move.l ($3333,a0), ($33,a0,d3.w*2) uses Op21a8 ----------
Op21a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21b0] move.l ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op21b0 ----------
Op21b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21b8] move.l $3333.w, ($33,a0,d3.w*2) uses Op21b8 ----------
Op21b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21b9] move.l $33333333.l, ($33,a0,d3.w*2) uses Op21b9 ----------
Op21b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21ba] move.l ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op21ba ----------
Op21ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21bb] move.l ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op21bb ----------
Op21bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21bc] move.l #$33333333, ($33,a0,d3.w*2) uses Op21bc ----------
Op21bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21c0] move.l d0, $3333.w uses Op21c0 ----------
Op21c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21d0] move.l (a0), $3333.w uses Op21d0 ----------
Op21d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21d8] move.l (a0)+, $3333.w uses Op21d8 ----------
Op21d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21df] move.l (a7)+, $3333.w uses Op21df ----------
Op21df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21e0] move.l -(a0), $3333.w uses Op21e0 ----------
Op21e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21e7] move.l -(a7), $3333.w uses Op21e7 ----------
Op21e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21e8] move.l ($3333,a0), $3333.w uses Op21e8 ----------
Op21e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21f0] move.l ($33,a0,d3.w*2), $3333.w uses Op21f0 ----------
Op21f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21f8] move.l $3333.w, $3333.w uses Op21f8 ----------
Op21f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21f9] move.l $33333333.l, $3333.w uses Op21f9 ----------
Op21f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21fa] move.l ($3333,pc), $3333.w; =3335 uses Op21fa ----------
Op21fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21fb] move.l ($33,pc,d3.w*2), $3333.w; =35 uses Op21fb ----------
Op21fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21fc] move.l #$33333333, $3333.w uses Op21fc ----------
Op21fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23c0] move.l d0, $33333333.l uses Op23c0 ----------
Op23c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23d0] move.l (a0), $33333333.l uses Op23d0 ----------
Op23d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23d8] move.l (a0)+, $33333333.l uses Op23d8 ----------
Op23d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23df] move.l (a7)+, $33333333.l uses Op23df ----------
Op23df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23e0] move.l -(a0), $33333333.l uses Op23e0 ----------
Op23e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23e7] move.l -(a7), $33333333.l uses Op23e7 ----------
Op23e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23e8] move.l ($3333,a0), $33333333.l uses Op23e8 ----------
Op23e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23f0] move.l ($33,a0,d3.w*2), $33333333.l uses Op23f0 ----------
Op23f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23f8] move.l $3333.w, $33333333.l uses Op23f8 ----------
Op23f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23f9] move.l $33333333.l, $33333333.l uses Op23f9 ----------
Op23f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23fa] move.l ($3333,pc), $33333333.l; =3335 uses Op23fa ----------
Op23fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23fb] move.l ($33,pc,d3.w*2), $33333333.l; =35 uses Op23fb ----------
Op23fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23fc] move.l #$33333333, $33333333.l uses Op23fc ----------
Op23fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [25c0] move.l d0, ($3333,pc); =3335 uses Op25c0 ----------
Op25c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [25d0] move.l (a0), ($3333,pc); =3335 uses Op25d0 ----------
Op25d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [25d8] move.l (a0)+, ($3333,pc); =3335 uses Op25d8 ----------
Op25d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [25df] move.l (a7)+, ($3333,pc); =3335 uses Op25df ----------
Op25df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [25e0] move.l -(a0), ($3333,pc); =3335 uses Op25e0 ----------
Op25e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [25e7] move.l -(a7), ($3333,pc); =3335 uses Op25e7 ----------
Op25e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [25e8] move.l ($3333,a0), ($3333,pc); =3337 uses Op25e8 ----------
Op25e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [25f0] move.l ($33,a0,d3.w*2), ($3333,pc); =3337 uses Op25f0 ----------
Op25f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [25f8] move.l $3333.w, ($3333,pc); =3337 uses Op25f8 ----------
Op25f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [25f9] move.l $33333333.l, ($3333,pc); =3339 uses Op25f9 ----------
Op25f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [25fa] move.l ($3333,pc), ($3333,pc); =3337 uses Op25fa ----------
Op25fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [25fb] move.l ($33,pc,d3.w*2), ($3333,pc); =3337 uses Op25fb ----------
Op25fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [25fc] move.l #$33333333, ($3333,pc); =3339 uses Op25fc ----------
Op25fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [27c0] move.l d0, ($33,pc,d3.w*2); =35 uses Op27c0 ----------
Op27c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [27d0] move.l (a0), ($33,pc,d3.w*2); =35 uses Op27d0 ----------
Op27d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [27d8] move.l (a0)+, ($33,pc,d3.w*2); =35 uses Op27d8 ----------
Op27d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [27df] move.l (a7)+, ($33,pc,d3.w*2); =35 uses Op27df ----------
Op27df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [27e0] move.l -(a0), ($33,pc,d3.w*2); =35 uses Op27e0 ----------
Op27e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [27e7] move.l -(a7), ($33,pc,d3.w*2); =35 uses Op27e7 ----------
Op27e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [27e8] move.l ($3333,a0), ($33,pc,d3.w*2); =37 uses Op27e8 ----------
Op27e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [27f0] move.l ($33,a0,d3.w*2), ($33,pc,d3.w*2); =37 uses Op27f0 ----------
Op27f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [27f8] move.l $3333.w, ($33,pc,d3.w*2); =37 uses Op27f8 ----------
Op27f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [27f9] move.l $33333333.l, ($33,pc,d3.w*2); =39 uses Op27f9 ----------
Op27f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [27fa] move.l ($3333,pc), ($33,pc,d3.w*2); =37 uses Op27fa ----------
Op27fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [27fb] move.l ($33,pc,d3.w*2), ($33,pc,d3.w*2); =37 uses Op27fb ----------
Op27fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [27fc] move.l #$33333333, ($33,pc,d3.w*2); =39 uses Op27fc ----------
Op27fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ec0] move.l d0, (a7)+ uses Op2ec0 ----------
Op2ec0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ed0] move.l (a0), (a7)+ uses Op2ed0 ----------
Op2ed0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ed8] move.l (a0)+, (a7)+ uses Op2ed8 ----------
Op2ed8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2edf] move.l (a7)+, (a7)+ uses Op2edf ----------
Op2edf:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ee0] move.l -(a0), (a7)+ uses Op2ee0 ----------
Op2ee0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ee7] move.l -(a7), (a7)+ uses Op2ee7 ----------
Op2ee7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ee8] move.l ($3333,a0), (a7)+ uses Op2ee8 ----------
Op2ee8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ef0] move.l ($33,a0,d3.w*2), (a7)+ uses Op2ef0 ----------
Op2ef0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ef8] move.l $3333.w, (a7)+ uses Op2ef8 ----------
Op2ef8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ef9] move.l $33333333.l, (a7)+ uses Op2ef9 ----------
Op2ef9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2efa] move.l ($3333,pc), (a7)+; =3335 uses Op2efa ----------
Op2efa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2efb] move.l ($33,pc,d3.w*2), (a7)+; =35 uses Op2efb ----------
Op2efb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2efc] move.l #$33333333, (a7)+ uses Op2efc ----------
Op2efc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f00] move.l d0, -(a7) uses Op2f00 ----------
Op2f00:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f10] move.l (a0), -(a7) uses Op2f10 ----------
Op2f10:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f18] move.l (a0)+, -(a7) uses Op2f18 ----------
Op2f18:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f1f] move.l (a7)+, -(a7) uses Op2f1f ----------
Op2f1f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f20] move.l -(a0), -(a7) uses Op2f20 ----------
Op2f20:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f27] move.l -(a7), -(a7) uses Op2f27 ----------
Op2f27:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f28] move.l ($3333,a0), -(a7) uses Op2f28 ----------
Op2f28:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f30] move.l ($33,a0,d3.w*2), -(a7) uses Op2f30 ----------
Op2f30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f38] move.l $3333.w, -(a7) uses Op2f38 ----------
Op2f38:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f39] move.l $33333333.l, -(a7) uses Op2f39 ----------
Op2f39:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f3a] move.l ($3333,pc), -(a7); =3335 uses Op2f3a ----------
Op2f3a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f3b] move.l ($33,pc,d3.w*2), -(a7); =35 uses Op2f3b ----------
Op2f3b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f3c] move.l #$33333333, -(a7) uses Op2f3c ----------
Op2f3c:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3000] move.w d0, d0 uses Op3000 ----------
Op3000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3010] move.w (a0), d0 uses Op3010 ----------
Op3010:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3018] move.w (a0)+, d0 uses Op3018 ----------
Op3018:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [301f] move.w (a7)+, d0 uses Op301f ----------
Op301f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3020] move.w -(a0), d0 uses Op3020 ----------
Op3020:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3027] move.w -(a7), d0 uses Op3027 ----------
Op3027:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3028] move.w ($3333,a0), d0 uses Op3028 ----------
Op3028:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3030] move.w ($33,a0,d3.w*2), d0 uses Op3030 ----------
Op3030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3038] move.w $3333.w, d0 uses Op3038 ----------
Op3038:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3039] move.w $33333333.l, d0 uses Op3039 ----------
Op3039:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [303a] move.w ($3333,pc), d0; =3335 uses Op303a ----------
Op303a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [303b] move.w ($33,pc,d3.w*2), d0; =35 uses Op303b ----------
Op303b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [303c] move.w #$3333, d0 uses Op303c ----------
Op303c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3040] movea.w d0, a0 uses Op3040 ----------
Op3040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3050] movea.w (a0), a0 uses Op3050 ----------
Op3050:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3058] movea.w (a0)+, a0 uses Op3058 ----------
Op3058:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [305f] movea.w (a7)+, a0 uses Op305f ----------
Op305f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3060] movea.w -(a0), a0 uses Op3060 ----------
Op3060:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3067] movea.w -(a7), a0 uses Op3067 ----------
Op3067:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3068] movea.w ($3333,a0), a0 uses Op3068 ----------
Op3068:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3070] movea.w ($33,a0,d3.w*2), a0 uses Op3070 ----------
Op3070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3078] movea.w $3333.w, a0 uses Op3078 ----------
Op3078:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3079] movea.w $33333333.l, a0 uses Op3079 ----------
Op3079:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [307a] movea.w ($3333,pc), a0; =3335 uses Op307a ----------
Op307a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [307b] movea.w ($33,pc,d3.w*2), a0; =35 uses Op307b ----------
Op307b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [307c] movea.w #$3333, a0 uses Op307c ----------
Op307c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3080] move.w d0, (a0) uses Op3080 ----------
Op3080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3090] move.w (a0), (a0) uses Op3090 ----------
Op3090:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3098] move.w (a0)+, (a0) uses Op3098 ----------
Op3098:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [309f] move.w (a7)+, (a0) uses Op309f ----------
Op309f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30a0] move.w -(a0), (a0) uses Op30a0 ----------
Op30a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30a7] move.w -(a7), (a0) uses Op30a7 ----------
Op30a7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30a8] move.w ($3333,a0), (a0) uses Op30a8 ----------
Op30a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30b0] move.w ($33,a0,d3.w*2), (a0) uses Op30b0 ----------
Op30b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30b8] move.w $3333.w, (a0) uses Op30b8 ----------
Op30b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30b9] move.w $33333333.l, (a0) uses Op30b9 ----------
Op30b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30ba] move.w ($3333,pc), (a0); =3335 uses Op30ba ----------
Op30ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30bb] move.w ($33,pc,d3.w*2), (a0); =35 uses Op30bb ----------
Op30bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30bc] move.w #$3333, (a0) uses Op30bc ----------
Op30bc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30c0] move.w d0, (a0)+ uses Op30c0 ----------
Op30c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30d0] move.w (a0), (a0)+ uses Op30d0 ----------
Op30d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30d8] move.w (a0)+, (a0)+ uses Op30d8 ----------
Op30d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30df] move.w (a7)+, (a0)+ uses Op30df ----------
Op30df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30e0] move.w -(a0), (a0)+ uses Op30e0 ----------
Op30e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30e7] move.w -(a7), (a0)+ uses Op30e7 ----------
Op30e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30e8] move.w ($3333,a0), (a0)+ uses Op30e8 ----------
Op30e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30f0] move.w ($33,a0,d3.w*2), (a0)+ uses Op30f0 ----------
Op30f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30f8] move.w $3333.w, (a0)+ uses Op30f8 ----------
Op30f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30f9] move.w $33333333.l, (a0)+ uses Op30f9 ----------
Op30f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30fa] move.w ($3333,pc), (a0)+; =3335 uses Op30fa ----------
Op30fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30fb] move.w ($33,pc,d3.w*2), (a0)+; =35 uses Op30fb ----------
Op30fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30fc] move.w #$3333, (a0)+ uses Op30fc ----------
Op30fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3100] move.w d0, -(a0) uses Op3100 ----------
Op3100:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3110] move.w (a0), -(a0) uses Op3110 ----------
Op3110:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3118] move.w (a0)+, -(a0) uses Op3118 ----------
Op3118:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [311f] move.w (a7)+, -(a0) uses Op311f ----------
Op311f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3120] move.w -(a0), -(a0) uses Op3120 ----------
Op3120:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3127] move.w -(a7), -(a0) uses Op3127 ----------
Op3127:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3128] move.w ($3333,a0), -(a0) uses Op3128 ----------
Op3128:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3130] move.w ($33,a0,d3.w*2), -(a0) uses Op3130 ----------
Op3130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3138] move.w $3333.w, -(a0) uses Op3138 ----------
Op3138:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3139] move.w $33333333.l, -(a0) uses Op3139 ----------
Op3139:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [313a] move.w ($3333,pc), -(a0); =3335 uses Op313a ----------
Op313a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [313b] move.w ($33,pc,d3.w*2), -(a0); =35 uses Op313b ----------
Op313b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [313c] move.w #$3333, -(a0) uses Op313c ----------
Op313c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3140] move.w d0, ($3333,a0) uses Op3140 ----------
Op3140:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3150] move.w (a0), ($3333,a0) uses Op3150 ----------
Op3150:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3158] move.w (a0)+, ($3333,a0) uses Op3158 ----------
Op3158:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [315f] move.w (a7)+, ($3333,a0) uses Op315f ----------
Op315f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3160] move.w -(a0), ($3333,a0) uses Op3160 ----------
Op3160:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3167] move.w -(a7), ($3333,a0) uses Op3167 ----------
Op3167:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3168] move.w ($3333,a0), ($3333,a0) uses Op3168 ----------
Op3168:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3170] move.w ($33,a0,d3.w*2), ($3333,a0) uses Op3170 ----------
Op3170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3178] move.w $3333.w, ($3333,a0) uses Op3178 ----------
Op3178:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3179] move.w $33333333.l, ($3333,a0) uses Op3179 ----------
Op3179:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [317a] move.w ($3333,pc), ($3333,a0); =3335 uses Op317a ----------
Op317a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [317b] move.w ($33,pc,d3.w*2), ($3333,a0); =35 uses Op317b ----------
Op317b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [317c] move.w #$3333, ($3333,a0) uses Op317c ----------
Op317c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3180] move.w d0, ($33,a0,d3.w*2) uses Op3180 ----------
Op3180:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3190] move.w (a0), ($33,a0,d3.w*2) uses Op3190 ----------
Op3190:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3198] move.w (a0)+, ($33,a0,d3.w*2) uses Op3198 ----------
Op3198:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [319f] move.w (a7)+, ($33,a0,d3.w*2) uses Op319f ----------
Op319f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31a0] move.w -(a0), ($33,a0,d3.w*2) uses Op31a0 ----------
Op31a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31a7] move.w -(a7), ($33,a0,d3.w*2) uses Op31a7 ----------
Op31a7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31a8] move.w ($3333,a0), ($33,a0,d3.w*2) uses Op31a8 ----------
Op31a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31b0] move.w ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op31b0 ----------
Op31b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31b8] move.w $3333.w, ($33,a0,d3.w*2) uses Op31b8 ----------
Op31b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31b9] move.w $33333333.l, ($33,a0,d3.w*2) uses Op31b9 ----------
Op31b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31ba] move.w ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op31ba ----------
Op31ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31bb] move.w ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op31bb ----------
Op31bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31bc] move.w #$3333, ($33,a0,d3.w*2) uses Op31bc ----------
Op31bc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31c0] move.w d0, $3333.w uses Op31c0 ----------
Op31c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31d0] move.w (a0), $3333.w uses Op31d0 ----------
Op31d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31d8] move.w (a0)+, $3333.w uses Op31d8 ----------
Op31d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31df] move.w (a7)+, $3333.w uses Op31df ----------
Op31df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31e0] move.w -(a0), $3333.w uses Op31e0 ----------
Op31e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31e7] move.w -(a7), $3333.w uses Op31e7 ----------
Op31e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31e8] move.w ($3333,a0), $3333.w uses Op31e8 ----------
Op31e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31f0] move.w ($33,a0,d3.w*2), $3333.w uses Op31f0 ----------
Op31f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31f8] move.w $3333.w, $3333.w uses Op31f8 ----------
Op31f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31f9] move.w $33333333.l, $3333.w uses Op31f9 ----------
Op31f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31fa] move.w ($3333,pc), $3333.w; =3335 uses Op31fa ----------
Op31fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31fb] move.w ($33,pc,d3.w*2), $3333.w; =35 uses Op31fb ----------
Op31fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31fc] move.w #$3333, $3333.w uses Op31fc ----------
Op31fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33c0] move.w d0, $33333333.l uses Op33c0 ----------
Op33c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33d0] move.w (a0), $33333333.l uses Op33d0 ----------
Op33d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33d8] move.w (a0)+, $33333333.l uses Op33d8 ----------
Op33d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33df] move.w (a7)+, $33333333.l uses Op33df ----------
Op33df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33e0] move.w -(a0), $33333333.l uses Op33e0 ----------
Op33e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33e7] move.w -(a7), $33333333.l uses Op33e7 ----------
Op33e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33e8] move.w ($3333,a0), $33333333.l uses Op33e8 ----------
Op33e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33f0] move.w ($33,a0,d3.w*2), $33333333.l uses Op33f0 ----------
Op33f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33f8] move.w $3333.w, $33333333.l uses Op33f8 ----------
Op33f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33f9] move.w $33333333.l, $33333333.l uses Op33f9 ----------
Op33f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33fa] move.w ($3333,pc), $33333333.l; =3335 uses Op33fa ----------
Op33fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33fb] move.w ($33,pc,d3.w*2), $33333333.l; =35 uses Op33fb ----------
Op33fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33fc] move.w #$3333, $33333333.l uses Op33fc ----------
Op33fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [35c0] move.w d0, ($3333,pc); =3335 uses Op35c0 ----------
Op35c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [35d0] move.w (a0), ($3333,pc); =3335 uses Op35d0 ----------
Op35d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [35d8] move.w (a0)+, ($3333,pc); =3335 uses Op35d8 ----------
Op35d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [35df] move.w (a7)+, ($3333,pc); =3335 uses Op35df ----------
Op35df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [35e0] move.w -(a0), ($3333,pc); =3335 uses Op35e0 ----------
Op35e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [35e7] move.w -(a7), ($3333,pc); =3335 uses Op35e7 ----------
Op35e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [35e8] move.w ($3333,a0), ($3333,pc); =3337 uses Op35e8 ----------
Op35e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [35f0] move.w ($33,a0,d3.w*2), ($3333,pc); =3337 uses Op35f0 ----------
Op35f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [35f8] move.w $3333.w, ($3333,pc); =3337 uses Op35f8 ----------
Op35f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [35f9] move.w $33333333.l, ($3333,pc); =3339 uses Op35f9 ----------
Op35f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [35fa] move.w ($3333,pc), ($3333,pc); =3337 uses Op35fa ----------
Op35fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [35fb] move.w ($33,pc,d3.w*2), ($3333,pc); =3337 uses Op35fb ----------
Op35fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [35fc] move.w #$3333, ($3333,pc); =3337 uses Op35fc ----------
Op35fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [37c0] move.w d0, ($33,pc,d3.w*2); =35 uses Op37c0 ----------
Op37c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [37d0] move.w (a0), ($33,pc,d3.w*2); =35 uses Op37d0 ----------
Op37d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [37d8] move.w (a0)+, ($33,pc,d3.w*2); =35 uses Op37d8 ----------
Op37d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [37df] move.w (a7)+, ($33,pc,d3.w*2); =35 uses Op37df ----------
Op37df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [37e0] move.w -(a0), ($33,pc,d3.w*2); =35 uses Op37e0 ----------
Op37e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [37e7] move.w -(a7), ($33,pc,d3.w*2); =35 uses Op37e7 ----------
Op37e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [37e8] move.w ($3333,a0), ($33,pc,d3.w*2); =37 uses Op37e8 ----------
Op37e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [37f0] move.w ($33,a0,d3.w*2), ($33,pc,d3.w*2); =37 uses Op37f0 ----------
Op37f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [37f8] move.w $3333.w, ($33,pc,d3.w*2); =37 uses Op37f8 ----------
Op37f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [37f9] move.w $33333333.l, ($33,pc,d3.w*2); =39 uses Op37f9 ----------
Op37f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [37fa] move.w ($3333,pc), ($33,pc,d3.w*2); =37 uses Op37fa ----------
Op37fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [37fb] move.w ($33,pc,d3.w*2), ($33,pc,d3.w*2); =37 uses Op37fb ----------
Op37fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [37fc] move.w #$3333, ($33,pc,d3.w*2); =37 uses Op37fc ----------
Op37fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ec0] move.w d0, (a7)+ uses Op3ec0 ----------
Op3ec0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ed0] move.w (a0), (a7)+ uses Op3ed0 ----------
Op3ed0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ed8] move.w (a0)+, (a7)+ uses Op3ed8 ----------
Op3ed8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3edf] move.w (a7)+, (a7)+ uses Op3edf ----------
Op3edf:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ee0] move.w -(a0), (a7)+ uses Op3ee0 ----------
Op3ee0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ee7] move.w -(a7), (a7)+ uses Op3ee7 ----------
Op3ee7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ee8] move.w ($3333,a0), (a7)+ uses Op3ee8 ----------
Op3ee8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ef0] move.w ($33,a0,d3.w*2), (a7)+ uses Op3ef0 ----------
Op3ef0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ef8] move.w $3333.w, (a7)+ uses Op3ef8 ----------
Op3ef8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ef9] move.w $33333333.l, (a7)+ uses Op3ef9 ----------
Op3ef9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3efa] move.w ($3333,pc), (a7)+; =3335 uses Op3efa ----------
Op3efa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3efb] move.w ($33,pc,d3.w*2), (a7)+; =35 uses Op3efb ----------
Op3efb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3efc] move.w #$3333, (a7)+ uses Op3efc ----------
Op3efc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f00] move.w d0, -(a7) uses Op3f00 ----------
Op3f00:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f10] move.w (a0), -(a7) uses Op3f10 ----------
Op3f10:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f18] move.w (a0)+, -(a7) uses Op3f18 ----------
Op3f18:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f1f] move.w (a7)+, -(a7) uses Op3f1f ----------
Op3f1f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f20] move.w -(a0), -(a7) uses Op3f20 ----------
Op3f20:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f27] move.w -(a7), -(a7) uses Op3f27 ----------
Op3f27:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f28] move.w ($3333,a0), -(a7) uses Op3f28 ----------
Op3f28:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f30] move.w ($33,a0,d3.w*2), -(a7) uses Op3f30 ----------
Op3f30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f38] move.w $3333.w, -(a7) uses Op3f38 ----------
Op3f38:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f39] move.w $33333333.l, -(a7) uses Op3f39 ----------
Op3f39:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f3a] move.w ($3333,pc), -(a7); =3335 uses Op3f3a ----------
Op3f3a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f3b] move.w ($33,pc,d3.w*2), -(a7); =35 uses Op3f3b ----------
Op3f3b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f3c] move.w #$3333, -(a7) uses Op3f3c ----------
Op3f3c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  adds r1,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4000] negx.b d0 uses Op4000 ----------
Op4000:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4010] negx.b (a0) uses Op4010 ----------
Op4010:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4018] negx.b (a0)+ uses Op4018 ----------
Op4018:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [401f] negx.b (a7)+ uses Op401f ----------
Op401f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4020] negx.b -(a0) uses Op4020 ----------
Op4020:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4027] negx.b -(a7) uses Op4027 ----------
Op4027:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4028] negx.b ($3333,a0) uses Op4028 ----------
Op4028:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4030] negx.b ($33,a0,d3.w*2) uses Op4030 ----------
Op4030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4038] negx.b $3333.w uses Op4038 ----------
Op4038:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4039] negx.b $33333333.l uses Op4039 ----------
Op4039:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [403a] negx.b ($3333,pc); =3335 uses Op403a ----------
Op403a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [403b] negx.b ($33,pc,d3.w*2); =35 uses Op403b ----------
Op403b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4040] negx.w d0 uses Op4040 ----------
Op4040:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4050] negx.w (a0) uses Op4050 ----------
Op4050:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4058] negx.w (a0)+ uses Op4058 ----------
Op4058:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [405f] negx.w (a7)+ uses Op405f ----------
Op405f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4060] negx.w -(a0) uses Op4060 ----------
Op4060:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4067] negx.w -(a7) uses Op4067 ----------
Op4067:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4068] negx.w ($3333,a0) uses Op4068 ----------
Op4068:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4070] negx.w ($33,a0,d3.w*2) uses Op4070 ----------
Op4070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4078] negx.w $3333.w uses Op4078 ----------
Op4078:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4079] negx.w $33333333.l uses Op4079 ----------
Op4079:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [407a] negx.w ($3333,pc); =3335 uses Op407a ----------
Op407a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [407b] negx.w ($33,pc,d3.w*2); =35 uses Op407b ----------
Op407b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4080] negx.l d0 uses Op4080 ----------
Op4080:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4090] negx.l (a0) uses Op4090 ----------
Op4090:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4098] negx.l (a0)+ uses Op4098 ----------
Op4098:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [409f] negx.l (a7)+ uses Op409f ----------
Op409f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40a0] negx.l -(a0) uses Op40a0 ----------
Op40a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40a7] negx.l -(a7) uses Op40a7 ----------
Op40a7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40a8] negx.l ($3333,a0) uses Op40a8 ----------
Op40a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40b0] negx.l ($33,a0,d3.w*2) uses Op40b0 ----------
Op40b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40b8] negx.l $3333.w uses Op40b8 ----------
Op40b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40b9] negx.l $33333333.l uses Op40b9 ----------
Op40b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40ba] negx.l ($3333,pc); =3335 uses Op40ba ----------
Op40ba:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40bb] negx.l ($33,pc,d3.w*2); =35 uses Op40bb ----------
Op40bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Negx:
  mov r11,r9 ;@ save old zero flag
  rsbs r1,r0,#0
  mov r3,#0
  movcs r3,#1 ;@ we had a carry clear (inverted in 68k)
  ldrb r2, [r7,#0x45]
  mov r2,r2,lsl #30 ;@ clear the undefined bits
  subs r1,r1,r2, lsr #31
  mrs r9,cpsr ;@ r9=flags
  eorcs r3,r3,#1 ;@ deterimne carry flag
  tst r3,r3
  orrne r9,r9,#0x20000000
  biceq r9,r9,#0x20000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40c0] move sr, d0 uses Op40c0 ----------
Op40c0:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode40c0 ;@ No

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode40c0:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40d0] move sr, (a0) uses Op40d0 ----------
Op40d0:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode40d0 ;@ No

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode40d0:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40d8] move sr, (a0)+ uses Op40d8 ----------
Op40d8:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode40d8 ;@ No

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode40d8:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40df] move sr, (a7)+ uses Op40df ----------
Op40df:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode40df ;@ No

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode40df:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40e0] move sr, -(a0) uses Op40e0 ----------
Op40e0:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode40e0 ;@ No

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode40e0:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40e7] move sr, -(a7) uses Op40e7 ----------
Op40e7:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode40e7 ;@ No

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode40e7:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40e8] move sr, ($3333,a0) uses Op40e8 ----------
Op40e8:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode40e8 ;@ No

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode40e8:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40f0] move sr, ($33,a0,d3.w*2) uses Op40f0 ----------
Op40f0:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode40f0 ;@ No

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode40f0:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40f8] move sr, $3333.w uses Op40f8 ----------
Op40f8:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode40f8 ;@ No

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode40f8:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40f9] move sr, $33333333.l uses Op40f9 ----------
Op40f9:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode40f9 ;@ No

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode40f9:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40fa] move sr, ($3333,pc); =3335 uses Op40fa ----------
Op40fa:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode40fa ;@ No

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode40fa:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40fb] move sr, ($33,pc,d3.w*2); =35 uses Op40fb ----------
Op40fb:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode40fb ;@ No

  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x02
  orr r1,r1,r2,lsl #8
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode40fb:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41d0] lea (a0), a0 uses Op41d0 ----------
Op41d0:
;@ EaCalc : Get '(a0)' into r1:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r1,[r7,r2]
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41e8] lea ($3333,a0), a0 uses Op41e8 ----------
Op41e8:
;@ EaCalc : Get '($3333,a0)' into r1:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r1,r0,r2 ;@ Add on offset
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41f0] lea ($33,a0,d3.w*2), a0 uses Op41f0 ----------
Op41f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r1:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r1,r2,r3 ;@ r1=Disp+An+Rn
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41f8] lea $3333.w, a0 uses Op41f8 ----------
Op41f8:
;@ EaCalc : Get '$3333.w' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch Absolute Short address
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41f9] lea $33333333.l, a0 uses Op41f9 ----------
Op41f9:
;@ EaCalc : Get '$33333333.l' into r1:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r1,r0,r2,lsl #16
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41fa] lea ($3333,pc), a0; =3335 uses Op41fa ----------
Op41fa:
;@ EaCalc : Get '($3333,pc)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r1,r0,r2 ;@ ($nn,PC)
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41fb] lea ($33,pc,d3.w*2), a0; =35 uses Op41fb ----------
Op41fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r1:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r1,r2,r0 ;@ r1=Disp+PC+Rn
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4200] clr.b d0 uses Op4200 ----------
Op4200:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4210] clr.b (a0) uses Op4210 ----------
Op4210:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4218] clr.b (a0)+ uses Op4218 ----------
Op4218:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [421f] clr.b (a7)+ uses Op421f ----------
Op421f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4220] clr.b -(a0) uses Op4220 ----------
Op4220:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4227] clr.b -(a7) uses Op4227 ----------
Op4227:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4228] clr.b ($3333,a0) uses Op4228 ----------
Op4228:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4230] clr.b ($33,a0,d3.w*2) uses Op4230 ----------
Op4230:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4238] clr.b $3333.w uses Op4238 ----------
Op4238:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4239] clr.b $33333333.l uses Op4239 ----------
Op4239:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [423a] clr.b ($3333,pc); =3335 uses Op423a ----------
Op423a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [423b] clr.b ($33,pc,d3.w*2); =35 uses Op423b ----------
Op423b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4240] clr.w d0 uses Op4240 ----------
Op4240:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4250] clr.w (a0) uses Op4250 ----------
Op4250:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4258] clr.w (a0)+ uses Op4258 ----------
Op4258:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [425f] clr.w (a7)+ uses Op425f ----------
Op425f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4260] clr.w -(a0) uses Op4260 ----------
Op4260:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4267] clr.w -(a7) uses Op4267 ----------
Op4267:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4268] clr.w ($3333,a0) uses Op4268 ----------
Op4268:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4270] clr.w ($33,a0,d3.w*2) uses Op4270 ----------
Op4270:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4278] clr.w $3333.w uses Op4278 ----------
Op4278:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4279] clr.w $33333333.l uses Op4279 ----------
Op4279:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [427a] clr.w ($3333,pc); =3335 uses Op427a ----------
Op427a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [427b] clr.w ($33,pc,d3.w*2); =35 uses Op427b ----------
Op427b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4280] clr.l d0 uses Op4280 ----------
Op4280:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4290] clr.l (a0) uses Op4290 ----------
Op4290:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4298] clr.l (a0)+ uses Op4298 ----------
Op4298:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [429f] clr.l (a7)+ uses Op429f ----------
Op429f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42a0] clr.l -(a0) uses Op42a0 ----------
Op42a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42a7] clr.l -(a7) uses Op42a7 ----------
Op42a7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42a8] clr.l ($3333,a0) uses Op42a8 ----------
Op42a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42b0] clr.l ($33,a0,d3.w*2) uses Op42b0 ----------
Op42b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42b8] clr.l $3333.w uses Op42b8 ----------
Op42b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42b9] clr.l $33333333.l uses Op42b9 ----------
Op42b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42ba] clr.l ($3333,pc); =3335 uses Op42ba ----------
Op42ba:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42bb] clr.l ($33,pc,d3.w*2); =35 uses Op42bb ----------
Op42bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42c0] move ccr, d0 uses Op42c0 ----------
Op42c0:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42d0] move ccr, (a0) uses Op42d0 ----------
Op42d0:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42d8] move ccr, (a0)+ uses Op42d8 ----------
Op42d8:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42df] move ccr, (a7)+ uses Op42df ----------
Op42df:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42e0] move ccr, -(a0) uses Op42e0 ----------
Op42e0:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42e7] move ccr, -(a7) uses Op42e7 ----------
Op42e7:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42e8] move ccr, ($3333,a0) uses Op42e8 ----------
Op42e8:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42f0] move ccr, ($33,a0,d3.w*2) uses Op42f0 ----------
Op42f0:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42f8] move ccr, $3333.w uses Op42f8 ----------
Op42f8:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42f9] move ccr, $33333333.l uses Op42f9 ----------
Op42f9:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42fa] move ccr, ($3333,pc); =3335 uses Op42fa ----------
Op42fa:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42fb] move ccr, ($33,pc,d3.w*2); =35 uses Op42fb ----------
Op42fb:
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r0,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r0,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r0,[r7,#0x45]  ;@ X bit
  and r0,r0,#0x02
  orr r1,r1,r0,lsl #3 ;@ ___XNZVC

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4400] neg.b d0 uses Op4400 ----------
Op4400:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]

;@ Neg:
  mov r0,r0,asl#24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4410] neg.b (a0) uses Op4410 ----------
Op4410:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,asl#24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#24
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4418] neg.b (a0)+ uses Op4418 ----------
Op4418:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,asl#24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#24
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [441f] neg.b (a7)+ uses Op441f ----------
Op441f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,asl#24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#24
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4420] neg.b -(a0) uses Op4420 ----------
Op4420:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,asl#24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#24
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4427] neg.b -(a7) uses Op4427 ----------
Op4427:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,asl#24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#24
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4428] neg.b ($3333,a0) uses Op4428 ----------
Op4428:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,asl#24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#24
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4430] neg.b ($33,a0,d3.w*2) uses Op4430 ----------
Op4430:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,asl#24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#24
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4438] neg.b $3333.w uses Op4438 ----------
Op4438:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,asl#24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#24
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4439] neg.b $33333333.l uses Op4439 ----------
Op4439:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,asl#24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#24
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [443a] neg.b ($3333,pc); =3335 uses Op443a ----------
Op443a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,asl#24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#24
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [443b] neg.b ($33,pc,d3.w*2); =35 uses Op443b ----------
Op443b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Neg:
  mov r0,r0,asl#24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#24
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4440] neg.w d0 uses Op4440 ----------
Op4440:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]

;@ Neg:
  mov r0,r0,asl#16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4450] neg.w (a0) uses Op4450 ----------
Op4450:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,asl#16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#16
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4458] neg.w (a0)+ uses Op4458 ----------
Op4458:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,asl#16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#16
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [445f] neg.w (a7)+ uses Op445f ----------
Op445f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,asl#16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#16
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4460] neg.w -(a0) uses Op4460 ----------
Op4460:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,asl#16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#16
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4467] neg.w -(a7) uses Op4467 ----------
Op4467:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,asl#16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#16
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4468] neg.w ($3333,a0) uses Op4468 ----------
Op4468:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,asl#16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#16
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4470] neg.w ($33,a0,d3.w*2) uses Op4470 ----------
Op4470:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,asl#16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#16
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4478] neg.w $3333.w uses Op4478 ----------
Op4478:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,asl#16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#16
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4479] neg.w $33333333.l uses Op4479 ----------
Op4479:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,asl#16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#16
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [447a] neg.w ($3333,pc); =3335 uses Op447a ----------
Op447a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,asl#16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#16
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [447b] neg.w ($33,pc,d3.w*2); =35 uses Op447b ----------
Op447b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Neg:
  mov r0,r0,asl#16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
  mov r1,r1,asr#16
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4480] neg.l d0 uses Op4480 ----------
Op4480:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4490] neg.l (a0) uses Op4490 ----------
Op4490:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4498] neg.l (a0)+ uses Op4498 ----------
Op4498:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [449f] neg.l (a7)+ uses Op449f ----------
Op449f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44a0] neg.l -(a0) uses Op44a0 ----------
Op44a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44a7] neg.l -(a7) uses Op44a7 ----------
Op44a7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44a8] neg.l ($3333,a0) uses Op44a8 ----------
Op44a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44b0] neg.l ($33,a0,d3.w*2) uses Op44b0 ----------
Op44b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44b8] neg.l $3333.w uses Op44b8 ----------
Op44b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44b9] neg.l $33333333.l uses Op44b9 ----------
Op44b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44ba] neg.l ($3333,pc); =3335 uses Op44ba ----------
Op44ba:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44bb] neg.l ($33,pc,d3.w*2); =35 uses Op44bb ----------
Op44bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44c0] move d0, ccr uses Op44c0 ----------
Op44c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44d0] move (a0), ccr uses Op44d0 ----------
Op44d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44d8] move (a0)+, ccr uses Op44d8 ----------
Op44d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44df] move (a7)+, ccr uses Op44df ----------
Op44df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44e0] move -(a0), ccr uses Op44e0 ----------
Op44e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44e7] move -(a7), ccr uses Op44e7 ----------
Op44e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44e8] move ($3333,a0), ccr uses Op44e8 ----------
Op44e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44f0] move ($33,a0,d3.w*2), ccr uses Op44f0 ----------
Op44f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44f8] move $3333.w, ccr uses Op44f8 ----------
Op44f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44f9] move $33333333.l, ccr uses Op44f9 ----------
Op44f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44fa] move ($3333,pc), ccr; =3335 uses Op44fa ----------
Op44fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44fb] move ($33,pc,d3.w*2), ccr; =35 uses Op44fb ----------
Op44fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44fc] move #$3333, ccr uses Op44fc ----------
Op44fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4600] not.b d0 uses Op4600 ----------
Op4600:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4610] not.b (a0) uses Op4610 ----------
Op4610:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4618] not.b (a0)+ uses Op4618 ----------
Op4618:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [461f] not.b (a7)+ uses Op461f ----------
Op461f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4620] not.b -(a0) uses Op4620 ----------
Op4620:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4627] not.b -(a7) uses Op4627 ----------
Op4627:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4628] not.b ($3333,a0) uses Op4628 ----------
Op4628:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4630] not.b ($33,a0,d3.w*2) uses Op4630 ----------
Op4630:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4638] not.b $3333.w uses Op4638 ----------
Op4638:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4639] not.b $33333333.l uses Op4639 ----------
Op4639:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [463a] not.b ($3333,pc); =3335 uses Op463a ----------
Op463a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [463b] not.b ($33,pc,d3.w*2); =35 uses Op463b ----------
Op463b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4640] not.w d0 uses Op4640 ----------
Op4640:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4650] not.w (a0) uses Op4650 ----------
Op4650:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4658] not.w (a0)+ uses Op4658 ----------
Op4658:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [465f] not.w (a7)+ uses Op465f ----------
Op465f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4660] not.w -(a0) uses Op4660 ----------
Op4660:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4667] not.w -(a7) uses Op4667 ----------
Op4667:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4668] not.w ($3333,a0) uses Op4668 ----------
Op4668:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4670] not.w ($33,a0,d3.w*2) uses Op4670 ----------
Op4670:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4678] not.w $3333.w uses Op4678 ----------
Op4678:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4679] not.w $33333333.l uses Op4679 ----------
Op4679:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [467a] not.w ($3333,pc); =3335 uses Op467a ----------
Op467a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [467b] not.w ($33,pc,d3.w*2); =35 uses Op467b ----------
Op467b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4680] not.l d0 uses Op4680 ----------
Op4680:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4690] not.l (a0) uses Op4690 ----------
Op4690:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4698] not.l (a0)+ uses Op4698 ----------
Op4698:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [469f] not.l (a7)+ uses Op469f ----------
Op469f:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46a0] not.l -(a0) uses Op46a0 ----------
Op46a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46a7] not.l -(a7) uses Op46a7 ----------
Op46a7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46a8] not.l ($3333,a0) uses Op46a8 ----------
Op46a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46b0] not.l ($33,a0,d3.w*2) uses Op46b0 ----------
Op46b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46b8] not.l $3333.w uses Op46b8 ----------
Op46b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46b9] not.l $33333333.l uses Op46b9 ----------
Op46b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46ba] not.l ($3333,pc); =3335 uses Op46ba ----------
Op46ba:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46bb] not.l ($33,pc,d3.w*2); =35 uses Op46bb ----------
Op46bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46c0] move d0, sr uses Op46c0 ----------
Op46c0:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46c0 ;@ No

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46c0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46c0:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46c0:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46d0] move (a0), sr uses Op46d0 ----------
Op46d0:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46d0 ;@ No

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46d0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46d0:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46d0:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46d8] move (a0)+, sr uses Op46d8 ----------
Op46d8:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46d8 ;@ No

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46d8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46d8:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46d8:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46df] move (a7)+, sr uses Op46df ----------
Op46df:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46df ;@ No

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46df
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46df:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46df:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46e0] move -(a0), sr uses Op46e0 ----------
Op46e0:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46e0 ;@ No

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46e0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46e0:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46e0:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46e7] move -(a7), sr uses Op46e7 ----------
Op46e7:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46e7 ;@ No

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46e7
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46e7:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46e7:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46e8] move ($3333,a0), sr uses Op46e8 ----------
Op46e8:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46e8 ;@ No

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46e8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46e8:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46e8:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46f0] move ($33,a0,d3.w*2), sr uses Op46f0 ----------
Op46f0:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46f0 ;@ No

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46f0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46f0:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46f0:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46f8] move $3333.w, sr uses Op46f8 ----------
Op46f8:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46f8 ;@ No

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46f8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46f8:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46f8:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46f9] move $33333333.l, sr uses Op46f9 ----------
Op46f9:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46f9 ;@ No

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46f9
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46f9:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46f9:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46fa] move ($3333,pc), sr; =3335 uses Op46fa ----------
Op46fa:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46fa ;@ No

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46fa
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46fa:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46fa:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46fb] move ($33,pc,d3.w*2), sr; =35 uses Op46fb ----------
Op46fb:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46fb ;@ No

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46fb
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46fb:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46fb:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46fc] move #$3333, sr uses Op46fc ----------
Op46fc:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode46fc ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap46fc
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap46fc:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode46fc:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4840] swap d0 uses Op4840 ----------
Op4840:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r1,r0,ror #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4850] pea (a0) uses Op4850 ----------
Op4850:
;@ EaCalc : Get '(a0)' into r1:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r1,[r7,r2]

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4868] pea ($3333,a0) uses Op4868 ----------
Op4868:
;@ EaCalc : Get '($3333,a0)' into r1:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r1,r0,r2 ;@ Add on offset

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4870] pea ($33,a0,d3.w*2) uses Op4870 ----------
Op4870:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r1:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r1,r2,r3 ;@ r1=Disp+An+Rn

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4878] pea $3333.w uses Op4878 ----------
Op4878:
;@ EaCalc : Get '$3333.w' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch Absolute Short address

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4879] pea $33333333.l uses Op4879 ----------
Op4879:
;@ EaCalc : Get '$33333333.l' into r1:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r1,r0,r2,lsl #16

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [487a] pea ($3333,pc); =3335 uses Op487a ----------
Op487a:
;@ EaCalc : Get '($3333,pc)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r1,r0,r2 ;@ ($nn,PC)

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [487b] pea ($33,pc,d3.w*2); =35 uses Op487b ----------
Op487b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r1:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r1,r2,r0 ;@ r1=Disp+PC+Rn

  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4880] ext.w d0 uses Op4880 ----------
Op4880:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]

  mov r0,r0,asl #24
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r0,asr #24

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4890] movem.w d0-d1/d4-d5/a0-a1/a4-a5, (a0) uses Op4890 ----------
Op4890:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4890:
  tst r11,#1
  beq SkipReg4890

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a0)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4890:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4890

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4898] movem.w d0-d1/d4-d5/a0-a1/a4-a5, (a0)+ uses Op4898 ----------
Op4898:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4898:
  tst r11,#1
  beq SkipReg4898

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a0)+' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4898:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4898

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#0 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [489f] movem.w d0-d1/d4-d5/a0-a1/a4-a5, (a7)+ uses Op489f ----------
Op489f:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg489f:
  tst r11,#1
  beq SkipReg489f

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a7)+' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg489f:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg489f

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#0 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48a0] movem.w d2-d3/d6-d7/a2-a3/a6-a7, -(a0) uses Op48a0 ----------
Op48a0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0x3c ;@ order reversed for -(An)

MoreReg48a0:
  tst r11,#1
  beq SkipReg48a0

  sub r9,r9,#2 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '-(a0)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  sub r5,r5,#4 ;@ Take some cycles

SkipReg48a0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#-4 ;@ r10=Next Register
  bne MoreReg48a0

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48a7] movem.w d2-d3/d6-d7/a2-a3/a6-a7, -(a7) uses Op48a7 ----------
Op48a7:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0x3c ;@ order reversed for -(An)

MoreReg48a7:
  tst r11,#1
  beq SkipReg48a7

  sub r9,r9,#2 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '-(a7)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  sub r5,r5,#4 ;@ Take some cycles

SkipReg48a7:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#-4 ;@ r10=Next Register
  bne MoreReg48a7

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48a8] movem.w d0-d1/d4-d5/a0-a1/a4-a5, ($3333,a0) uses Op48a8 ----------
Op48a8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($3333,a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r9,r0,r2 ;@ Add on offset
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48a8:
  tst r11,#1
  beq SkipReg48a8

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($3333,a0)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg48a8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48a8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48b0] movem.w d0-d1/d4-d5/a0-a1/a4-a5, ($33,a0,d3.w*2) uses Op48b0 ----------
Op48b0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r9:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r9,r2,r3 ;@ r9=Disp+An+Rn
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48b0:
  tst r11,#1
  beq SkipReg48b0

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg48b0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48b0

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48b8] movem.w d0-d1/d4-d5/a0-a1/a4-a5, $3333.w uses Op48b8 ----------
Op48b8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$3333.w' into r9:
  ldrsh r9,[r4],#2 ;@ Fetch Absolute Short address
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48b8:
  tst r11,#1
  beq SkipReg48b8

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$3333.w' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg48b8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48b8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48b9] movem.w d0-d1/d4-d5/a0-a1/a4-a5, $33333333.l uses Op48b9 ----------
Op48b9:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$33333333.l' into r9:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r9,r0,r2,lsl #16
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48b9:
  tst r11,#1
  beq SkipReg48b9

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$33333333.l' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg48b9:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48b9

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48c0] ext.l d0 uses Op48c0 ----------
Op48c0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r0,r0,asl #16
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r0,asr #16

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48d0] movem.l d0-d1/d4-d5/a0-a1/a4-a5, (a0) uses Op48d0 ----------
Op48d0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48d0:
  tst r11,#1
  beq SkipReg48d0

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a0)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg48d0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48d0

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48d8] movem.l d0-d1/d4-d5/a0-a1/a4-a5, (a0)+ uses Op48d8 ----------
Op48d8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48d8:
  tst r11,#1
  beq SkipReg48d8

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a0)+' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg48d8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48d8

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#0 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48df] movem.l d0-d1/d4-d5/a0-a1/a4-a5, (a7)+ uses Op48df ----------
Op48df:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48df:
  tst r11,#1
  beq SkipReg48df

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a7)+' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg48df:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48df

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#0 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48e0] movem.l d2-d3/d6-d7/a2-a3/a6-a7, -(a0) uses Op48e0 ----------
Op48e0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0x3c ;@ order reversed for -(An)

MoreReg48e0:
  tst r11,#1
  beq SkipReg48e0

  sub r9,r9,#4 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '-(a0)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  sub r5,r5,#8 ;@ Take some cycles

SkipReg48e0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#-4 ;@ r10=Next Register
  bne MoreReg48e0

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48e7] movem.l d2-d3/d6-d7/a2-a3/a6-a7, -(a7) uses Op48e7 ----------
Op48e7:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0x3c ;@ order reversed for -(An)

MoreReg48e7:
  tst r11,#1
  beq SkipReg48e7

  sub r9,r9,#4 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '-(a7)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  sub r5,r5,#8 ;@ Take some cycles

SkipReg48e7:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#-4 ;@ r10=Next Register
  bne MoreReg48e7

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48e8] movem.l d0-d1/d4-d5/a0-a1/a4-a5, ($3333,a0) uses Op48e8 ----------
Op48e8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($3333,a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r9,r0,r2 ;@ Add on offset
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48e8:
  tst r11,#1
  beq SkipReg48e8

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($3333,a0)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg48e8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48e8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48f0] movem.l d0-d1/d4-d5/a0-a1/a4-a5, ($33,a0,d3.w*2) uses Op48f0 ----------
Op48f0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r9:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r9,r2,r3 ;@ r9=Disp+An+Rn
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48f0:
  tst r11,#1
  beq SkipReg48f0

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg48f0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48f0

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48f8] movem.l d0-d1/d4-d5/a0-a1/a4-a5, $3333.w uses Op48f8 ----------
Op48f8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$3333.w' into r9:
  ldrsh r9,[r4],#2 ;@ Fetch Absolute Short address
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48f8:
  tst r11,#1
  beq SkipReg48f8

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$3333.w' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg48f8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48f8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48f9] movem.l d0-d1/d4-d5/a0-a1/a4-a5, $33333333.l uses Op48f9 ----------
Op48f9:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$33333333.l' into r9:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r9,r0,r2,lsl #16
;@ r10=Register Index*4:
  mov r10,#0

MoreReg48f9:
  tst r11,#1
  beq SkipReg48f9

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$33333333.l' (address in r9):
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg48f9:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg48f9

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a00] tst.b d0 uses Op4a00 ----------
Op4a00:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsb r0,[r7,r0]

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a10] tst.b (a0) uses Op4a10 ----------
Op4a10:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a18] tst.b (a0)+ uses Op4a18 ----------
Op4a18:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a1f] tst.b (a7)+ uses Op4a1f ----------
Op4a1f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a20] tst.b -(a0) uses Op4a20 ----------
Op4a20:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a27] tst.b -(a7) uses Op4a27 ----------
Op4a27:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a28] tst.b ($3333,a0) uses Op4a28 ----------
Op4a28:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a30] tst.b ($33,a0,d3.w*2) uses Op4a30 ----------
Op4a30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a38] tst.b $3333.w uses Op4a38 ----------
Op4a38:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a39] tst.b $33333333.l uses Op4a39 ----------
Op4a39:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a3a] tst.b ($3333,pc); =3335 uses Op4a3a ----------
Op4a3a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a3b] tst.b ($33,pc,d3.w*2); =35 uses Op4a3b ----------
Op4a3b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24
  mov r0,r0,asr #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a40] tst.w d0 uses Op4a40 ----------
Op4a40:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldrsh r0,[r7,r0]

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a50] tst.w (a0) uses Op4a50 ----------
Op4a50:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a58] tst.w (a0)+ uses Op4a58 ----------
Op4a58:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a5f] tst.w (a7)+ uses Op4a5f ----------
Op4a5f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a60] tst.w -(a0) uses Op4a60 ----------
Op4a60:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a67] tst.w -(a7) uses Op4a67 ----------
Op4a67:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a68] tst.w ($3333,a0) uses Op4a68 ----------
Op4a68:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a70] tst.w ($33,a0,d3.w*2) uses Op4a70 ----------
Op4a70:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a78] tst.w $3333.w uses Op4a78 ----------
Op4a78:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a79] tst.w $33333333.l uses Op4a79 ----------
Op4a79:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a7a] tst.w ($3333,pc); =3335 uses Op4a7a ----------
Op4a7a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a7b] tst.w ($33,pc,d3.w*2); =35 uses Op4a7b ----------
Op4a7b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a80] tst.l d0 uses Op4a80 ----------
Op4a80:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a90] tst.l (a0) uses Op4a90 ----------
Op4a90:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a98] tst.l (a0)+ uses Op4a98 ----------
Op4a98:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a9f] tst.l (a7)+ uses Op4a9f ----------
Op4a9f:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4aa0] tst.l -(a0) uses Op4aa0 ----------
Op4aa0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4aa7] tst.l -(a7) uses Op4aa7 ----------
Op4aa7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4aa8] tst.l ($3333,a0) uses Op4aa8 ----------
Op4aa8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ab0] tst.l ($33,a0,d3.w*2) uses Op4ab0 ----------
Op4ab0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ab8] tst.l $3333.w uses Op4ab8 ----------
Op4ab8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ab9] tst.l $33333333.l uses Op4ab9 ----------
Op4ab9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4aba] tst.l ($3333,pc); =3335 uses Op4aba ----------
Op4aba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4abb] tst.l ($33,pc,d3.w*2); =35 uses Op4abb ----------
Op4abb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4c90] movem.w (a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4c90 ----------
Op4c90:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4c90:
  tst r11,#1
  beq SkipReg4c90

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4c90:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4c90

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4c98] movem.w (a0)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4c98 ----------
Op4c98:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4c98:
  tst r11,#1
  beq SkipReg4c98

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)+' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4c98:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4c98

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#0 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4c9f] movem.w (a7)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4c9f ----------
Op4c9f:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4c9f:
  tst r11,#1
  beq SkipReg4c9f

  ;@ Copy memory to register:
;@ EaRead : Read '(a7)+' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4c9f:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4c9f

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#0 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ca0] movem.w -(a0), d2-d3/d6-d7/a2-a3/a6-a7 uses Op4ca0 ----------
Op4ca0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0x3c ;@ order reversed for -(An)

MoreReg4ca0:
  tst r11,#1
  beq SkipReg4ca0

  sub r9,r9,#2 ;@ Pre-decrement address
  ;@ Copy memory to register:
;@ EaRead : Read '-(a0)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4ca0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#-4 ;@ r10=Next Register
  bne MoreReg4ca0

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ca7] movem.w -(a7), d2-d3/d6-d7/a2-a3/a6-a7 uses Op4ca7 ----------
Op4ca7:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0x3c ;@ order reversed for -(An)

MoreReg4ca7:
  tst r11,#1
  beq SkipReg4ca7

  sub r9,r9,#2 ;@ Pre-decrement address
  ;@ Copy memory to register:
;@ EaRead : Read '-(a7)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4ca7:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#-4 ;@ r10=Next Register
  bne MoreReg4ca7

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ca8] movem.w ($3333,a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4ca8 ----------
Op4ca8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($3333,a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r9,r0,r2 ;@ Add on offset
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4ca8:
  tst r11,#1
  beq SkipReg4ca8

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,a0)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4ca8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4ca8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cb0] movem.w ($33,a0,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb0 ----------
Op4cb0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r9:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r9,r2,r3 ;@ r9=Disp+An+Rn
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cb0:
  tst r11,#1
  beq SkipReg4cb0

  ;@ Copy memory to register:
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4cb0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cb0

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cb8] movem.w $3333.w, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb8 ----------
Op4cb8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$3333.w' into r9:
  ldrsh r9,[r4],#2 ;@ Fetch Absolute Short address
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cb8:
  tst r11,#1
  beq SkipReg4cb8

  ;@ Copy memory to register:
;@ EaRead : Read '$3333.w' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4cb8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cb8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cb9] movem.w $33333333.l, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb9 ----------
Op4cb9:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$33333333.l' into r9:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r9,r0,r2,lsl #16
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cb9:
  tst r11,#1
  beq SkipReg4cb9

  ;@ Copy memory to register:
;@ EaRead : Read '$33333333.l' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4cb9:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cb9

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cba] movem.w ($3333,pc), d0-d1/d4-d5/a0-a1/a4-a5; =3337 uses Op4cba ----------
Op4cba:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($3333,pc)' into r9:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r9,r0,r2 ;@ ($nn,PC)
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cba:
  tst r11,#1
  beq SkipReg4cba

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,pc)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4cba:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cba

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cbb] movem.w ($33,pc,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5; =37 uses Op4cbb ----------
Op4cbb:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r9:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r9,r2,r0 ;@ r9=Disp+PC+Rn
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cbb:
  tst r11,#1
  beq SkipReg4cbb

  ;@ Copy memory to register:
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles

SkipReg4cbb:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cbb

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cd0] movem.l (a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cd0 ----------
Op4cd0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cd0:
  tst r11,#1
  beq SkipReg4cd0

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cd0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cd0

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cd8] movem.l (a0)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cd8 ----------
Op4cd8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cd8:
  tst r11,#1
  beq SkipReg4cd8

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)+' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cd8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cd8

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#0 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cdf] movem.l (a7)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cdf ----------
Op4cdf:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cdf:
  tst r11,#1
  beq SkipReg4cdf

  ;@ Copy memory to register:
;@ EaRead : Read '(a7)+' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cdf:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cdf

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#0 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ce0] movem.l -(a0), d2-d3/d6-d7/a2-a3/a6-a7 uses Op4ce0 ----------
Op4ce0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0x3c ;@ order reversed for -(An)

MoreReg4ce0:
  tst r11,#1
  beq SkipReg4ce0

  sub r9,r9,#4 ;@ Pre-decrement address
  ;@ Copy memory to register:
;@ EaRead : Read '-(a0)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4ce0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#-4 ;@ r10=Next Register
  bne MoreReg4ce0

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ce7] movem.l -(a7), d2-d3/d6-d7/a2-a3/a6-a7 uses Op4ce7 ----------
Op4ce7:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '(a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r9,[r7,r2]
;@ r10=Register Index*4:
  mov r10,#0x3c ;@ order reversed for -(An)

MoreReg4ce7:
  tst r11,#1
  beq SkipReg4ce7

  sub r9,r9,#4 ;@ Pre-decrement address
  ;@ Copy memory to register:
;@ EaRead : Read '-(a7)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4ce7:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#-4 ;@ r10=Next Register
  bne MoreReg4ce7

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r9 into register[r0]:
  str r9,[r7,r0,lsl #2]

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ce8] movem.l ($3333,a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4ce8 ----------
Op4ce8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($3333,a0)' into r9:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r9,r0,r2 ;@ Add on offset
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4ce8:
  tst r11,#1
  beq SkipReg4ce8

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,a0)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4ce8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4ce8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cf0] movem.l ($33,a0,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf0 ----------
Op4cf0:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r9:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r9,r2,r3 ;@ r9=Disp+An+Rn
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cf0:
  tst r11,#1
  beq SkipReg4cf0

  ;@ Copy memory to register:
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cf0:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cf0

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cf8] movem.l $3333.w, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf8 ----------
Op4cf8:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$3333.w' into r9:
  ldrsh r9,[r4],#2 ;@ Fetch Absolute Short address
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cf8:
  tst r11,#1
  beq SkipReg4cf8

  ;@ Copy memory to register:
;@ EaRead : Read '$3333.w' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cf8:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cf8

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cf9] movem.l $33333333.l, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf9 ----------
Op4cf9:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '$33333333.l' into r9:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r9,r0,r2,lsl #16
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cf9:
  tst r11,#1
  beq SkipReg4cf9

  ;@ Copy memory to register:
;@ EaRead : Read '$33333333.l' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cf9:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cf9

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cfa] movem.l ($3333,pc), d0-d1/d4-d5/a0-a1/a4-a5; =3337 uses Op4cfa ----------
Op4cfa:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($3333,pc)' into r9:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r9,r0,r2 ;@ ($nn,PC)
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cfa:
  tst r11,#1
  beq SkipReg4cfa

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,pc)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cfa:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cfa

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4cfb] movem.l ($33,pc,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5; =37 uses Op4cfb ----------
Op4cfb:
  stmdb sp!,{r9} ;@ Push r9
  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r9:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r9:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r9,r2,r0 ;@ r9=Disp+PC+Rn
;@ r10=Register Index*4:
  mov r10,#0

MoreReg4cfb:
  tst r11,#1
  beq SkipReg4cfb

  ;@ Copy memory to register:
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r9) into r0:
  mov r0,r9
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r9,r9,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles

SkipReg4cfb:
  movs r11,r11,lsr #1;@ Shift mask:
  add r10,r10,#4 ;@ r10=Next Register
  bne MoreReg4cfb

  ldmia sp!,{r9} ;@ Pop r9

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e40] trap #0 uses Op4e40 ----------
Op4e40:
  and r0,r8,#0xf ;@ Get trap number
  orr r0,r0,#0x20
  mov r0,r0,asl #2
  bl Exception

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#38 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e50] link a0,#$3333 uses Op4e50 ----------
Op4e50:
;@ Get An
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  orr r10,r10,#0x8 ;@ A0-7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsl #2]

  ldr r0,[r7,#0x3c] ;@ Get A7
  sub r0,r0,#4 ;@ A7-=4
  mov r11,r0

;@ Write An to Stack
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler
;@ Save to An
;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsl #2]

;@ Get offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  add r11,r11,r0 ;@ Add offset to A7
  str r11,[r7,#0x3c]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e58] unlk a0 uses Op4e58 ----------
Op4e58:
;@ Get An
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  orr r10,r10,#0x8 ;@ A0-7
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  add r11,r0,#4 ;@ A7+=4

;@ Pop An from stack:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  str r11,[r7,#0x3c] ;@ Save A7

;@ An = value from stack:
;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e60] move a0, usp uses Op4e60 ----------
Op4e60:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode4e60 ;@ No

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  str r0,[r7,#0x48] ;@ Put in USP

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode4e60:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e68] move usp, a0 uses Op4e68 ----------
Op4e68:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode4e68 ;@ No

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
  ldr r1,[r7,#0x48] ;@ Get from USP

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode4e68:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e70] reset uses Op4e70 ----------
Op4e70:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode4e70 ;@ No

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#124 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode4e70:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#124 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e71] nop uses Op4e71 ----------
Op4e71:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e72] stop uses Op4e72 ----------
Op4e72:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode4e72 ;@ No

  ldrh r0,[r4],#2 ;@ Fetch the immediate
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap4e72
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap4e72:

  mov r0,#1
  str r0,[r7,#0x58] ;@ stopped

  mov r5,#0 ;@ eat cycles

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#1 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode4e72:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#1 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e73] rte uses Op4e73 ----------
Op4e73:
  ldrb r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongMode4e73 ;@ No

;@ Pop SR:
  ldr r0,[r7,#0x3c]
  add r1,r0,#2 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  strb r0,[r7,#0x44] ;@ Store SR high

  ldr r10,[r7,#0x60] ;@ Get Memory base
;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  add r4,r0,r10 ;@ r4=Memory Base+PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

;@ A7 <-> OSP?
  and r11,r11,#0x20
  ldrb r1,[r7,#0x44] ;@ Get other SR high
  and r1,r1,#0x20
  teq r11,r1 ;@ r11 xor r1
  beq no_sp_swap4e73
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r1, [r7,#0x48] ;@ Get OSP
  str r1, [r7,#0x3C]
  str r11,[r7,#0x48]
no_sp_swap4e73:
;@ CheckInterrupt:
  ldrb r0,[r7,#0x47] ;@ Get IRQ level
  tst r0,r0
  blne DoInterrupt

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

WrongMode4e73:
  sub r4,r4,#2 ;@ this opcode wasn't executed - go back
  mov r0,#0x20 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e75] rts uses Op4e75 ----------
Op4e75:
  ldr r10,[r7,#0x60] ;@ Get Memory base
;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  add r4,r0,r10 ;@ r4=Memory Base+PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e77] rtr uses Op4e77 ----------
Op4e77:
;@ Pop SR:
  ldr r0,[r7,#0x3c]
  add r1,r0,#2 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsr #3    ;@ r2=___XN
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  strb r2,[r7,#0x45]  ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldr r10,[r7,#0x60] ;@ Get Memory base
;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  add r4,r0,r10 ;@ r4=Memory Base+PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e90] jsr (a0) uses Op4e90 ----------
Op4e90:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ea8] jsr ($3333,a0) uses Op4ea8 ----------
Op4ea8:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eb0] jsr ($33,a0,d3.w*2) uses Op4eb0 ----------
Op4eb0:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eb8] jsr $3333.w uses Op4eb8 ----------
Op4eb8:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eb9] jsr $33333333.l uses Op4eb9 ----------
Op4eb9:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eba] jsr ($3333,pc); =3335 uses Op4eba ----------
Op4eba:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ebb] jsr ($33,pc,d3.w*2); =35 uses Op4ebb ----------
Op4ebb:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ Jump - Get new PC from r0
;@ Jsr - Push old PC first
  sub r1,r4,r10 ;@ r1 = Old PC
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ed0] jmp (a0) uses Op4ed0 ----------
Op4ed0:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ee8] jmp ($3333,a0) uses Op4ee8 ----------
Op4ee8:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ef0] jmp ($33,a0,d3.w*2) uses Op4ef0 ----------
Op4ef0:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ef8] jmp $3333.w uses Op4ef8 ----------
Op4ef8:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ef9] jmp $33333333.l uses Op4ef9 ----------
Op4ef9:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4efa] jmp ($3333,pc); =3335 uses Op4efa ----------
Op4efa:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4efb] jmp ($33,pc,d3.w*2); =35 uses Op4efb ----------
Op4efb:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ Jump - Get new PC from r0
  add r4,r0,r10 ;@ r4 = Memory Base + New PC

;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5000] addq.b #8, d0 uses Op5000 ----------
Op5000:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5008] addq.b #8, a0 uses Op5008 ----------
Op5008:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  adds r1,r0,#0x0008

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5010] addq.b #8, (a0) uses Op5010 ----------
Op5010:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5018] addq.b #8, (a0)+ uses Op5018 ----------
Op5018:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5020] addq.b #8, -(a0) uses Op5020 ----------
Op5020:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5028] addq.b #8, ($3333,a0) uses Op5028 ----------
Op5028:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5030] addq.b #8, ($33,a0,d3.w*2) uses Op5030 ----------
Op5030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5038] addq.b #8, $3333.w uses Op5038 ----------
Op5038:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5039] addq.b #8, $33333333.l uses Op5039 ----------
Op5039:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [503a] addq.b #8, ($3333,pc); =3335 uses Op503a ----------
Op503a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [503b] addq.b #8, ($33,pc,d3.w*2); =35 uses Op503b ----------
Op503b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5040] addq.w #8, d0 uses Op5040 ----------
Op5040:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5050] addq.w #8, (a0) uses Op5050 ----------
Op5050:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5058] addq.w #8, (a0)+ uses Op5058 ----------
Op5058:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5060] addq.w #8, -(a0) uses Op5060 ----------
Op5060:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5068] addq.w #8, ($3333,a0) uses Op5068 ----------
Op5068:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5070] addq.w #8, ($33,a0,d3.w*2) uses Op5070 ----------
Op5070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5078] addq.w #8, $3333.w uses Op5078 ----------
Op5078:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5079] addq.w #8, $33333333.l uses Op5079 ----------
Op5079:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [507a] addq.w #8, ($3333,pc); =3335 uses Op507a ----------
Op507a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [507b] addq.w #8, ($33,pc,d3.w*2); =35 uses Op507b ----------
Op507b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5080] addq.l #8, d0 uses Op5080 ----------
Op5080:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5090] addq.l #8, (a0) uses Op5090 ----------
Op5090:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5098] addq.l #8, (a0)+ uses Op5098 ----------
Op5098:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50a0] addq.l #8, -(a0) uses Op50a0 ----------
Op50a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50a8] addq.l #8, ($3333,a0) uses Op50a8 ----------
Op50a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50b0] addq.l #8, ($33,a0,d3.w*2) uses Op50b0 ----------
Op50b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50b8] addq.l #8, $3333.w uses Op50b8 ----------
Op50b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50b9] addq.l #8, $33333333.l uses Op50b9 ----------
Op50b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50ba] addq.l #8, ($3333,pc); =3335 uses Op50ba ----------
Op50ba:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50bb] addq.l #8, ($33,pc,d3.w*2); =35 uses Op50bb ----------
Op50bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50c0] st d0 uses Op50c0 ----------
Op50c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1
  subal r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50c8] dbt d0, 3335 uses Op50c8 ----------
Op50c8:
;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd50c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd50c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50d0] st (a0) uses Op50d0 ----------
Op50d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50d8] st (a0)+ uses Op50d8 ----------
Op50d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50df] st (a7)+ uses Op50df ----------
Op50df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50e0] st -(a0) uses Op50e0 ----------
Op50e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50e7] st -(a7) uses Op50e7 ----------
Op50e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50e8] st ($3333,a0) uses Op50e8 ----------
Op50e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50f0] st ($33,a0,d3.w*2) uses Op50f0 ----------
Op50f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50f8] st $3333.w uses Op50f8 ----------
Op50f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50f9] st $33333333.l uses Op50f9 ----------
Op50f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50fa] st ($3333,pc); =3335 uses Op50fa ----------
Op50fa:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50fb] st ($33,pc,d3.w*2); =35 uses Op50fb ----------
Op50fb:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnal r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5100] subq.b #8, d0 uses Op5100 ----------
Op5100:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5108] subq.b #8, a0 uses Op5108 ----------
Op5108:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  subs r1,r0,#0x0008

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5110] subq.b #8, (a0) uses Op5110 ----------
Op5110:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5118] subq.b #8, (a0)+ uses Op5118 ----------
Op5118:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5120] subq.b #8, -(a0) uses Op5120 ----------
Op5120:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5128] subq.b #8, ($3333,a0) uses Op5128 ----------
Op5128:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5130] subq.b #8, ($33,a0,d3.w*2) uses Op5130 ----------
Op5130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5138] subq.b #8, $3333.w uses Op5138 ----------
Op5138:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5139] subq.b #8, $33333333.l uses Op5139 ----------
Op5139:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [513a] subq.b #8, ($3333,pc); =3335 uses Op513a ----------
Op513a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [513b] subq.b #8, ($33,pc,d3.w*2); =35 uses Op513b ----------
Op513b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5140] subq.w #8, d0 uses Op5140 ----------
Op5140:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5150] subq.w #8, (a0) uses Op5150 ----------
Op5150:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5158] subq.w #8, (a0)+ uses Op5158 ----------
Op5158:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5160] subq.w #8, -(a0) uses Op5160 ----------
Op5160:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5168] subq.w #8, ($3333,a0) uses Op5168 ----------
Op5168:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5170] subq.w #8, ($33,a0,d3.w*2) uses Op5170 ----------
Op5170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5178] subq.w #8, $3333.w uses Op5178 ----------
Op5178:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5179] subq.w #8, $33333333.l uses Op5179 ----------
Op5179:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [517a] subq.w #8, ($3333,pc); =3335 uses Op517a ----------
Op517a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [517b] subq.w #8, ($33,pc,d3.w*2); =35 uses Op517b ----------
Op517b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5180] subq.l #8, d0 uses Op5180 ----------
Op5180:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5190] subq.l #8, (a0) uses Op5190 ----------
Op5190:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5198] subq.l #8, (a0)+ uses Op5198 ----------
Op5198:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51a0] subq.l #8, -(a0) uses Op51a0 ----------
Op51a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51a8] subq.l #8, ($3333,a0) uses Op51a8 ----------
Op51a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51b0] subq.l #8, ($33,a0,d3.w*2) uses Op51b0 ----------
Op51b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51b8] subq.l #8, $3333.w uses Op51b8 ----------
Op51b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51b9] subq.l #8, $33333333.l uses Op51b9 ----------
Op51b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51ba] subq.l #8, ($3333,pc); =3335 uses Op51ba ----------
Op51ba:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51bb] subq.l #8, ($33,pc,d3.w*2); =35 uses Op51bb ----------
Op51bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51c0] sf d0 uses Op51c0 ----------
Op51c0:
  mov r1,#0
  sub r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51c8] dbra d0, 3335 uses Op51c8 ----------
Op51c8:
;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd51c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd51c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51d0] sf (a0) uses Op51d0 ----------
Op51d0:
  mov r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51d8] sf (a0)+ uses Op51d8 ----------
Op51d8:
  mov r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51df] sf (a7)+ uses Op51df ----------
Op51df:
  mov r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51e0] sf -(a0) uses Op51e0 ----------
Op51e0:
  mov r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51e7] sf -(a7) uses Op51e7 ----------
Op51e7:
  mov r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51e8] sf ($3333,a0) uses Op51e8 ----------
Op51e8:
  mov r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51f0] sf ($33,a0,d3.w*2) uses Op51f0 ----------
Op51f0:
  mov r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51f8] sf $3333.w uses Op51f8 ----------
Op51f8:
  mov r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51f9] sf $33333333.l uses Op51f9 ----------
Op51f9:
  mov r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51fa] sf ($3333,pc); =3335 uses Op51fa ----------
Op51fa:
  mov r1,#0

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51fb] sf ($33,pc,d3.w*2); =35 uses Op51fb ----------
Op51fb:
  mov r1,#0

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52c0] shi d0 uses Op52c0 ----------
Op52c0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1
  subhi r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52c8] dbhi d0, 3335 uses Op52c8 ----------
Op52c8:
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
;@ If so, don't dbra
  bhi DbraEnd52c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd52c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd52c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52d0] shi (a0) uses Op52d0 ----------
Op52d0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52d8] shi (a0)+ uses Op52d8 ----------
Op52d8:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52df] shi (a7)+ uses Op52df ----------
Op52df:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52e0] shi -(a0) uses Op52e0 ----------
Op52e0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52e7] shi -(a7) uses Op52e7 ----------
Op52e7:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52e8] shi ($3333,a0) uses Op52e8 ----------
Op52e8:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52f0] shi ($33,a0,d3.w*2) uses Op52f0 ----------
Op52f0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52f8] shi $3333.w uses Op52f8 ----------
Op52f8:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52f9] shi $33333333.l uses Op52f9 ----------
Op52f9:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52fa] shi ($3333,pc); =3335 uses Op52fa ----------
Op52fa:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52fb] shi ($33,pc,d3.w*2); =35 uses Op52fb ----------
Op52fb:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnhi r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53c0] sls d0 uses Op53c0 ----------
Op53c0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1
  subls r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53c8] dbls d0, 3335 uses Op53c8 ----------
Op53c8:
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
;@ If so, don't dbra
  bls DbraEnd53c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd53c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd53c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53d0] sls (a0) uses Op53d0 ----------
Op53d0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53d8] sls (a0)+ uses Op53d8 ----------
Op53d8:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53df] sls (a7)+ uses Op53df ----------
Op53df:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53e0] sls -(a0) uses Op53e0 ----------
Op53e0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53e7] sls -(a7) uses Op53e7 ----------
Op53e7:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53e8] sls ($3333,a0) uses Op53e8 ----------
Op53e8:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53f0] sls ($33,a0,d3.w*2) uses Op53f0 ----------
Op53f0:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53f8] sls $3333.w uses Op53f8 ----------
Op53f8:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53f9] sls $33333333.l uses Op53f9 ----------
Op53f9:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53fa] sls ($3333,pc); =3335 uses Op53fa ----------
Op53fa:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53fb] sls ($33,pc,d3.w*2); =35 uses Op53fb ----------
Op53fb:
  mov r1,#0
;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  mvnls r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54c0] scc d0 uses Op54c0 ----------
Op54c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1
  subcc r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54c8] dbcc d0, 3335 uses Op54c8 ----------
Op54c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bcc DbraEnd54c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd54c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd54c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54d0] scc (a0) uses Op54d0 ----------
Op54d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54d8] scc (a0)+ uses Op54d8 ----------
Op54d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54df] scc (a7)+ uses Op54df ----------
Op54df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54e0] scc -(a0) uses Op54e0 ----------
Op54e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54e7] scc -(a7) uses Op54e7 ----------
Op54e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54e8] scc ($3333,a0) uses Op54e8 ----------
Op54e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54f0] scc ($33,a0,d3.w*2) uses Op54f0 ----------
Op54f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54f8] scc $3333.w uses Op54f8 ----------
Op54f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54f9] scc $33333333.l uses Op54f9 ----------
Op54f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54fa] scc ($3333,pc); =3335 uses Op54fa ----------
Op54fa:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54fb] scc ($33,pc,d3.w*2); =35 uses Op54fb ----------
Op54fb:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55c0] scs d0 uses Op55c0 ----------
Op55c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1
  subcs r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55c8] dbcs d0, 3335 uses Op55c8 ----------
Op55c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bcs DbraEnd55c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd55c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd55c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55d0] scs (a0) uses Op55d0 ----------
Op55d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55d8] scs (a0)+ uses Op55d8 ----------
Op55d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55df] scs (a7)+ uses Op55df ----------
Op55df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55e0] scs -(a0) uses Op55e0 ----------
Op55e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55e7] scs -(a7) uses Op55e7 ----------
Op55e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55e8] scs ($3333,a0) uses Op55e8 ----------
Op55e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55f0] scs ($33,a0,d3.w*2) uses Op55f0 ----------
Op55f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55f8] scs $3333.w uses Op55f8 ----------
Op55f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55f9] scs $33333333.l uses Op55f9 ----------
Op55f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55fa] scs ($3333,pc); =3335 uses Op55fa ----------
Op55fa:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55fb] scs ($33,pc,d3.w*2); =35 uses Op55fb ----------
Op55fb:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56c0] sne d0 uses Op56c0 ----------
Op56c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1
  subne r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56c8] dbne d0, 3335 uses Op56c8 ----------
Op56c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bne DbraEnd56c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd56c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd56c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56d0] sne (a0) uses Op56d0 ----------
Op56d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56d8] sne (a0)+ uses Op56d8 ----------
Op56d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56df] sne (a7)+ uses Op56df ----------
Op56df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56e0] sne -(a0) uses Op56e0 ----------
Op56e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56e7] sne -(a7) uses Op56e7 ----------
Op56e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56e8] sne ($3333,a0) uses Op56e8 ----------
Op56e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56f0] sne ($33,a0,d3.w*2) uses Op56f0 ----------
Op56f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56f8] sne $3333.w uses Op56f8 ----------
Op56f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56f9] sne $33333333.l uses Op56f9 ----------
Op56f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56fa] sne ($3333,pc); =3335 uses Op56fa ----------
Op56fa:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56fb] sne ($33,pc,d3.w*2); =35 uses Op56fb ----------
Op56fb:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57c0] seq d0 uses Op57c0 ----------
Op57c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1
  subeq r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57c8] dbeq d0, 3335 uses Op57c8 ----------
Op57c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  beq DbraEnd57c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd57c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd57c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57d0] seq (a0) uses Op57d0 ----------
Op57d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57d8] seq (a0)+ uses Op57d8 ----------
Op57d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57df] seq (a7)+ uses Op57df ----------
Op57df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57e0] seq -(a0) uses Op57e0 ----------
Op57e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57e7] seq -(a7) uses Op57e7 ----------
Op57e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57e8] seq ($3333,a0) uses Op57e8 ----------
Op57e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57f0] seq ($33,a0,d3.w*2) uses Op57f0 ----------
Op57f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57f8] seq $3333.w uses Op57f8 ----------
Op57f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57f9] seq $33333333.l uses Op57f9 ----------
Op57f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57fa] seq ($3333,pc); =3335 uses Op57fa ----------
Op57fa:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57fb] seq ($33,pc,d3.w*2); =35 uses Op57fb ----------
Op57fb:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58c0] svc d0 uses Op58c0 ----------
Op58c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1
  subvc r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58c8] dbvc d0, 3335 uses Op58c8 ----------
Op58c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bvc DbraEnd58c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd58c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd58c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58d0] svc (a0) uses Op58d0 ----------
Op58d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58d8] svc (a0)+ uses Op58d8 ----------
Op58d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58df] svc (a7)+ uses Op58df ----------
Op58df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58e0] svc -(a0) uses Op58e0 ----------
Op58e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58e7] svc -(a7) uses Op58e7 ----------
Op58e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58e8] svc ($3333,a0) uses Op58e8 ----------
Op58e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58f0] svc ($33,a0,d3.w*2) uses Op58f0 ----------
Op58f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58f8] svc $3333.w uses Op58f8 ----------
Op58f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58f9] svc $33333333.l uses Op58f9 ----------
Op58f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58fa] svc ($3333,pc); =3335 uses Op58fa ----------
Op58fa:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58fb] svc ($33,pc,d3.w*2); =35 uses Op58fb ----------
Op58fb:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59c0] svs d0 uses Op59c0 ----------
Op59c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1
  subvs r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59c8] dbvs d0, 3335 uses Op59c8 ----------
Op59c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bvs DbraEnd59c8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd59c8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd59c8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59d0] svs (a0) uses Op59d0 ----------
Op59d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59d8] svs (a0)+ uses Op59d8 ----------
Op59d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59df] svs (a7)+ uses Op59df ----------
Op59df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59e0] svs -(a0) uses Op59e0 ----------
Op59e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59e7] svs -(a7) uses Op59e7 ----------
Op59e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59e8] svs ($3333,a0) uses Op59e8 ----------
Op59e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59f0] svs ($33,a0,d3.w*2) uses Op59f0 ----------
Op59f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59f8] svs $3333.w uses Op59f8 ----------
Op59f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59f9] svs $33333333.l uses Op59f9 ----------
Op59f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59fa] svs ($3333,pc); =3335 uses Op59fa ----------
Op59fa:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59fb] svs ($33,pc,d3.w*2); =35 uses Op59fb ----------
Op59fb:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ac0] spl d0 uses Op5ac0 ----------
Op5ac0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1
  subpl r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ac8] dbpl d0, 3335 uses Op5ac8 ----------
Op5ac8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bpl DbraEnd5ac8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd5ac8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd5ac8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ad0] spl (a0) uses Op5ad0 ----------
Op5ad0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ad8] spl (a0)+ uses Op5ad8 ----------
Op5ad8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5adf] spl (a7)+ uses Op5adf ----------
Op5adf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ae0] spl -(a0) uses Op5ae0 ----------
Op5ae0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ae7] spl -(a7) uses Op5ae7 ----------
Op5ae7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ae8] spl ($3333,a0) uses Op5ae8 ----------
Op5ae8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5af0] spl ($33,a0,d3.w*2) uses Op5af0 ----------
Op5af0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5af8] spl $3333.w uses Op5af8 ----------
Op5af8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5af9] spl $33333333.l uses Op5af9 ----------
Op5af9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5afa] spl ($3333,pc); =3335 uses Op5afa ----------
Op5afa:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5afb] spl ($33,pc,d3.w*2); =35 uses Op5afb ----------
Op5afb:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bc0] smi d0 uses Op5bc0 ----------
Op5bc0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1
  submi r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bc8] dbmi d0, 3335 uses Op5bc8 ----------
Op5bc8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bmi DbraEnd5bc8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd5bc8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd5bc8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bd0] smi (a0) uses Op5bd0 ----------
Op5bd0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bd8] smi (a0)+ uses Op5bd8 ----------
Op5bd8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bdf] smi (a7)+ uses Op5bdf ----------
Op5bdf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5be0] smi -(a0) uses Op5be0 ----------
Op5be0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5be7] smi -(a7) uses Op5be7 ----------
Op5be7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5be8] smi ($3333,a0) uses Op5be8 ----------
Op5be8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bf0] smi ($33,a0,d3.w*2) uses Op5bf0 ----------
Op5bf0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bf8] smi $3333.w uses Op5bf8 ----------
Op5bf8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bf9] smi $33333333.l uses Op5bf9 ----------
Op5bf9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bfa] smi ($3333,pc); =3335 uses Op5bfa ----------
Op5bfa:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bfb] smi ($33,pc,d3.w*2); =35 uses Op5bfb ----------
Op5bfb:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cc0] sge d0 uses Op5cc0 ----------
Op5cc0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1
  subge r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cc8] dbge d0, 3335 uses Op5cc8 ----------
Op5cc8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bge DbraEnd5cc8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd5cc8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd5cc8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cd0] sge (a0) uses Op5cd0 ----------
Op5cd0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cd8] sge (a0)+ uses Op5cd8 ----------
Op5cd8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cdf] sge (a7)+ uses Op5cdf ----------
Op5cdf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ce0] sge -(a0) uses Op5ce0 ----------
Op5ce0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ce7] sge -(a7) uses Op5ce7 ----------
Op5ce7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ce8] sge ($3333,a0) uses Op5ce8 ----------
Op5ce8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cf0] sge ($33,a0,d3.w*2) uses Op5cf0 ----------
Op5cf0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cf8] sge $3333.w uses Op5cf8 ----------
Op5cf8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cf9] sge $33333333.l uses Op5cf9 ----------
Op5cf9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cfa] sge ($3333,pc); =3335 uses Op5cfa ----------
Op5cfa:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cfb] sge ($33,pc,d3.w*2); =35 uses Op5cfb ----------
Op5cfb:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dc0] slt d0 uses Op5dc0 ----------
Op5dc0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1
  sublt r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dc8] dblt d0, 3335 uses Op5dc8 ----------
Op5dc8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  blt DbraEnd5dc8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd5dc8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd5dc8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dd0] slt (a0) uses Op5dd0 ----------
Op5dd0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dd8] slt (a0)+ uses Op5dd8 ----------
Op5dd8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ddf] slt (a7)+ uses Op5ddf ----------
Op5ddf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5de0] slt -(a0) uses Op5de0 ----------
Op5de0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5de7] slt -(a7) uses Op5de7 ----------
Op5de7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5de8] slt ($3333,a0) uses Op5de8 ----------
Op5de8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5df0] slt ($33,a0,d3.w*2) uses Op5df0 ----------
Op5df0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5df8] slt $3333.w uses Op5df8 ----------
Op5df8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5df9] slt $33333333.l uses Op5df9 ----------
Op5df9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dfa] slt ($3333,pc); =3335 uses Op5dfa ----------
Op5dfa:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dfb] slt ($33,pc,d3.w*2); =35 uses Op5dfb ----------
Op5dfb:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e00] addq.b #7, d0 uses Op5e00 ----------
Op5e00:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e08] addq.b #7, a0 uses Op5e08 ----------
Op5e08:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e10] addq.b #7, (a0) uses Op5e10 ----------
Op5e10:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e18] addq.b #7, (a0)+ uses Op5e18 ----------
Op5e18:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e20] addq.b #7, -(a0) uses Op5e20 ----------
Op5e20:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e28] addq.b #7, ($3333,a0) uses Op5e28 ----------
Op5e28:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e30] addq.b #7, ($33,a0,d3.w*2) uses Op5e30 ----------
Op5e30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e38] addq.b #7, $3333.w uses Op5e38 ----------
Op5e38:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e39] addq.b #7, $33333333.l uses Op5e39 ----------
Op5e39:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e3a] addq.b #7, ($3333,pc); =3335 uses Op5e3a ----------
Op5e3a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e3b] addq.b #7, ($33,pc,d3.w*2); =35 uses Op5e3b ----------
Op5e3b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e40] addq.w #7, d0 uses Op5e40 ----------
Op5e40:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e50] addq.w #7, (a0) uses Op5e50 ----------
Op5e50:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e58] addq.w #7, (a0)+ uses Op5e58 ----------
Op5e58:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e60] addq.w #7, -(a0) uses Op5e60 ----------
Op5e60:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e68] addq.w #7, ($3333,a0) uses Op5e68 ----------
Op5e68:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e70] addq.w #7, ($33,a0,d3.w*2) uses Op5e70 ----------
Op5e70:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e78] addq.w #7, $3333.w uses Op5e78 ----------
Op5e78:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e79] addq.w #7, $33333333.l uses Op5e79 ----------
Op5e79:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e7a] addq.w #7, ($3333,pc); =3335 uses Op5e7a ----------
Op5e7a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e7b] addq.w #7, ($33,pc,d3.w*2); =35 uses Op5e7b ----------
Op5e7b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e80] addq.l #7, d0 uses Op5e80 ----------
Op5e80:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e90] addq.l #7, (a0) uses Op5e90 ----------
Op5e90:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e98] addq.l #7, (a0)+ uses Op5e98 ----------
Op5e98:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ea0] addq.l #7, -(a0) uses Op5ea0 ----------
Op5ea0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ea8] addq.l #7, ($3333,a0) uses Op5ea8 ----------
Op5ea8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5eb0] addq.l #7, ($33,a0,d3.w*2) uses Op5eb0 ----------
Op5eb0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5eb8] addq.l #7, $3333.w uses Op5eb8 ----------
Op5eb8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5eb9] addq.l #7, $33333333.l uses Op5eb9 ----------
Op5eb9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5eba] addq.l #7, ($3333,pc); =3335 uses Op5eba ----------
Op5eba:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ebb] addq.l #7, ($33,pc,d3.w*2); =35 uses Op5ebb ----------
Op5ebb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  adds r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ec0] sgt d0 uses Op5ec0 ----------
Op5ec0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1
  subgt r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ec8] dbgt d0, 3335 uses Op5ec8 ----------
Op5ec8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bgt DbraEnd5ec8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd5ec8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd5ec8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ed0] sgt (a0) uses Op5ed0 ----------
Op5ed0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ed8] sgt (a0)+ uses Op5ed8 ----------
Op5ed8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5edf] sgt (a7)+ uses Op5edf ----------
Op5edf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ee0] sgt -(a0) uses Op5ee0 ----------
Op5ee0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ee7] sgt -(a7) uses Op5ee7 ----------
Op5ee7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ee8] sgt ($3333,a0) uses Op5ee8 ----------
Op5ee8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ef0] sgt ($33,a0,d3.w*2) uses Op5ef0 ----------
Op5ef0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ef8] sgt $3333.w uses Op5ef8 ----------
Op5ef8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ef9] sgt $33333333.l uses Op5ef9 ----------
Op5ef9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5efa] sgt ($3333,pc); =3335 uses Op5efa ----------
Op5efa:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5efb] sgt ($33,pc,d3.w*2); =35 uses Op5efb ----------
Op5efb:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f00] subq.b #7, d0 uses Op5f00 ----------
Op5f00:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f08] subq.b #7, a0 uses Op5f08 ----------
Op5f08:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f10] subq.b #7, (a0) uses Op5f10 ----------
Op5f10:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f18] subq.b #7, (a0)+ uses Op5f18 ----------
Op5f18:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f20] subq.b #7, -(a0) uses Op5f20 ----------
Op5f20:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f28] subq.b #7, ($3333,a0) uses Op5f28 ----------
Op5f28:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f30] subq.b #7, ($33,a0,d3.w*2) uses Op5f30 ----------
Op5f30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f38] subq.b #7, $3333.w uses Op5f38 ----------
Op5f38:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f39] subq.b #7, $33333333.l uses Op5f39 ----------
Op5f39:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f3a] subq.b #7, ($3333,pc); =3335 uses Op5f3a ----------
Op5f3a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f3b] subq.b #7, ($33,pc,d3.w*2); =35 uses Op5f3b ----------
Op5f3b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

  mov r2,r8,lsl #15 ;@ Get quick value
  and r2,r2,#0x7000000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f40] subq.w #7, d0 uses Op5f40 ----------
Op5f40:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f50] subq.w #7, (a0) uses Op5f50 ----------
Op5f50:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f58] subq.w #7, (a0)+ uses Op5f58 ----------
Op5f58:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f60] subq.w #7, -(a0) uses Op5f60 ----------
Op5f60:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f68] subq.w #7, ($3333,a0) uses Op5f68 ----------
Op5f68:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f70] subq.w #7, ($33,a0,d3.w*2) uses Op5f70 ----------
Op5f70:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f78] subq.w #7, $3333.w uses Op5f78 ----------
Op5f78:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f79] subq.w #7, $33333333.l uses Op5f79 ----------
Op5f79:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f7a] subq.w #7, ($3333,pc); =3335 uses Op5f7a ----------
Op5f7a:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f7b] subq.w #7, ($33,pc,d3.w*2); =35 uses Op5f7b ----------
Op5f7b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

  mov r2,r8,lsl #7 ;@ Get quick value
  and r2,r2,#0x70000

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f80] subq.l #7, d0 uses Op5f80 ----------
Op5f80:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f90] subq.l #7, (a0) uses Op5f90 ----------
Op5f90:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f98] subq.l #7, (a0)+ uses Op5f98 ----------
Op5f98:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fa0] subq.l #7, -(a0) uses Op5fa0 ----------
Op5fa0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fa8] subq.l #7, ($3333,a0) uses Op5fa8 ----------
Op5fa8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fb0] subq.l #7, ($33,a0,d3.w*2) uses Op5fb0 ----------
Op5fb0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fb8] subq.l #7, $3333.w uses Op5fb8 ----------
Op5fb8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fb9] subq.l #7, $33333333.l uses Op5fb9 ----------
Op5fb9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fba] subq.l #7, ($3333,pc); =3335 uses Op5fba ----------
Op5fba:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fbb] subq.l #7, ($33,pc,d3.w*2); =35 uses Op5fbb ----------
Op5fbb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

  mov r2,r8,lsr #9 ;@ Get quick value
  and r2,r2,#0x0007

  subs r1,r0,r2
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fc0] sle d0 uses Op5fc0 ----------
Op5fc0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1
  suble r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fc8] dble d0, 3335 uses Op5fc8 ----------
Op5fc8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  ble DbraEnd5fc8

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmps r0,#-1
  beq DbraEnd5fc8

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DbraEnd5fc8:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fd0] sle (a0) uses Op5fd0 ----------
Op5fd0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fd8] sle (a0)+ uses Op5fd8 ----------
Op5fd8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fdf] sle (a7)+ uses Op5fdf ----------
Op5fdf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fe0] sle -(a0) uses Op5fe0 ----------
Op5fe0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fe7] sle -(a7) uses Op5fe7 ----------
Op5fe7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fe8] sle ($3333,a0) uses Op5fe8 ----------
Op5fe8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ff0] sle ($33,a0,d3.w*2) uses Op5ff0 ----------
Op5ff0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ff8] sle $3333.w uses Op5ff8 ----------
Op5ff8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ff9] sle $33333333.l uses Op5ff9 ----------
Op5ff9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ffa] sle ($3333,pc); =3335 uses Op5ffa ----------
Op5ffa:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaWrite: Write r1 into '($3333,pc)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ffb] sle ($33,pc,d3.w*2); =35 uses Op5ffb ----------
Op5ffb:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r0):
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6000] bra 3335 uses Op6000 ----------
Op6000:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6001] bra 3 uses Op6001 ----------
Op6001:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

  mov r0,r0,asr #24 ;@ ...shift down

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [60ff] bra 33333335 uses Op60ff ----------
Op60ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6100] bsr 3335 uses Op6100 ----------
Op6100:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r10,[r7,#0x60] ;@ Get Memory base
  sub r1,r4,r10 ;@ r1 = Old PC

  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6101] bsr 3 uses Op6101 ----------
Op6101:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

  mov r0,r0,asr #24 ;@ ...shift down

;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r10,[r7,#0x60] ;@ Get Memory base
  sub r1,r4,r10 ;@ r1 = Old PC

  add r4,r4,r0 ;@ r4 = New PC

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [61ff] bsr 33333335 uses Op61ff ----------
Op61ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r10,[r7,#0x60] ;@ Get Memory base
  sub r1,r4,r10 ;@ r1 = Old PC

  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Push r1 onto stack
  ldr r0,[r7,#0x3c]
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6200] bhi 3335 uses Op6200 ----------
Op6200:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
  bls DontBranch6200

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6200:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6201] bhi 3 uses Op6201 ----------
Op6201:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
  mov r0,r0,asr #24 ;@ ...shift down

  bls DontBranch6201

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6201:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [62ff] bhi 33333335 uses Op62ff ----------
Op62ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
  bls DontBranch62ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch62ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6300] bls 3335 uses Op6300 ----------
Op6300:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
  bhi DontBranch6300

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6300:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6301] bls 3 uses Op6301 ----------
Op6301:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
  mov r0,r0,asr #24 ;@ ...shift down

  bhi DontBranch6301

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6301:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [63ff] bls 33333335 uses Op63ff ----------
Op63ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  eor r9,r9,#0x20000000 ;@ Invert carry for hi/ls
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  eor r9,r9,#0x20000000
  bhi DontBranch63ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch63ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6400] bcc 3335 uses Op6400 ----------
Op6400:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bcs DontBranch6400

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6400:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6401] bcc 3 uses Op6401 ----------
Op6401:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bcs DontBranch6401

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6401:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [64ff] bcc 33333335 uses Op64ff ----------
Op64ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bcs DontBranch64ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch64ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6500] bcs 3335 uses Op6500 ----------
Op6500:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bcc DontBranch6500

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6500:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6501] bcs 3 uses Op6501 ----------
Op6501:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bcc DontBranch6501

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6501:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [65ff] bcs 33333335 uses Op65ff ----------
Op65ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bcc DontBranch65ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch65ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6600] bne 3335 uses Op6600 ----------
Op6600:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  beq DontBranch6600

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6600:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6601] bne 3 uses Op6601 ----------
Op6601:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  beq DontBranch6601

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6601:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [66ff] bne 33333335 uses Op66ff ----------
Op66ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  beq DontBranch66ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch66ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6700] beq 3335 uses Op6700 ----------
Op6700:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bne DontBranch6700

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6700:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6701] beq 3 uses Op6701 ----------
Op6701:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bne DontBranch6701

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6701:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [67ff] beq 33333335 uses Op67ff ----------
Op67ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bne DontBranch67ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch67ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6800] bvc 3335 uses Op6800 ----------
Op6800:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bvs DontBranch6800

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6800:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6801] bvc 3 uses Op6801 ----------
Op6801:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bvs DontBranch6801

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6801:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [68ff] bvc 33333335 uses Op68ff ----------
Op68ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bvs DontBranch68ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch68ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6900] bvs 3335 uses Op6900 ----------
Op6900:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bvc DontBranch6900

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6900:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6901] bvs 3 uses Op6901 ----------
Op6901:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bvc DontBranch6901

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6901:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [69ff] bvs 33333335 uses Op69ff ----------
Op69ff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bvc DontBranch69ff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch69ff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6a00] bpl 3335 uses Op6a00 ----------
Op6a00:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bmi DontBranch6a00

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6a00:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6a01] bpl 3 uses Op6a01 ----------
Op6a01:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bmi DontBranch6a01

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6a01:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6aff] bpl 33333335 uses Op6aff ----------
Op6aff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bmi DontBranch6aff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6aff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6b00] bmi 3335 uses Op6b00 ----------
Op6b00:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bpl DontBranch6b00

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6b00:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6b01] bmi 3 uses Op6b01 ----------
Op6b01:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bpl DontBranch6b01

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6b01:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6bff] bmi 33333335 uses Op6bff ----------
Op6bff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bpl DontBranch6bff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6bff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6c00] bge 3335 uses Op6c00 ----------
Op6c00:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  blt DontBranch6c00

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6c00:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6c01] bge 3 uses Op6c01 ----------
Op6c01:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  blt DontBranch6c01

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6c01:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6cff] bge 33333335 uses Op6cff ----------
Op6cff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  blt DontBranch6cff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6cff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6d00] blt 3335 uses Op6d00 ----------
Op6d00:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bge DontBranch6d00

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6d00:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6d01] blt 3 uses Op6d01 ----------
Op6d01:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bge DontBranch6d01

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6d01:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6dff] blt 33333335 uses Op6dff ----------
Op6dff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bge DontBranch6dff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6dff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6e00] bgt 3335 uses Op6e00 ----------
Op6e00:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  ble DontBranch6e00

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6e00:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6e01] bgt 3 uses Op6e01 ----------
Op6e01:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  ble DontBranch6e01

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6e01:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6eff] bgt 33333335 uses Op6eff ----------
Op6eff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  ble DontBranch6eff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6eff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6f00] ble 3335 uses Op6f00 ----------
Op6f00:
;@ Get Branch offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bgt DontBranch6f00

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#2 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6f00:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6f01] ble 3 uses Op6f01 ----------
Op6f01:
;@ Get Branch offset:
  mov r0,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mov r0,r0,asr #24 ;@ ...shift down

  bgt DontBranch6f01

;@ Branch taken - Add on r0 to PC
  add r4,r4,r0 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6f01:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6fff] ble 33333335 uses Op6fff ----------
Op6fff:
;@ Get Branch offset:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bgt DontBranch6fff

;@ Branch taken - Add on r0 to PC
  sub r4,r4,#4 ;@ (Branch is relative to Opcode+2)
  add r4,r4,r0 ;@ r4 = New PC

;@ Branch is quite far, so may be a good idea to check Memory Base+pc
;@ Check Memory Base+pc (r4)
  add lr,pc,#4
  mov r0,r4
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  mov r4,r0

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

DontBranch6fff:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [7000] moveq #$0, d0 uses Op7000 ----------
Op7000:
  mov r0,r8,asl #24
  and r1,r8,#0x0e00
  movs r0,r0,asr #24 ;@ Sign extended Quick value
  mrs r9,cpsr ;@ r9=NZ flags
  bic r9,r9,#(1<<29)|(1<<28)
  str r0,[r7,r1,lsr #7] ;@ Store into Dn

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8000] or.b d0, d0 uses Op8000 ----------
Op8000:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r11:
  ldrsb r11,[r7,r10]
  mov r11,r11,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8010] or.b (a0), d0 uses Op8010 ----------
Op8010:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8018] or.b (a0)+, d0 uses Op8018 ----------
Op8018:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [801f] or.b (a7)+, d0 uses Op801f ----------
Op801f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8020] or.b -(a0), d0 uses Op8020 ----------
Op8020:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8027] or.b -(a7), d0 uses Op8027 ----------
Op8027:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8028] or.b ($3333,a0), d0 uses Op8028 ----------
Op8028:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8030] or.b ($33,a0,d3.w*2), d0 uses Op8030 ----------
Op8030:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8038] or.b $3333.w, d0 uses Op8038 ----------
Op8038:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8039] or.b $33333333.l, d0 uses Op8039 ----------
Op8039:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803a] or.b ($3333,pc), d0; =3335 uses Op803a ----------
Op803a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803b] or.b ($33,pc,d3.w*2), d0; =35 uses Op803b ----------
Op803b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803c] or.b #$33, d0 uses Op803c ----------
Op803c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r11:
  mov r11,r10,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803d] or.b ea=(111 101), d0 uses Op803d ----------
Op803d:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 101)' into r10:
;@ EaRead : Read 'ea=(111 101)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803e] or.b ea=(111 110), d0 uses Op803e ----------
Op803e:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 110)' into r10:
;@ EaRead : Read 'ea=(111 110)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803f] or.b ea=(111 111), d0 uses Op803f ----------
Op803f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 111)' into r10:
;@ EaRead : Read 'ea=(111 111)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8040] or.w d0, d0 uses Op8040 ----------
Op8040:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r11:
  ldrsh r11,[r7,r10]
  mov r11,r11,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8050] or.w (a0), d0 uses Op8050 ----------
Op8050:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8058] or.w (a0)+, d0 uses Op8058 ----------
Op8058:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [805f] or.w (a7)+, d0 uses Op805f ----------
Op805f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8060] or.w -(a0), d0 uses Op8060 ----------
Op8060:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8067] or.w -(a7), d0 uses Op8067 ----------
Op8067:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8068] or.w ($3333,a0), d0 uses Op8068 ----------
Op8068:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8070] or.w ($33,a0,d3.w*2), d0 uses Op8070 ----------
Op8070:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8078] or.w $3333.w, d0 uses Op8078 ----------
Op8078:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8079] or.w $33333333.l, d0 uses Op8079 ----------
Op8079:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807a] or.w ($3333,pc), d0; =3335 uses Op807a ----------
Op807a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807b] or.w ($33,pc,d3.w*2), d0; =35 uses Op807b ----------
Op807b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807c] or.w #$3333, d0 uses Op807c ----------
Op807c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r11:
  mov r11,r10,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807d] or.w ea=(111 101), d0 uses Op807d ----------
Op807d:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 101)' into r10:
;@ EaRead : Read 'ea=(111 101)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807e] or.w ea=(111 110), d0 uses Op807e ----------
Op807e:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 110)' into r10:
;@ EaRead : Read 'ea=(111 110)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807f] or.w ea=(111 111), d0 uses Op807f ----------
Op807f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 111)' into r10:
;@ EaRead : Read 'ea=(111 111)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8080] or.l d0, d0 uses Op8080 ----------
Op8080:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsl #2]

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8090] or.l (a0), d0 uses Op8090 ----------
Op8090:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8098] or.l (a0)+, d0 uses Op8098 ----------
Op8098:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [809f] or.l (a7)+, d0 uses Op809f ----------
Op809f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80a0] or.l -(a0), d0 uses Op80a0 ----------
Op80a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80a7] or.l -(a7), d0 uses Op80a7 ----------
Op80a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80a8] or.l ($3333,a0), d0 uses Op80a8 ----------
Op80a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80b0] or.l ($33,a0,d3.w*2), d0 uses Op80b0 ----------
Op80b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80b8] or.l $3333.w, d0 uses Op80b8 ----------
Op80b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80b9] or.l $33333333.l, d0 uses Op80b9 ----------
Op80b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80ba] or.l ($3333,pc), d0; =3335 uses Op80ba ----------
Op80ba:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80bb] or.l ($33,pc,d3.w*2), d0; =35 uses Op80bb ----------
Op80bb:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80bc] or.l #$33333333, d0 uses Op80bc ----------
Op80bc:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r11:
  mov r11,r10,asl #0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80bd] or.l ea=(111 101), d0 uses Op80bd ----------
Op80bd:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 101)' into r10:
;@ EaRead : Read 'ea=(111 101)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80be] or.l ea=(111 110), d0 uses Op80be ----------
Op80be:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 110)' into r10:
;@ EaRead : Read 'ea=(111 110)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80bf] or.l ea=(111 111), d0 uses Op80bf ----------
Op80bf:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 111)' into r10:
;@ EaRead : Read 'ea=(111 111)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80c0] divu.w d0, d0 uses Op80c0 ----------
Op80c0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r10:
  ldrsh r10,[r7,r10]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  mov r10,r10,lsl#16
  movs r10,r10,lsr#16
  moveq r10,#1 ;@ Divide by zero

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift80c0:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift80c0

Divide80c0:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide80c0

  cmp r3,#0x10000
  bge Divide80c0Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide80c0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#133 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide80c0Overflow:
  orr r9,r9,#1<<28
Divide80c0Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#133 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80d0] divu.w (a0), d0 uses Op80d0 ----------
Op80d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  mov r10,r10,lsl#16
  movs r10,r10,lsr#16
  moveq r10,#1 ;@ Divide by zero

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift80d0:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift80d0

Divide80d0:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide80d0

  cmp r3,#0x10000
  bge Divide80d0Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide80d0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide80d0Overflow:
  orr r9,r9,#1<<28
Divide80d0Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80d8] divu.w (a0)+, d0 uses Op80d8 ----------
Op80d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  mov r10,r10,lsl#16
  movs r10,r10,lsr#16
  moveq r10,#1 ;@ Divide by zero

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift80d8:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift80d8

Divide80d8:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide80d8

  cmp r3,#0x10000
  bge Divide80d8Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide80d8WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide80d8Overflow:
  orr r9,r9,#1<<28
Divide80d8Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80df] divu.w (a7)+, d0 uses Op80df ----------
Op80df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  mov r10,r10,lsl#16
  movs r10,r10,lsr#16
  moveq r10,#1 ;@ Divide by zero

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift80df:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift80df

Divide80df:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide80df

  cmp r3,#0x10000
  bge Divide80dfOverflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide80dfWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide80dfOverflow:
  orr r9,r9,#1<<28
Divide80dfExit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80e0] divu.w -(a0), d0 uses Op80e0 ----------
Op80e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  mov r10,r10,lsl#16
  movs r10,r10,lsr#16
  moveq r10,#1 ;@ Divide by zero

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift80e0:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift80e0

Divide80e0:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide80e0

  cmp r3,#0x10000
  bge Divide80e0Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide80e0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#139 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide80e0Overflow:
  orr r9,r9,#1<<28
Divide80e0Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#139 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80e7] divu.w -(a7), d0 uses Op80e7 ----------
Op80e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  mov r10,r10,lsl#16
  movs r10,r10,lsr#16
  moveq r10,#1 ;@ Divide by zero

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift80e7:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift80e7

Divide80e7:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide80e7

  cmp r3,#0x10000
  bge Divide80e7Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide80e7WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#139 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide80e7Overflow:
  orr r9,r9,#1<<28
Divide80e7Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#139 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80e8] divu.w ($3333,a0), d0 uses Op80e8 ----------
Op80e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  mov r10,r10,lsl#16
  movs r10,r10,lsr#16
  moveq r10,#1 ;@ Divide by zero

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift80e8:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift80e8

Divide80e8:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide80e8

  cmp r3,#0x10000
  bge Divide80e8Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide80e8WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#141 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide80e8Overflow:
  orr r9,r9,#1<<28
Divide80e8Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#141 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80f0] divu.w ($33,a0,d3.w*2), d0 uses Op80f0 ----------
Op80f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  mov r10,r10,lsl#16
  movs r10,r10,lsr#16
  moveq r10,#1 ;@ Divide by zero

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift80f0:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift80f0

Divide80f0:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide80f0

  cmp r3,#0x10000
  bge Divide80f0Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide80f0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#143 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide80f0Overflow:
  orr r9,r9,#1<<28
Divide80f0Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#143 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80f8] divu.w $3333.w, d0 uses Op80f8 ----------
Op80f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  mov r10,r10,lsl#16
  movs r10,r10,lsr#16
  moveq r10,#1 ;@ Divide by zero

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift80f8:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift80f8

Divide80f8:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide80f8

  cmp r3,#0x10000
  bge Divide80f8Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide80f8WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#141 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide80f8Overflow:
  orr r9,r9,#1<<28
Divide80f8Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#141 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80f9] divu.w $33333333.l, d0 uses Op80f9 ----------
Op80f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  mov r10,r10,lsl#16
  movs r10,r10,lsr#16
  moveq r10,#1 ;@ Divide by zero

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift80f9:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift80f9

Divide80f9:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide80f9

  cmp r3,#0x10000
  bge Divide80f9Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide80f9WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#145 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide80f9Overflow:
  orr r9,r9,#1<<28
Divide80f9Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#145 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80fa] divu.w ($3333,pc), d0; =3335 uses Op80fa ----------
Op80fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  mov r10,r10,lsl#16
  movs r10,r10,lsr#16
  moveq r10,#1 ;@ Divide by zero

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift80fa:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift80fa

Divide80fa:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide80fa

  cmp r3,#0x10000
  bge Divide80faOverflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide80faWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#141 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide80faOverflow:
  orr r9,r9,#1<<28
Divide80faExit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#141 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80fb] divu.w ($33,pc,d3.w*2), d0; =35 uses Op80fb ----------
Op80fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  mov r10,r10,lsl#16
  movs r10,r10,lsr#16
  moveq r10,#1 ;@ Divide by zero

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift80fb:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift80fb

Divide80fb:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide80fb

  cmp r3,#0x10000
  bge Divide80fbOverflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide80fbWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#143 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide80fbOverflow:
  orr r9,r9,#1<<28
Divide80fbExit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#143 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80fc] divu.w #$3333, d0 uses Op80fc ----------
Op80fc:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  mov r10,r10,lsl#16
  movs r10,r10,lsr#16
  moveq r10,#1 ;@ Divide by zero

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift80fc:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift80fc

Divide80fc:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide80fc

  cmp r3,#0x10000
  bge Divide80fcOverflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide80fcWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide80fcOverflow:
  orr r9,r9,#1<<28
Divide80fcExit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8100] sbcd d0, d0 uses Op8100 ----------
Op8100:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r10:
  ldrsb r10,[r7,r0]
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldrsb r1,[r7,r11]
  mov r1,r1,asl #24

  ldrb r2,[r7,#0x45] ;@ Get X bit
  tst r2,#2
  addne r10,r10,#0x01000000 ;@ Add carry bit
;@ Sub units into r2:
  mov r1,r1,lsr#24
  mov r10,r10,lsr#24
  and r2,r1, #0x0f
  and r0,r10,#0x0f
  sub r2,r2,r0
  and r2,r2,#0xFF
  cmp r2,#0x9
  subgt r2,r2,#0x06 ;@ Decimal adjust units
  and r1,r1,#0xF0
  and r10,r10,#0xF0
  sub r1,r1,r10 ;@ Subtract BCD
  add r1,r1,r2
  and r1,r1,#0xFF
  bic r9,r9,#(1<<29)|(1<<31)  ;@ clear szc
  cmp r1,#0x99
  addgt r1,r1,#0xA0
  orrgt r9,r9,#1<<29
  mov r1,r1,lsl#24
  adds r1,r1,#0      ;@ define sz
  orrmi r9,r9,#1<<31 ;@ set S flag
  bicne r9,r9,#1<<30 ;@ set Z flag
  mov r2,r9,lsr#28
  strb r2,[r7,#0x45] ;@ set X flag

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8108] sbcd -(a0), -(a0) uses Op8108 ----------
Op8108:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  ldrb r2,[r7,#0x45] ;@ Get X bit
  tst r2,#2
  addne r10,r10,#0x01000000 ;@ Add carry bit
;@ Sub units into r2:
  mov r1,r1,lsr#24
  mov r10,r10,lsr#24
  and r2,r1, #0x0f
  and r0,r10,#0x0f
  sub r2,r2,r0
  and r2,r2,#0xFF
  cmp r2,#0x9
  subgt r2,r2,#0x06 ;@ Decimal adjust units
  and r1,r1,#0xF0
  and r10,r10,#0xF0
  sub r1,r1,r10 ;@ Subtract BCD
  add r1,r1,r2
  and r1,r1,#0xFF
  bic r9,r9,#(1<<29)|(1<<31)  ;@ clear szc
  cmp r1,#0x99
  addgt r1,r1,#0xA0
  orrgt r9,r9,#1<<29
  mov r1,r1,lsl#24
  adds r1,r1,#0      ;@ define sz
  orrmi r9,r9,#1<<31 ;@ set S flag
  bicne r9,r9,#1<<30 ;@ set Z flag
  mov r2,r9,lsr#28
  strb r2,[r7,#0x45] ;@ set X flag

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8110] or.b d0, (a0) uses Op8110 ----------
Op8110:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8118] or.b d0, (a0)+ uses Op8118 ----------
Op8118:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [811f] or.b d0, (a7)+ uses Op811f ----------
Op811f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8120] or.b d0, -(a0) uses Op8120 ----------
Op8120:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8127] or.b d0, -(a7) uses Op8127 ----------
Op8127:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8128] or.b d0, ($3333,a0) uses Op8128 ----------
Op8128:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8130] or.b d0, ($33,a0,d3.w*2) uses Op8130 ----------
Op8130:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8138] or.b d0, $3333.w uses Op8138 ----------
Op8138:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8139] or.b d0, $33333333.l uses Op8139 ----------
Op8139:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [813a] or.b d0, ($3333,pc); =3335 uses Op813a ----------
Op813a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [813b] or.b d0, ($33,pc,d3.w*2); =35 uses Op813b ----------
Op813b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8150] or.w d0, (a0) uses Op8150 ----------
Op8150:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8158] or.w d0, (a0)+ uses Op8158 ----------
Op8158:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [815f] or.w d0, (a7)+ uses Op815f ----------
Op815f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8160] or.w d0, -(a0) uses Op8160 ----------
Op8160:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8167] or.w d0, -(a7) uses Op8167 ----------
Op8167:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8168] or.w d0, ($3333,a0) uses Op8168 ----------
Op8168:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8170] or.w d0, ($33,a0,d3.w*2) uses Op8170 ----------
Op8170:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8178] or.w d0, $3333.w uses Op8178 ----------
Op8178:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8179] or.w d0, $33333333.l uses Op8179 ----------
Op8179:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [817a] or.w d0, ($3333,pc); =3335 uses Op817a ----------
Op817a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [817b] or.w d0, ($33,pc,d3.w*2); =35 uses Op817b ----------
Op817b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8190] or.l d0, (a0) uses Op8190 ----------
Op8190:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8198] or.l d0, (a0)+ uses Op8198 ----------
Op8198:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [819f] or.l d0, (a7)+ uses Op819f ----------
Op819f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81a0] or.l d0, -(a0) uses Op81a0 ----------
Op81a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81a7] or.l d0, -(a7) uses Op81a7 ----------
Op81a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81a8] or.l d0, ($3333,a0) uses Op81a8 ----------
Op81a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81b0] or.l d0, ($33,a0,d3.w*2) uses Op81b0 ----------
Op81b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81b8] or.l d0, $3333.w uses Op81b8 ----------
Op81b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81b9] or.l d0, $33333333.l uses Op81b9 ----------
Op81b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81ba] or.l d0, ($3333,pc); =3335 uses Op81ba ----------
Op81ba:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81bb] or.l d0, ($33,pc,d3.w*2); =35 uses Op81bb ----------
Op81bb:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  orr  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81c0] divs.w d0, d0 uses Op81c0 ----------
Op81c0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r10:
  ldrsh r10,[r7,r10]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  cmp r2,#0x80<<24
  bne Divide81c0Check1
  cmp r10,#-1
  bne Divide81c0Check1
  bic r9,r9,#(1<<28)|(1<<29)|(1<<30)|(1<<31)
  mov r1,#0
  b Divide81c0WriteVal
Divide81c0Check1:
  cmp r10,#0
  moveq r10,#1 ;@ Divide by zero

  mov r11,#0 ;@ r11 = 1 if the result is negative
  eorlt r11,r11,#1
  rsblt r10,r10,#0 ;@ Make r10 positive

  cmp r2,#0
  eorlt r11,r11,#(1<<0)|(1<<1)
  rsblt r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift81c0:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift81c0

Divide81c0:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide81c0

  tst r11,#1
  rsbne r3,r3,#0 ;@ Negate if result is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ Negate remainder
  mov lr,r3,lsl#16
  mov lr,lr,asr#16
  cmp lr,r3
  bne Divide81c0Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide81c0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#133 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide81c0Overflow:
  orr r9,r9,#1<<28
Divide81c0Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#133 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81d0] divs.w (a0), d0 uses Op81d0 ----------
Op81d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  cmp r2,#0x80<<24
  bne Divide81d0Check1
  cmp r10,#-1
  bne Divide81d0Check1
  bic r9,r9,#(1<<28)|(1<<29)|(1<<30)|(1<<31)
  mov r1,#0
  b Divide81d0WriteVal
Divide81d0Check1:
  cmp r10,#0
  moveq r10,#1 ;@ Divide by zero

  mov r11,#0 ;@ r11 = 1 if the result is negative
  eorlt r11,r11,#1
  rsblt r10,r10,#0 ;@ Make r10 positive

  cmp r2,#0
  eorlt r11,r11,#(1<<0)|(1<<1)
  rsblt r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift81d0:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift81d0

Divide81d0:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide81d0

  tst r11,#1
  rsbne r3,r3,#0 ;@ Negate if result is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ Negate remainder
  mov lr,r3,lsl#16
  mov lr,lr,asr#16
  cmp lr,r3
  bne Divide81d0Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide81d0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide81d0Overflow:
  orr r9,r9,#1<<28
Divide81d0Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81d8] divs.w (a0)+, d0 uses Op81d8 ----------
Op81d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  cmp r2,#0x80<<24
  bne Divide81d8Check1
  cmp r10,#-1
  bne Divide81d8Check1
  bic r9,r9,#(1<<28)|(1<<29)|(1<<30)|(1<<31)
  mov r1,#0
  b Divide81d8WriteVal
Divide81d8Check1:
  cmp r10,#0
  moveq r10,#1 ;@ Divide by zero

  mov r11,#0 ;@ r11 = 1 if the result is negative
  eorlt r11,r11,#1
  rsblt r10,r10,#0 ;@ Make r10 positive

  cmp r2,#0
  eorlt r11,r11,#(1<<0)|(1<<1)
  rsblt r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift81d8:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift81d8

Divide81d8:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide81d8

  tst r11,#1
  rsbne r3,r3,#0 ;@ Negate if result is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ Negate remainder
  mov lr,r3,lsl#16
  mov lr,lr,asr#16
  cmp lr,r3
  bne Divide81d8Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide81d8WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide81d8Overflow:
  orr r9,r9,#1<<28
Divide81d8Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81df] divs.w (a7)+, d0 uses Op81df ----------
Op81df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  cmp r2,#0x80<<24
  bne Divide81dfCheck1
  cmp r10,#-1
  bne Divide81dfCheck1
  bic r9,r9,#(1<<28)|(1<<29)|(1<<30)|(1<<31)
  mov r1,#0
  b Divide81dfWriteVal
Divide81dfCheck1:
  cmp r10,#0
  moveq r10,#1 ;@ Divide by zero

  mov r11,#0 ;@ r11 = 1 if the result is negative
  eorlt r11,r11,#1
  rsblt r10,r10,#0 ;@ Make r10 positive

  cmp r2,#0
  eorlt r11,r11,#(1<<0)|(1<<1)
  rsblt r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift81df:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift81df

Divide81df:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide81df

  tst r11,#1
  rsbne r3,r3,#0 ;@ Negate if result is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ Negate remainder
  mov lr,r3,lsl#16
  mov lr,lr,asr#16
  cmp lr,r3
  bne Divide81dfOverflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide81dfWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide81dfOverflow:
  orr r9,r9,#1<<28
Divide81dfExit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81e0] divs.w -(a0), d0 uses Op81e0 ----------
Op81e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  cmp r2,#0x80<<24
  bne Divide81e0Check1
  cmp r10,#-1
  bne Divide81e0Check1
  bic r9,r9,#(1<<28)|(1<<29)|(1<<30)|(1<<31)
  mov r1,#0
  b Divide81e0WriteVal
Divide81e0Check1:
  cmp r10,#0
  moveq r10,#1 ;@ Divide by zero

  mov r11,#0 ;@ r11 = 1 if the result is negative
  eorlt r11,r11,#1
  rsblt r10,r10,#0 ;@ Make r10 positive

  cmp r2,#0
  eorlt r11,r11,#(1<<0)|(1<<1)
  rsblt r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift81e0:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift81e0

Divide81e0:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide81e0

  tst r11,#1
  rsbne r3,r3,#0 ;@ Negate if result is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ Negate remainder
  mov lr,r3,lsl#16
  mov lr,lr,asr#16
  cmp lr,r3
  bne Divide81e0Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide81e0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#139 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide81e0Overflow:
  orr r9,r9,#1<<28
Divide81e0Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#139 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81e7] divs.w -(a7), d0 uses Op81e7 ----------
Op81e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  cmp r2,#0x80<<24
  bne Divide81e7Check1
  cmp r10,#-1
  bne Divide81e7Check1
  bic r9,r9,#(1<<28)|(1<<29)|(1<<30)|(1<<31)
  mov r1,#0
  b Divide81e7WriteVal
Divide81e7Check1:
  cmp r10,#0
  moveq r10,#1 ;@ Divide by zero

  mov r11,#0 ;@ r11 = 1 if the result is negative
  eorlt r11,r11,#1
  rsblt r10,r10,#0 ;@ Make r10 positive

  cmp r2,#0
  eorlt r11,r11,#(1<<0)|(1<<1)
  rsblt r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift81e7:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift81e7

Divide81e7:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide81e7

  tst r11,#1
  rsbne r3,r3,#0 ;@ Negate if result is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ Negate remainder
  mov lr,r3,lsl#16
  mov lr,lr,asr#16
  cmp lr,r3
  bne Divide81e7Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide81e7WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#139 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide81e7Overflow:
  orr r9,r9,#1<<28
Divide81e7Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#139 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81e8] divs.w ($3333,a0), d0 uses Op81e8 ----------
Op81e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  cmp r2,#0x80<<24
  bne Divide81e8Check1
  cmp r10,#-1
  bne Divide81e8Check1
  bic r9,r9,#(1<<28)|(1<<29)|(1<<30)|(1<<31)
  mov r1,#0
  b Divide81e8WriteVal
Divide81e8Check1:
  cmp r10,#0
  moveq r10,#1 ;@ Divide by zero

  mov r11,#0 ;@ r11 = 1 if the result is negative
  eorlt r11,r11,#1
  rsblt r10,r10,#0 ;@ Make r10 positive

  cmp r2,#0
  eorlt r11,r11,#(1<<0)|(1<<1)
  rsblt r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift81e8:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift81e8

Divide81e8:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide81e8

  tst r11,#1
  rsbne r3,r3,#0 ;@ Negate if result is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ Negate remainder
  mov lr,r3,lsl#16
  mov lr,lr,asr#16
  cmp lr,r3
  bne Divide81e8Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide81e8WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#141 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide81e8Overflow:
  orr r9,r9,#1<<28
Divide81e8Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#141 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81f0] divs.w ($33,a0,d3.w*2), d0 uses Op81f0 ----------
Op81f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  cmp r2,#0x80<<24
  bne Divide81f0Check1
  cmp r10,#-1
  bne Divide81f0Check1
  bic r9,r9,#(1<<28)|(1<<29)|(1<<30)|(1<<31)
  mov r1,#0
  b Divide81f0WriteVal
Divide81f0Check1:
  cmp r10,#0
  moveq r10,#1 ;@ Divide by zero

  mov r11,#0 ;@ r11 = 1 if the result is negative
  eorlt r11,r11,#1
  rsblt r10,r10,#0 ;@ Make r10 positive

  cmp r2,#0
  eorlt r11,r11,#(1<<0)|(1<<1)
  rsblt r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift81f0:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift81f0

Divide81f0:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide81f0

  tst r11,#1
  rsbne r3,r3,#0 ;@ Negate if result is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ Negate remainder
  mov lr,r3,lsl#16
  mov lr,lr,asr#16
  cmp lr,r3
  bne Divide81f0Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide81f0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#143 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide81f0Overflow:
  orr r9,r9,#1<<28
Divide81f0Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#143 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81f8] divs.w $3333.w, d0 uses Op81f8 ----------
Op81f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  cmp r2,#0x80<<24
  bne Divide81f8Check1
  cmp r10,#-1
  bne Divide81f8Check1
  bic r9,r9,#(1<<28)|(1<<29)|(1<<30)|(1<<31)
  mov r1,#0
  b Divide81f8WriteVal
Divide81f8Check1:
  cmp r10,#0
  moveq r10,#1 ;@ Divide by zero

  mov r11,#0 ;@ r11 = 1 if the result is negative
  eorlt r11,r11,#1
  rsblt r10,r10,#0 ;@ Make r10 positive

  cmp r2,#0
  eorlt r11,r11,#(1<<0)|(1<<1)
  rsblt r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift81f8:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift81f8

Divide81f8:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide81f8

  tst r11,#1
  rsbne r3,r3,#0 ;@ Negate if result is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ Negate remainder
  mov lr,r3,lsl#16
  mov lr,lr,asr#16
  cmp lr,r3
  bne Divide81f8Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide81f8WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#141 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide81f8Overflow:
  orr r9,r9,#1<<28
Divide81f8Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#141 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81f9] divs.w $33333333.l, d0 uses Op81f9 ----------
Op81f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  cmp r2,#0x80<<24
  bne Divide81f9Check1
  cmp r10,#-1
  bne Divide81f9Check1
  bic r9,r9,#(1<<28)|(1<<29)|(1<<30)|(1<<31)
  mov r1,#0
  b Divide81f9WriteVal
Divide81f9Check1:
  cmp r10,#0
  moveq r10,#1 ;@ Divide by zero

  mov r11,#0 ;@ r11 = 1 if the result is negative
  eorlt r11,r11,#1
  rsblt r10,r10,#0 ;@ Make r10 positive

  cmp r2,#0
  eorlt r11,r11,#(1<<0)|(1<<1)
  rsblt r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift81f9:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift81f9

Divide81f9:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide81f9

  tst r11,#1
  rsbne r3,r3,#0 ;@ Negate if result is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ Negate remainder
  mov lr,r3,lsl#16
  mov lr,lr,asr#16
  cmp lr,r3
  bne Divide81f9Overflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide81f9WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#145 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide81f9Overflow:
  orr r9,r9,#1<<28
Divide81f9Exit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#145 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81fa] divs.w ($3333,pc), d0; =3335 uses Op81fa ----------
Op81fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  cmp r2,#0x80<<24
  bne Divide81faCheck1
  cmp r10,#-1
  bne Divide81faCheck1
  bic r9,r9,#(1<<28)|(1<<29)|(1<<30)|(1<<31)
  mov r1,#0
  b Divide81faWriteVal
Divide81faCheck1:
  cmp r10,#0
  moveq r10,#1 ;@ Divide by zero

  mov r11,#0 ;@ r11 = 1 if the result is negative
  eorlt r11,r11,#1
  rsblt r10,r10,#0 ;@ Make r10 positive

  cmp r2,#0
  eorlt r11,r11,#(1<<0)|(1<<1)
  rsblt r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift81fa:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift81fa

Divide81fa:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide81fa

  tst r11,#1
  rsbne r3,r3,#0 ;@ Negate if result is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ Negate remainder
  mov lr,r3,lsl#16
  mov lr,lr,asr#16
  cmp lr,r3
  bne Divide81faOverflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide81faWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#141 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide81faOverflow:
  orr r9,r9,#1<<28
Divide81faExit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#141 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81fb] divs.w ($33,pc,d3.w*2), d0; =35 uses Op81fb ----------
Op81fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  cmp r2,#0x80<<24
  bne Divide81fbCheck1
  cmp r10,#-1
  bne Divide81fbCheck1
  bic r9,r9,#(1<<28)|(1<<29)|(1<<30)|(1<<31)
  mov r1,#0
  b Divide81fbWriteVal
Divide81fbCheck1:
  cmp r10,#0
  moveq r10,#1 ;@ Divide by zero

  mov r11,#0 ;@ r11 = 1 if the result is negative
  eorlt r11,r11,#1
  rsblt r10,r10,#0 ;@ Make r10 positive

  cmp r2,#0
  eorlt r11,r11,#(1<<0)|(1<<1)
  rsblt r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift81fb:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift81fb

Divide81fb:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide81fb

  tst r11,#1
  rsbne r3,r3,#0 ;@ Negate if result is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ Negate remainder
  mov lr,r3,lsl#16
  mov lr,lr,asr#16
  cmp lr,r3
  bne Divide81fbOverflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide81fbWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#143 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide81fbOverflow:
  orr r9,r9,#1<<28
Divide81fbExit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#143 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81fc] divs.w #$3333, d0 uses Op81fc ----------
Op81fc:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

  cmp r2,#0x80<<24
  bne Divide81fcCheck1
  cmp r10,#-1
  bne Divide81fcCheck1
  bic r9,r9,#(1<<28)|(1<<29)|(1<<30)|(1<<31)
  mov r1,#0
  b Divide81fcWriteVal
Divide81fcCheck1:
  cmp r10,#0
  moveq r10,#1 ;@ Divide by zero

  mov r11,#0 ;@ r11 = 1 if the result is negative
  eorlt r11,r11,#1
  rsblt r10,r10,#0 ;@ Make r10 positive

  cmp r2,#0
  eorlt r11,r11,#(1<<0)|(1<<1)
  rsblt r2,r2,#0 ;@ Make r2 positive

;@ Divide r2 by r10
  mov r3,#0
  mov r1,r10
  cmp r1,r2,lsr#1

;@ Shift up divisor till it's just less than numerator
Shift81fc:
  movls r1,r1,lsl #1
  cmp r1,r2,lsr #1
  bls Shift81fc

Divide81fc:
  cmp r2,r1
  subcs r2,r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  mov r1,r1,lsr#1
  cmp r1,r10
  bhs Divide81fc

  tst r11,#1
  rsbne r3,r3,#0 ;@ Negate if result is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ Negate remainder
  mov lr,r3,lsl#16
  mov lr,lr,asr#16
  cmp lr,r3
  bne Divide81fcOverflow
  mov r11,r2 ;@ Remainder
  mov r3,r3,lsl#16 ;@ Defines NZ, clears CV
  adds r3,r3,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r3,lsr#16 ;@ Defines NZ, clears CV
  orr r1,r1,r11,lsl #16 ;@ Insert remainder

Divide81fcWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Divide81fcOverflow:
  orr r9,r9,#1<<28
Divide81fcExit:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#137 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9000] sub.b d0, d0 uses Op9000 ----------
Op9000:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r11:
  ldrsb r11,[r7,r10]
  mov r11,r11,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9010] sub.b (a0), d0 uses Op9010 ----------
Op9010:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9018] sub.b (a0)+, d0 uses Op9018 ----------
Op9018:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [901f] sub.b (a7)+, d0 uses Op901f ----------
Op901f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9020] sub.b -(a0), d0 uses Op9020 ----------
Op9020:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9027] sub.b -(a7), d0 uses Op9027 ----------
Op9027:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9028] sub.b ($3333,a0), d0 uses Op9028 ----------
Op9028:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9030] sub.b ($33,a0,d3.w*2), d0 uses Op9030 ----------
Op9030:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9038] sub.b $3333.w, d0 uses Op9038 ----------
Op9038:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9039] sub.b $33333333.l, d0 uses Op9039 ----------
Op9039:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903a] sub.b ($3333,pc), d0; =3335 uses Op903a ----------
Op903a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903b] sub.b ($33,pc,d3.w*2), d0; =35 uses Op903b ----------
Op903b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903c] sub.b #$33, d0 uses Op903c ----------
Op903c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r11:
  mov r11,r10,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903d] sub.b ea=(111 101), d0 uses Op903d ----------
Op903d:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 101)' into r10:
;@ EaRead : Read 'ea=(111 101)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903e] sub.b ea=(111 110), d0 uses Op903e ----------
Op903e:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 110)' into r10:
;@ EaRead : Read 'ea=(111 110)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903f] sub.b ea=(111 111), d0 uses Op903f ----------
Op903f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 111)' into r10:
;@ EaRead : Read 'ea=(111 111)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9040] sub.w d0, d0 uses Op9040 ----------
Op9040:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r11:
  ldrsh r11,[r7,r10]
  mov r11,r11,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9050] sub.w (a0), d0 uses Op9050 ----------
Op9050:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9058] sub.w (a0)+, d0 uses Op9058 ----------
Op9058:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [905f] sub.w (a7)+, d0 uses Op905f ----------
Op905f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9060] sub.w -(a0), d0 uses Op9060 ----------
Op9060:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9067] sub.w -(a7), d0 uses Op9067 ----------
Op9067:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9068] sub.w ($3333,a0), d0 uses Op9068 ----------
Op9068:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9070] sub.w ($33,a0,d3.w*2), d0 uses Op9070 ----------
Op9070:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9078] sub.w $3333.w, d0 uses Op9078 ----------
Op9078:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9079] sub.w $33333333.l, d0 uses Op9079 ----------
Op9079:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907a] sub.w ($3333,pc), d0; =3335 uses Op907a ----------
Op907a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907b] sub.w ($33,pc,d3.w*2), d0; =35 uses Op907b ----------
Op907b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907c] sub.w #$3333, d0 uses Op907c ----------
Op907c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r11:
  mov r11,r10,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907d] sub.w ea=(111 101), d0 uses Op907d ----------
Op907d:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 101)' into r10:
;@ EaRead : Read 'ea=(111 101)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907e] sub.w ea=(111 110), d0 uses Op907e ----------
Op907e:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 110)' into r10:
;@ EaRead : Read 'ea=(111 110)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907f] sub.w ea=(111 111), d0 uses Op907f ----------
Op907f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 111)' into r10:
;@ EaRead : Read 'ea=(111 111)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9080] sub.l d0, d0 uses Op9080 ----------
Op9080:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsl #2]

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9090] sub.l (a0), d0 uses Op9090 ----------
Op9090:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9098] sub.l (a0)+, d0 uses Op9098 ----------
Op9098:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [909f] sub.l (a7)+, d0 uses Op909f ----------
Op909f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90a0] sub.l -(a0), d0 uses Op90a0 ----------
Op90a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90a7] sub.l -(a7), d0 uses Op90a7 ----------
Op90a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90a8] sub.l ($3333,a0), d0 uses Op90a8 ----------
Op90a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90b0] sub.l ($33,a0,d3.w*2), d0 uses Op90b0 ----------
Op90b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90b8] sub.l $3333.w, d0 uses Op90b8 ----------
Op90b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90b9] sub.l $33333333.l, d0 uses Op90b9 ----------
Op90b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90ba] sub.l ($3333,pc), d0; =3335 uses Op90ba ----------
Op90ba:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90bb] sub.l ($33,pc,d3.w*2), d0; =35 uses Op90bb ----------
Op90bb:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90bc] sub.l #$33333333, d0 uses Op90bc ----------
Op90bc:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r11:
  mov r11,r10,asl #0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90bd] sub.l ea=(111 101), d0 uses Op90bd ----------
Op90bd:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 101)' into r10:
;@ EaRead : Read 'ea=(111 101)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90be] sub.l ea=(111 110), d0 uses Op90be ----------
Op90be:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 110)' into r10:
;@ EaRead : Read 'ea=(111 110)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90bf] sub.l ea=(111 111), d0 uses Op90bf ----------
Op90bf:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 111)' into r10:
;@ EaRead : Read 'ea=(111 111)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90c0] suba.w d0, a0 uses Op90c0 ----------
Op90c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r10:
  ldrsh r10,[r7,r0]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90d0] suba.w (a0), a0 uses Op90d0 ----------
Op90d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90d8] suba.w (a0)+, a0 uses Op90d8 ----------
Op90d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90df] suba.w (a7)+, a0 uses Op90df ----------
Op90df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90e0] suba.w -(a0), a0 uses Op90e0 ----------
Op90e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90e7] suba.w -(a7), a0 uses Op90e7 ----------
Op90e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90e8] suba.w ($3333,a0), a0 uses Op90e8 ----------
Op90e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90f0] suba.w ($33,a0,d3.w*2), a0 uses Op90f0 ----------
Op90f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90f8] suba.w $3333.w, a0 uses Op90f8 ----------
Op90f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90f9] suba.w $33333333.l, a0 uses Op90f9 ----------
Op90f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90fa] suba.w ($3333,pc), a0; =3335 uses Op90fa ----------
Op90fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90fb] suba.w ($33,pc,d3.w*2), a0; =35 uses Op90fb ----------
Op90fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90fc] suba.w #$3333, a0 uses Op90fc ----------
Op90fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r10:
  mov r10,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9100] subx.b d0, d0 uses Op9100 ----------
Op9100:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r11:
  ldrsb r11,[r7,r0]
  mov r11,r11,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  mov r2,r9
  mrs r9,cpsr ;@ r9=flags
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9110] sub.b d0, (a0) uses Op9110 ----------
Op9110:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9118] sub.b d0, (a0)+ uses Op9118 ----------
Op9118:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [911f] sub.b d0, (a7)+ uses Op911f ----------
Op911f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9120] sub.b d0, -(a0) uses Op9120 ----------
Op9120:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9127] sub.b d0, -(a7) uses Op9127 ----------
Op9127:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9128] sub.b d0, ($3333,a0) uses Op9128 ----------
Op9128:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9130] sub.b d0, ($33,a0,d3.w*2) uses Op9130 ----------
Op9130:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9138] sub.b d0, $3333.w uses Op9138 ----------
Op9138:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9139] sub.b d0, $33333333.l uses Op9139 ----------
Op9139:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [913a] sub.b d0, ($3333,pc); =3335 uses Op913a ----------
Op913a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [913b] sub.b d0, ($33,pc,d3.w*2); =35 uses Op913b ----------
Op913b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9140] subx.w d0, d0 uses Op9140 ----------
Op9140:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r11:
  ldrsh r11,[r7,r0]
  mov r11,r11,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  mov r2,r9
  mrs r9,cpsr ;@ r9=flags
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9150] sub.w d0, (a0) uses Op9150 ----------
Op9150:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9158] sub.w d0, (a0)+ uses Op9158 ----------
Op9158:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [915f] sub.w d0, (a7)+ uses Op915f ----------
Op915f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9160] sub.w d0, -(a0) uses Op9160 ----------
Op9160:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9167] sub.w d0, -(a7) uses Op9167 ----------
Op9167:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9168] sub.w d0, ($3333,a0) uses Op9168 ----------
Op9168:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9170] sub.w d0, ($33,a0,d3.w*2) uses Op9170 ----------
Op9170:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9178] sub.w d0, $3333.w uses Op9178 ----------
Op9178:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9179] sub.w d0, $33333333.l uses Op9179 ----------
Op9179:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [917a] sub.w d0, ($3333,pc); =3335 uses Op917a ----------
Op917a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [917b] sub.w d0, ($33,pc,d3.w*2); =35 uses Op917b ----------
Op917b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9180] subx.l d0, d0 uses Op9180 ----------
Op9180:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r11:
  ldr r11,[r7,r0,lsl #2]

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mvn r2,r2,lsl #28 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  sbcs r1,r1,r11
  mov r2,r9
  mrs r9,cpsr ;@ r9=flags
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9190] sub.l d0, (a0) uses Op9190 ----------
Op9190:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9198] sub.l d0, (a0)+ uses Op9198 ----------
Op9198:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [919f] sub.l d0, (a7)+ uses Op919f ----------
Op919f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91a0] sub.l d0, -(a0) uses Op91a0 ----------
Op91a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91a7] sub.l d0, -(a7) uses Op91a7 ----------
Op91a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91a8] sub.l d0, ($3333,a0) uses Op91a8 ----------
Op91a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91b0] sub.l d0, ($33,a0,d3.w*2) uses Op91b0 ----------
Op91b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91b8] sub.l d0, $3333.w uses Op91b8 ----------
Op91b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91b9] sub.l d0, $33333333.l uses Op91b9 ----------
Op91b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91ba] sub.l d0, ($3333,pc); =3335 uses Op91ba ----------
Op91ba:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91bb] sub.l d0, ($33,pc,d3.w*2); =35 uses Op91bb ----------
Op91bb:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  subs r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91c0] suba.l d0, a0 uses Op91c0 ----------
Op91c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r10:
  ldr r10,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91d0] suba.l (a0), a0 uses Op91d0 ----------
Op91d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91d8] suba.l (a0)+, a0 uses Op91d8 ----------
Op91d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91df] suba.l (a7)+, a0 uses Op91df ----------
Op91df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91e0] suba.l -(a0), a0 uses Op91e0 ----------
Op91e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91e7] suba.l -(a7), a0 uses Op91e7 ----------
Op91e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91e8] suba.l ($3333,a0), a0 uses Op91e8 ----------
Op91e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91f0] suba.l ($33,a0,d3.w*2), a0 uses Op91f0 ----------
Op91f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91f8] suba.l $3333.w, a0 uses Op91f8 ----------
Op91f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91f9] suba.l $33333333.l, a0 uses Op91f9 ----------
Op91f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91fa] suba.l ($3333,pc), a0; =3335 uses Op91fa ----------
Op91fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91fb] suba.l ($33,pc,d3.w*2), a0; =35 uses Op91fb ----------
Op91fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91fc] suba.l #$33333333, a0 uses Op91fc ----------
Op91fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r10:
  mov r10,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  sub r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b000] cmp.b d0, d0 uses Opb000 ----------
Opb000:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b010] cmp.b (a0), d0 uses Opb010 ----------
Opb010:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b018] cmp.b (a0)+, d0 uses Opb018 ----------
Opb018:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b01f] cmp.b (a7)+, d0 uses Opb01f ----------
Opb01f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b020] cmp.b -(a0), d0 uses Opb020 ----------
Opb020:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b027] cmp.b -(a7), d0 uses Opb027 ----------
Opb027:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b028] cmp.b ($3333,a0), d0 uses Opb028 ----------
Opb028:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b030] cmp.b ($33,a0,d3.w*2), d0 uses Opb030 ----------
Opb030:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b038] cmp.b $3333.w, d0 uses Opb038 ----------
Opb038:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b039] cmp.b $33333333.l, d0 uses Opb039 ----------
Opb039:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b03a] cmp.b ($3333,pc), d0; =3335 uses Opb03a ----------
Opb03a:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b03b] cmp.b ($33,pc,d3.w*2), d0; =35 uses Opb03b ----------
Opb03b:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b03c] cmp.b #$33, d0 uses Opb03c ----------
Opb03c:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r0:
  mov r0,r10,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b040] cmp.w d0, d0 uses Opb040 ----------
Opb040:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b050] cmp.w (a0), d0 uses Opb050 ----------
Opb050:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b058] cmp.w (a0)+, d0 uses Opb058 ----------
Opb058:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b05f] cmp.w (a7)+, d0 uses Opb05f ----------
Opb05f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b060] cmp.w -(a0), d0 uses Opb060 ----------
Opb060:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b067] cmp.w -(a7), d0 uses Opb067 ----------
Opb067:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b068] cmp.w ($3333,a0), d0 uses Opb068 ----------
Opb068:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b070] cmp.w ($33,a0,d3.w*2), d0 uses Opb070 ----------
Opb070:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b078] cmp.w $3333.w, d0 uses Opb078 ----------
Opb078:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b079] cmp.w $33333333.l, d0 uses Opb079 ----------
Opb079:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b07a] cmp.w ($3333,pc), d0; =3335 uses Opb07a ----------
Opb07a:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b07b] cmp.w ($33,pc,d3.w*2), d0; =35 uses Opb07b ----------
Opb07b:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b07c] cmp.w #$3333, d0 uses Opb07c ----------
Opb07c:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r0:
  mov r0,r10,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b080] cmp.l d0, d0 uses Opb080 ----------
Opb080:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b090] cmp.l (a0), d0 uses Opb090 ----------
Opb090:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b098] cmp.l (a0)+, d0 uses Opb098 ----------
Opb098:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b09f] cmp.l (a7)+, d0 uses Opb09f ----------
Opb09f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0a0] cmp.l -(a0), d0 uses Opb0a0 ----------
Opb0a0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0a7] cmp.l -(a7), d0 uses Opb0a7 ----------
Opb0a7:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0a8] cmp.l ($3333,a0), d0 uses Opb0a8 ----------
Opb0a8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0b0] cmp.l ($33,a0,d3.w*2), d0 uses Opb0b0 ----------
Opb0b0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0b8] cmp.l $3333.w, d0 uses Opb0b8 ----------
Opb0b8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0b9] cmp.l $33333333.l, d0 uses Opb0b9 ----------
Opb0b9:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0ba] cmp.l ($3333,pc), d0; =3335 uses Opb0ba ----------
Opb0ba:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0bb] cmp.l ($33,pc,d3.w*2), d0; =35 uses Opb0bb ----------
Opb0bb:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0bc] cmp.l #$33333333, d0 uses Opb0bc ----------
Opb0bc:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r0:
  mov r0,r10,asl #0

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  cmp r1,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0c0] cmpa.w d0, a0 uses Opb0c0 ----------
Opb0c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r10:
  ldrsh r10,[r7,r0]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0d0] cmpa.w (a0), a0 uses Opb0d0 ----------
Opb0d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0d8] cmpa.w (a0)+, a0 uses Opb0d8 ----------
Opb0d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0df] cmpa.w (a7)+, a0 uses Opb0df ----------
Opb0df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0e0] cmpa.w -(a0), a0 uses Opb0e0 ----------
Opb0e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0e7] cmpa.w -(a7), a0 uses Opb0e7 ----------
Opb0e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0e8] cmpa.w ($3333,a0), a0 uses Opb0e8 ----------
Opb0e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0f0] cmpa.w ($33,a0,d3.w*2), a0 uses Opb0f0 ----------
Opb0f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0f8] cmpa.w $3333.w, a0 uses Opb0f8 ----------
Opb0f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0f9] cmpa.w $33333333.l, a0 uses Opb0f9 ----------
Opb0f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0fa] cmpa.w ($3333,pc), a0; =3335 uses Opb0fa ----------
Opb0fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0fb] cmpa.w ($33,pc,d3.w*2), a0; =35 uses Opb0fb ----------
Opb0fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0fc] cmpa.w #$3333, a0 uses Opb0fc ----------
Opb0fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r10:
  mov r10,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b100] eor.b d0, d0 uses Opb100 ----------
Opb100:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b108] cmpm.b a0, a0 uses Opb108 ----------
Opb108:
;@ Get src operand into r10:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  mov r2,r2,lsr #7
  ldr r0,[r7,r2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b110] eor.b d0, (a0) uses Opb110 ----------
Opb110:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b118] eor.b d0, (a0)+ uses Opb118 ----------
Opb118:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b11f] eor.b d0, (a7)+ uses Opb11f ----------
Opb11f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b120] eor.b d0, -(a0) uses Opb120 ----------
Opb120:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b127] eor.b d0, -(a7) uses Opb127 ----------
Opb127:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b128] eor.b d0, ($3333,a0) uses Opb128 ----------
Opb128:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b130] eor.b d0, ($33,a0,d3.w*2) uses Opb130 ----------
Opb130:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b138] eor.b d0, $3333.w uses Opb138 ----------
Opb138:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b139] eor.b d0, $33333333.l uses Opb139 ----------
Opb139:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b13a] eor.b d0, ($3333,pc); =3335 uses Opb13a ----------
Opb13a:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b13b] eor.b d0, ($33,pc,d3.w*2); =35 uses Opb13b ----------
Opb13b:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r0,r0,asl #24

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]
  mov r1,r1,asl #24

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b140] eor.w d0, d0 uses Opb140 ----------
Opb140:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b148] cmpm.w a0, a0 uses Opb148 ----------
Opb148:
;@ Get src operand into r10:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  mov r2,r2,lsr #7
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b150] eor.w d0, (a0) uses Opb150 ----------
Opb150:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b158] eor.w d0, (a0)+ uses Opb158 ----------
Opb158:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b15f] eor.w d0, (a7)+ uses Opb15f ----------
Opb15f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b160] eor.w d0, -(a0) uses Opb160 ----------
Opb160:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b167] eor.w d0, -(a7) uses Opb167 ----------
Opb167:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b168] eor.w d0, ($3333,a0) uses Opb168 ----------
Opb168:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b170] eor.w d0, ($33,a0,d3.w*2) uses Opb170 ----------
Opb170:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b178] eor.w d0, $3333.w uses Opb178 ----------
Opb178:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b179] eor.w d0, $33333333.l uses Opb179 ----------
Opb179:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b17a] eor.w d0, ($3333,pc); =3335 uses Opb17a ----------
Opb17a:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b17b] eor.w d0, ($33,pc,d3.w*2); =35 uses Opb17b ----------
Opb17b:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #7
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]
  mov r1,r1,asl #16

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b180] eor.l d0, d0 uses Opb180 ----------
Opb180:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b188] cmpm.l a0, a0 uses Opb188 ----------
Opb188:
;@ Get src operand into r10:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  mov r2,r2,lsr #7
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

  cmp r0,r10
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b190] eor.l d0, (a0) uses Opb190 ----------
Opb190:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b198] eor.l d0, (a0)+ uses Opb198 ----------
Opb198:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b19f] eor.l d0, (a7)+ uses Opb19f ----------
Opb19f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1a0] eor.l d0, -(a0) uses Opb1a0 ----------
Opb1a0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1a7] eor.l d0, -(a7) uses Opb1a7 ----------
Opb1a7:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1a8] eor.l d0, ($3333,a0) uses Opb1a8 ----------
Opb1a8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1b0] eor.l d0, ($33,a0,d3.w*2) uses Opb1b0 ----------
Opb1b0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1b8] eor.l d0, $3333.w uses Opb1b8 ----------
Opb1b8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1b9] eor.l d0, $33333333.l uses Opb1b9 ----------
Opb1b9:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1ba] eor.l d0, ($3333,pc); =3335 uses Opb1ba ----------
Opb1ba:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1bb] eor.l d0, ($33,pc,d3.w*2); =35 uses Opb1bb ----------
Opb1bb:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
  mov r1,r1,lsr #9
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1c0] cmpa.l d0, a0 uses Opb1c0 ----------
Opb1c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r10:
  ldr r10,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1d0] cmpa.l (a0), a0 uses Opb1d0 ----------
Opb1d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1d8] cmpa.l (a0)+, a0 uses Opb1d8 ----------
Opb1d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1df] cmpa.l (a7)+, a0 uses Opb1df ----------
Opb1df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1e0] cmpa.l -(a0), a0 uses Opb1e0 ----------
Opb1e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1e7] cmpa.l -(a7), a0 uses Opb1e7 ----------
Opb1e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1e8] cmpa.l ($3333,a0), a0 uses Opb1e8 ----------
Opb1e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1f0] cmpa.l ($33,a0,d3.w*2), a0 uses Opb1f0 ----------
Opb1f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1f8] cmpa.l $3333.w, a0 uses Opb1f8 ----------
Opb1f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1f9] cmpa.l $33333333.l, a0 uses Opb1f9 ----------
Opb1f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1fa] cmpa.l ($3333,pc), a0; =3335 uses Opb1fa ----------
Opb1fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1fb] cmpa.l ($33,pc,d3.w*2), a0; =35 uses Opb1fb ----------
Opb1fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1fc] cmpa.l #$33333333, a0 uses Opb1fc ----------
Opb1fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r10:
  mov r10,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  cmp r1,r10 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c000] and.b d0, d0 uses Opc000 ----------
Opc000:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r11:
  ldrsb r11,[r7,r10]
  mov r11,r11,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c010] and.b (a0), d0 uses Opc010 ----------
Opc010:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c018] and.b (a0)+, d0 uses Opc018 ----------
Opc018:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c01f] and.b (a7)+, d0 uses Opc01f ----------
Opc01f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c020] and.b -(a0), d0 uses Opc020 ----------
Opc020:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c027] and.b -(a7), d0 uses Opc027 ----------
Opc027:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c028] and.b ($3333,a0), d0 uses Opc028 ----------
Opc028:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c030] and.b ($33,a0,d3.w*2), d0 uses Opc030 ----------
Opc030:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c038] and.b $3333.w, d0 uses Opc038 ----------
Opc038:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c039] and.b $33333333.l, d0 uses Opc039 ----------
Opc039:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03a] and.b ($3333,pc), d0; =3335 uses Opc03a ----------
Opc03a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03b] and.b ($33,pc,d3.w*2), d0; =35 uses Opc03b ----------
Opc03b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03c] and.b #$33, d0 uses Opc03c ----------
Opc03c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r11:
  mov r11,r10,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03d] and.b ea=(111 101), d0 uses Opc03d ----------
Opc03d:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 101)' into r10:
;@ EaRead : Read 'ea=(111 101)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03e] and.b ea=(111 110), d0 uses Opc03e ----------
Opc03e:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 110)' into r10:
;@ EaRead : Read 'ea=(111 110)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03f] and.b ea=(111 111), d0 uses Opc03f ----------
Opc03f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 111)' into r10:
;@ EaRead : Read 'ea=(111 111)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c040] and.w d0, d0 uses Opc040 ----------
Opc040:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r11:
  ldrsh r11,[r7,r10]
  mov r11,r11,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c050] and.w (a0), d0 uses Opc050 ----------
Opc050:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c058] and.w (a0)+, d0 uses Opc058 ----------
Opc058:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c05f] and.w (a7)+, d0 uses Opc05f ----------
Opc05f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c060] and.w -(a0), d0 uses Opc060 ----------
Opc060:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c067] and.w -(a7), d0 uses Opc067 ----------
Opc067:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c068] and.w ($3333,a0), d0 uses Opc068 ----------
Opc068:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c070] and.w ($33,a0,d3.w*2), d0 uses Opc070 ----------
Opc070:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c078] and.w $3333.w, d0 uses Opc078 ----------
Opc078:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c079] and.w $33333333.l, d0 uses Opc079 ----------
Opc079:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07a] and.w ($3333,pc), d0; =3335 uses Opc07a ----------
Opc07a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07b] and.w ($33,pc,d3.w*2), d0; =35 uses Opc07b ----------
Opc07b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07c] and.w #$3333, d0 uses Opc07c ----------
Opc07c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r11:
  mov r11,r10,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07d] and.w ea=(111 101), d0 uses Opc07d ----------
Opc07d:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 101)' into r10:
;@ EaRead : Read 'ea=(111 101)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07e] and.w ea=(111 110), d0 uses Opc07e ----------
Opc07e:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 110)' into r10:
;@ EaRead : Read 'ea=(111 110)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07f] and.w ea=(111 111), d0 uses Opc07f ----------
Opc07f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 111)' into r10:
;@ EaRead : Read 'ea=(111 111)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c080] and.l d0, d0 uses Opc080 ----------
Opc080:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsl #2]

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c090] and.l (a0), d0 uses Opc090 ----------
Opc090:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c098] and.l (a0)+, d0 uses Opc098 ----------
Opc098:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c09f] and.l (a7)+, d0 uses Opc09f ----------
Opc09f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0a0] and.l -(a0), d0 uses Opc0a0 ----------
Opc0a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0a7] and.l -(a7), d0 uses Opc0a7 ----------
Opc0a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0a8] and.l ($3333,a0), d0 uses Opc0a8 ----------
Opc0a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0b0] and.l ($33,a0,d3.w*2), d0 uses Opc0b0 ----------
Opc0b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0b8] and.l $3333.w, d0 uses Opc0b8 ----------
Opc0b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0b9] and.l $33333333.l, d0 uses Opc0b9 ----------
Opc0b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0ba] and.l ($3333,pc), d0; =3335 uses Opc0ba ----------
Opc0ba:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0bb] and.l ($33,pc,d3.w*2), d0; =35 uses Opc0bb ----------
Opc0bb:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0bc] and.l #$33333333, d0 uses Opc0bc ----------
Opc0bc:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r11:
  mov r11,r10,asl #0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0bd] and.l ea=(111 101), d0 uses Opc0bd ----------
Opc0bd:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 101)' into r10:
;@ EaRead : Read 'ea=(111 101)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0be] and.l ea=(111 110), d0 uses Opc0be ----------
Opc0be:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 110)' into r10:
;@ EaRead : Read 'ea=(111 110)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0bf] and.l ea=(111 111), d0 uses Opc0bf ----------
Opc0bf:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 111)' into r10:
;@ EaRead : Read 'ea=(111 111)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r1,r11
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0c0] mulu.w d0, d0 uses Opc0c0 ----------
Opc0c0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r10:
  ldrsh r10,[r7,r10]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec0c0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#70 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0d0] mulu.w (a0), d0 uses Opc0d0 ----------
Opc0d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec0d0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#74 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0d8] mulu.w (a0)+, d0 uses Opc0d8 ----------
Opc0d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec0d8WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#74 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0df] mulu.w (a7)+, d0 uses Opc0df ----------
Opc0df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec0dfWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#74 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0e0] mulu.w -(a0), d0 uses Opc0e0 ----------
Opc0e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec0e0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#76 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0e7] mulu.w -(a7), d0 uses Opc0e7 ----------
Opc0e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec0e7WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#76 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0e8] mulu.w ($3333,a0), d0 uses Opc0e8 ----------
Opc0e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec0e8WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#78 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0f0] mulu.w ($33,a0,d3.w*2), d0 uses Opc0f0 ----------
Opc0f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec0f0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#80 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0f8] mulu.w $3333.w, d0 uses Opc0f8 ----------
Opc0f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec0f8WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#78 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0f9] mulu.w $33333333.l, d0 uses Opc0f9 ----------
Opc0f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec0f9WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#82 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0fa] mulu.w ($3333,pc), d0; =3335 uses Opc0fa ----------
Opc0fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec0faWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#78 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0fb] mulu.w ($33,pc,d3.w*2), d0; =35 uses Opc0fb ----------
Opc0fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec0fbWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#80 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0fc] mulu.w #$3333, d0 uses Opc0fc ----------
Opc0fc:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r10,r10,lsl #16
  mov r2,r2,lsl #16
  mov r10,r10,lsr #16
  mov r2,r2,lsr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec0fcWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#74 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c100] abcd d0, d0 uses Opc100 ----------
Opc100:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r10:
  ldrsb r10,[r7,r0]
  mov r10,r10,asl #24

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldrsb r1,[r7,r11]
  mov r1,r1,asl #24

  ldrb r2,[r7,#0x45] ;@ Get X bit
  tst r2,#2
  addne r10,r10,#0x01000000 ;@ Add carry bit
;@ Add units into r2:
  mov r1,r1,lsr#24
  mov r10,r10,lsr#24
  and r2,r1, #0x0f
  and r0,r10,#0x0f
  add r2,r2,r0
  cmp r2,#0x09
  addgt r2,r2,#0x06 ;@ Decimal adjust units
  and r1,r1,#0xF0
  and r10,r10,#0xF0
  add r1,r1,r10 ;@ Add BCD
  add r1,r1,r2
  bic r9,r9,#(1<<29)|(1<<31)  ;@ clear szc
  cmp r1,#0x99
  subgt r1,r1,#0xa0
  orrgt r9,r9,#1<<29
  mov r1,r1,lsl#24
  adds r1,r1,#0      ;@ define sz
  orrmi r9,r9,#1<<31 ;@ set S flag
  bicne r9,r9,#1<<30 ;@ set Z flag
  mov r2,r9,lsr#28
  strb r2,[r7,#0x45] ;@ set X flag

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c108] abcd -(a0), -(a0) uses Opc108 ----------
Opc108:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x0007
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  mov r2,r2,lsr #7
  orr r2,r2,#0x20 ;@ A0-7
  ldr r11,[r7,r2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r11) into r1:
  mov r0,r11
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  ldrb r2,[r7,#0x45] ;@ Get X bit
  tst r2,#2
  addne r10,r10,#0x01000000 ;@ Add carry bit
;@ Add units into r2:
  mov r1,r1,lsr#24
  mov r10,r10,lsr#24
  and r2,r1, #0x0f
  and r0,r10,#0x0f
  add r2,r2,r0
  cmp r2,#0x09
  addgt r2,r2,#0x06 ;@ Decimal adjust units
  and r1,r1,#0xF0
  and r10,r10,#0xF0
  add r1,r1,r10 ;@ Add BCD
  add r1,r1,r2
  bic r9,r9,#(1<<29)|(1<<31)  ;@ clear szc
  cmp r1,#0x99
  subgt r1,r1,#0xa0
  orrgt r9,r9,#1<<29
  mov r1,r1,lsl#24
  adds r1,r1,#0      ;@ define sz
  orrmi r9,r9,#1<<31 ;@ set S flag
  bicne r9,r9,#1<<30 ;@ set Z flag
  mov r2,r9,lsr#28
  strb r2,[r7,#0x45] ;@ set X flag

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c110] and.b d0, (a0) uses Opc110 ----------
Opc110:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c118] and.b d0, (a0)+ uses Opc118 ----------
Opc118:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c11f] and.b d0, (a7)+ uses Opc11f ----------
Opc11f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c120] and.b d0, -(a0) uses Opc120 ----------
Opc120:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c127] and.b d0, -(a7) uses Opc127 ----------
Opc127:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c128] and.b d0, ($3333,a0) uses Opc128 ----------
Opc128:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c130] and.b d0, ($33,a0,d3.w*2) uses Opc130 ----------
Opc130:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c138] and.b d0, $3333.w uses Opc138 ----------
Opc138:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c139] and.b d0, $33333333.l uses Opc139 ----------
Opc139:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c13a] and.b d0, ($3333,pc); =3335 uses Opc13a ----------
Opc13a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c13b] and.b d0, ($33,pc,d3.w*2); =35 uses Opc13b ----------
Opc13b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c140] exg d0, d0 uses Opc140 ----------
Opc140:
  and r10,r8,#0x0e00 ;@ Find T register
  and r11,r8,#0x000f ;@ Find S register

  ldr r0,[r7,r10,lsr #7] ;@ Get T
  ldr r1,[r7,r11,lsl #2] ;@ Get S

  str r0,[r7,r11,lsl #2] ;@ T->S
  str r1,[r7,r10,lsr #7] ;@ S->T

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c148] exg a0, a0 uses Opc148 ----------
Opc148:
  and r10,r8,#0x0e00 ;@ Find T register
  and r11,r8,#0x000f ;@ Find S register
  orr r10,r10,#0x1000 ;@ T is an address register

  ldr r0,[r7,r10,lsr #7] ;@ Get T
  ldr r1,[r7,r11,lsl #2] ;@ Get S

  str r0,[r7,r11,lsl #2] ;@ T->S
  str r1,[r7,r10,lsr #7] ;@ S->T

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c150] and.w d0, (a0) uses Opc150 ----------
Opc150:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c158] and.w d0, (a0)+ uses Opc158 ----------
Opc158:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c15f] and.w d0, (a7)+ uses Opc15f ----------
Opc15f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c160] and.w d0, -(a0) uses Opc160 ----------
Opc160:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c167] and.w d0, -(a7) uses Opc167 ----------
Opc167:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c168] and.w d0, ($3333,a0) uses Opc168 ----------
Opc168:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c170] and.w d0, ($33,a0,d3.w*2) uses Opc170 ----------
Opc170:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c178] and.w d0, $3333.w uses Opc178 ----------
Opc178:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c179] and.w d0, $33333333.l uses Opc179 ----------
Opc179:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c17a] and.w d0, ($3333,pc); =3335 uses Opc17a ----------
Opc17a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c17b] and.w d0, ($33,pc,d3.w*2); =35 uses Opc17b ----------
Opc17b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c188] exg a0, d0 uses Opc188 ----------
Opc188:
  and r10,r8,#0x0e00 ;@ Find T register
  and r11,r8,#0x000f ;@ Find S register

  ldr r0,[r7,r10,lsr #7] ;@ Get T
  ldr r1,[r7,r11,lsl #2] ;@ Get S

  str r0,[r7,r11,lsl #2] ;@ T->S
  str r1,[r7,r10,lsr #7] ;@ S->T

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c190] and.l d0, (a0) uses Opc190 ----------
Opc190:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c198] and.l d0, (a0)+ uses Opc198 ----------
Opc198:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c19f] and.l d0, (a7)+ uses Opc19f ----------
Opc19f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1a0] and.l d0, -(a0) uses Opc1a0 ----------
Opc1a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1a7] and.l d0, -(a7) uses Opc1a7 ----------
Opc1a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1a8] and.l d0, ($3333,a0) uses Opc1a8 ----------
Opc1a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1b0] and.l d0, ($33,a0,d3.w*2) uses Opc1b0 ----------
Opc1b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1b8] and.l d0, $3333.w uses Opc1b8 ----------
Opc1b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1b9] and.l d0, $33333333.l uses Opc1b9 ----------
Opc1b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1ba] and.l d0, ($3333,pc); =3335 uses Opc1ba ----------
Opc1ba:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1bb] and.l d0, ($33,pc,d3.w*2); =35 uses Opc1bb ----------
Opc1bb:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  and  r1,r11,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1c0] muls.w d0, d0 uses Opc1c0 ----------
Opc1c0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r10:
  ldrsh r10,[r7,r10]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec1c0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#70 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1d0] muls.w (a0), d0 uses Opc1d0 ----------
Opc1d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec1d0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#74 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1d8] muls.w (a0)+, d0 uses Opc1d8 ----------
Opc1d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec1d8WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#74 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1df] muls.w (a7)+, d0 uses Opc1df ----------
Opc1df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec1dfWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#74 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1e0] muls.w -(a0), d0 uses Opc1e0 ----------
Opc1e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec1e0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#76 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1e7] muls.w -(a7), d0 uses Opc1e7 ----------
Opc1e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec1e7WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#76 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1e8] muls.w ($3333,a0), d0 uses Opc1e8 ----------
Opc1e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec1e8WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#78 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1f0] muls.w ($33,a0,d3.w*2), d0 uses Opc1f0 ----------
Opc1f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec1f0WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#80 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1f8] muls.w $3333.w, d0 uses Opc1f8 ----------
Opc1f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec1f8WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#78 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1f9] muls.w $33333333.l, d0 uses Opc1f9 ----------
Opc1f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec1f9WriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#82 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1fa] muls.w ($3333,pc), d0; =3335 uses Opc1fa ----------
Opc1fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec1faWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#78 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1fb] muls.w ($33,pc,d3.w*2), d0; =35 uses Opc1fb ----------
Opc1fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r10:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec1fbWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#80 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1fc] muls.w #$3333, d0 uses Opc1fc ----------
Opc1fc:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r2:
  ldr r2,[r7,r0,lsl #2]

;@ Get 16-bit signs right:
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r10
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

Dividec1fcWriteVal:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#74 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d000] add.b d0, d0 uses Opd000 ----------
Opd000:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r11:
  ldrsb r11,[r7,r10]
  mov r11,r11,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d010] add.b (a0), d0 uses Opd010 ----------
Opd010:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d018] add.b (a0)+, d0 uses Opd018 ----------
Opd018:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d01f] add.b (a7)+, d0 uses Opd01f ----------
Opd01f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d020] add.b -(a0), d0 uses Opd020 ----------
Opd020:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d027] add.b -(a7), d0 uses Opd027 ----------
Opd027:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d028] add.b ($3333,a0), d0 uses Opd028 ----------
Opd028:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d030] add.b ($33,a0,d3.w*2), d0 uses Opd030 ----------
Opd030:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d038] add.b $3333.w, d0 uses Opd038 ----------
Opd038:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d039] add.b $33333333.l, d0 uses Opd039 ----------
Opd039:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03a] add.b ($3333,pc), d0; =3335 uses Opd03a ----------
Opd03a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03b] add.b ($33,pc,d3.w*2), d0; =35 uses Opd03b ----------
Opd03b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03c] add.b #$33, d0 uses Opd03c ----------
Opd03c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r11:
  mov r11,r10,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03d] add.b ea=(111 101), d0 uses Opd03d ----------
Opd03d:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 101)' into r10:
;@ EaRead : Read 'ea=(111 101)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03e] add.b ea=(111 110), d0 uses Opd03e ----------
Opd03e:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 110)' into r10:
;@ EaRead : Read 'ea=(111 110)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03f] add.b ea=(111 111), d0 uses Opd03f ----------
Opd03f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 111)' into r10:
;@ EaRead : Read 'ea=(111 111)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d040] add.w d0, d0 uses Opd040 ----------
Opd040:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r11:
  ldrsh r11,[r7,r10]
  mov r11,r11,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d050] add.w (a0), d0 uses Opd050 ----------
Opd050:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d058] add.w (a0)+, d0 uses Opd058 ----------
Opd058:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d05f] add.w (a7)+, d0 uses Opd05f ----------
Opd05f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d060] add.w -(a0), d0 uses Opd060 ----------
Opd060:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d067] add.w -(a7), d0 uses Opd067 ----------
Opd067:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d068] add.w ($3333,a0), d0 uses Opd068 ----------
Opd068:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d070] add.w ($33,a0,d3.w*2), d0 uses Opd070 ----------
Opd070:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d078] add.w $3333.w, d0 uses Opd078 ----------
Opd078:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d079] add.w $33333333.l, d0 uses Opd079 ----------
Opd079:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07a] add.w ($3333,pc), d0; =3335 uses Opd07a ----------
Opd07a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07b] add.w ($33,pc,d3.w*2), d0; =35 uses Opd07b ----------
Opd07b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07c] add.w #$3333, d0 uses Opd07c ----------
Opd07c:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r11:
  mov r11,r10,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07d] add.w ea=(111 101), d0 uses Opd07d ----------
Opd07d:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 101)' into r10:
;@ EaRead : Read 'ea=(111 101)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07e] add.w ea=(111 110), d0 uses Opd07e ----------
Opd07e:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 110)' into r10:
;@ EaRead : Read 'ea=(111 110)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07f] add.w ea=(111 111), d0 uses Opd07f ----------
Opd07f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 111)' into r10:
;@ EaRead : Read 'ea=(111 111)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d080] add.l d0, d0 uses Opd080 ----------
Opd080:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsl #2]

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d090] add.l (a0), d0 uses Opd090 ----------
Opd090:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d098] add.l (a0)+, d0 uses Opd098 ----------
Opd098:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d09f] add.l (a7)+, d0 uses Opd09f ----------
Opd09f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0a0] add.l -(a0), d0 uses Opd0a0 ----------
Opd0a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0a7] add.l -(a7), d0 uses Opd0a7 ----------
Opd0a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0a8] add.l ($3333,a0), d0 uses Opd0a8 ----------
Opd0a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0b0] add.l ($33,a0,d3.w*2), d0 uses Opd0b0 ----------
Opd0b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0b8] add.l $3333.w, d0 uses Opd0b8 ----------
Opd0b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0b9] add.l $33333333.l, d0 uses Opd0b9 ----------
Opd0b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0ba] add.l ($3333,pc), d0; =3335 uses Opd0ba ----------
Opd0ba:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0bb] add.l ($33,pc,d3.w*2), d0; =35 uses Opd0bb ----------
Opd0bb:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0bc] add.l #$33333333, d0 uses Opd0bc ----------
Opd0bc:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r11:
  mov r11,r10,asl #0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0bd] add.l ea=(111 101), d0 uses Opd0bd ----------
Opd0bd:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 101)' into r10:
;@ EaRead : Read 'ea=(111 101)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0be] add.l ea=(111 110), d0 uses Opd0be ----------
Opd0be:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 110)' into r10:
;@ EaRead : Read 'ea=(111 110)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0bf] add.l ea=(111 111), d0 uses Opd0bf ----------
Opd0bf:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get 'ea=(111 111)' into r10:
;@ EaRead : Read 'ea=(111 111)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r1,r11
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0c0] adda.w d0, a0 uses Opd0c0 ----------
Opd0c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r10:
  ldrsh r10,[r7,r0]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0d0] adda.w (a0), a0 uses Opd0d0 ----------
Opd0d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0d8] adda.w (a0)+, a0 uses Opd0d8 ----------
Opd0d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0df] adda.w (a7)+, a0 uses Opd0df ----------
Opd0df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0e0] adda.w -(a0), a0 uses Opd0e0 ----------
Opd0e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0e7] adda.w -(a7), a0 uses Opd0e7 ----------
Opd0e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0e8] adda.w ($3333,a0), a0 uses Opd0e8 ----------
Opd0e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0f0] adda.w ($33,a0,d3.w*2), a0 uses Opd0f0 ----------
Opd0f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0f8] adda.w $3333.w, a0 uses Opd0f8 ----------
Opd0f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0f9] adda.w $33333333.l, a0 uses Opd0f9 ----------
Opd0f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0fa] adda.w ($3333,pc), a0; =3335 uses Opd0fa ----------
Opd0fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0fb] adda.w ($33,pc,d3.w*2), a0; =35 uses Opd0fb ----------
Opd0fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r10,r0,asl #16
  mov r10,r10,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0fc] adda.w #$3333, a0 uses Opd0fc ----------
Opd0fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r10:
  mov r10,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d100] addx.b d0, d0 uses Opd100 ----------
Opd100:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r11:
  ldrsb r11,[r7,r0]
  mov r11,r11,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
;@ But only if carry bit set!:
  ldrcs r2,=0x00ffffff
  orrcs r11,r11,r2

  adcs r1,r1,r11
  mov r2,r9
  mrs r9,cpsr ;@ r9=flags
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #24
  strb r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

  .ltorg

;@ ---------- [d110] add.b d0, (a0) uses Opd110 ----------
Opd110:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d118] add.b d0, (a0)+ uses Opd118 ----------
Opd118:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d11f] add.b d0, (a7)+ uses Opd11f ----------
Opd11f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d120] add.b d0, -(a0) uses Opd120 ----------
Opd120:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d127] add.b d0, -(a7) uses Opd127 ----------
Opd127:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d128] add.b d0, ($3333,a0) uses Opd128 ----------
Opd128:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d130] add.b d0, ($33,a0,d3.w*2) uses Opd130 ----------
Opd130:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d138] add.b d0, $3333.w uses Opd138 ----------
Opd138:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d139] add.b d0, $33333333.l uses Opd139 ----------
Opd139:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x68] ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d13a] add.b d0, ($3333,pc); =3335 uses Opd13a ----------
Opd13a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d13b] add.b d0, ($33,pc,d3.w*2); =35 uses Opd13b ----------
Opd13b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x80] ;@ Call fetch8(r0) handler
  mov r11,r0,asl #24

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsb r1,[r7,r0]
  mov r1,r1,asl #24

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #24
  mov lr,pc
  ldr pc,[r7,#0x74] ;@ Call write8(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d140] addx.w d0, d0 uses Opd140 ----------
Opd140:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r11:
  ldrsh r11,[r7,r0]
  mov r11,r11,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
;@ But only if carry bit set!:
  ldrcs r2,=0x0000ffff
  orrcs r11,r11,r2

  adcs r1,r1,r11
  mov r2,r9
  mrs r9,cpsr ;@ r9=flags
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,asr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

  .ltorg

;@ ---------- [d150] add.w d0, (a0) uses Opd150 ----------
Opd150:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d158] add.w d0, (a0)+ uses Opd158 ----------
Opd158:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d15f] add.w d0, (a7)+ uses Opd15f ----------
Opd15f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d160] add.w d0, -(a0) uses Opd160 ----------
Opd160:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d167] add.w d0, -(a7) uses Opd167 ----------
Opd167:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d168] add.w d0, ($3333,a0) uses Opd168 ----------
Opd168:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d170] add.w d0, ($33,a0,d3.w*2) uses Opd170 ----------
Opd170:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d178] add.w d0, $3333.w uses Opd178 ----------
Opd178:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d179] add.w d0, $33333333.l uses Opd179 ----------
Opd179:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d17a] add.w d0, ($3333,pc); =3335 uses Opd17a ----------
Opd17a:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d17b] add.w d0, ($33,pc,d3.w*2); =35 uses Opd17b ----------
Opd17b:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r11,r0,asl #16

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaRead : Read register[r0] into r1:
  ldrsh r1,[r7,r0]
  mov r1,r1,asl #16

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d180] addx.l d0, d0 uses Opd180 ----------
Opd180:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r11:
  ldr r11,[r7,r0,lsl #2]

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
;@ Get X bit:
  ldrb r2,[r7,#0x45]
  mov r2,r2,lsl #28
  msr cpsr_flg,r2 ;@ Get into Carry

  adcs r1,r1,r11
  mov r2,r9
  mrs r9,cpsr ;@ r9=flags
  tst r9,#0x40000000 ;@ the Z flag problem
  tstne r2,#0x40000000
  biceq r9,r9,#0x40000000
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d190] add.l d0, (a0) uses Opd190 ----------
Opd190:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d198] add.l d0, (a0)+ uses Opd198 ----------
Opd198:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d19f] add.l d0, (a7)+ uses Opd19f ----------
Opd19f:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1a0] add.l d0, -(a0) uses Opd1a0 ----------
Opd1a0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1a7] add.l d0, -(a7) uses Opd1a7 ----------
Opd1a7:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1a8] add.l d0, ($3333,a0) uses Opd1a8 ----------
Opd1a8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1b0] add.l d0, ($33,a0,d3.w*2) uses Opd1b0 ----------
Opd1b0:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1b8] add.l d0, $3333.w uses Opd1b8 ----------
Opd1b8:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1b9] add.l d0, $33333333.l uses Opd1b9 ----------
Opd1b9:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1ba] add.l d0, ($3333,pc); =3335 uses Opd1ba ----------
Opd1ba:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1bb] add.l d0, ($33,pc,d3.w*2); =35 uses Opd1bb ----------
Opd1bb:
;@ Get r10=EA r11=EA value
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r11:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r11,r0

;@ Get r0=Register r1=Register value
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

;@ Do arithmetic:
  adds r1,r11,r1
  mrs r9,cpsr ;@ r9=flags
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x7c] ;@ Call write32(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1c0] adda.l d0, a0 uses Opd1c0 ----------
Opd1c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r10:
  ldr r10,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1d0] adda.l (a0), a0 uses Opd1d0 ----------
Opd1d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
;@ EaRead : Read '(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1d8] adda.l (a0)+, a0 uses Opd1d8 ----------
Opd1d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1df] adda.l (a7)+, a0 uses Opd1df ----------
Opd1df:
;@ EaCalc : Get '(a7)+' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r0,[r7,r2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1e0] adda.l -(a0), a0 uses Opd1e0 ----------
Opd1e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1e7] adda.l -(a7), a0 uses Opd1e7 ----------
Opd1e7:
;@ EaCalc : Get '-(a7)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r0,[r7,r2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1e8] adda.l ($3333,a0), a0 uses Opd1e8 ----------
Opd1e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1f0] adda.l ($33,a0,d3.w*2), a0 uses Opd1f0 ----------
Opd1f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1f8] adda.l $3333.w, a0 uses Opd1f8 ----------
Opd1f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1f9] adda.l $33333333.l, a0 uses Opd1f9 ----------
Opd1f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x70] ;@ Call read32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1fa] adda.l ($3333,pc), a0; =3335 uses Opd1fa ----------
Opd1fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1fb] adda.l ($33,pc,d3.w*2), a0; =35 uses Opd1fb ----------
Opd1fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r10:
  mov lr,pc
  ldr pc,[r7,#0x88] ;@ Call fetch32(r0) handler
  mov r10,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1fc] adda.l #$33333333, a0 uses Opd1fc ----------
Opd1fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r10:
  mov r10,r0,asl #0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #9
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r1:
  ldr r1,[r7,r0,lsl #2]

  add r1,r1,r10

;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e000] asr.b #8, d0 uses Ope000 ----------
Ope000:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #24

;@ Shift register and set carry flag:
  movs r0,r0,asr #8
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #24
  orreq r9,r9,#1<<30


;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e008] lsr.b #8, d0 uses Ope008 ----------
Ope008:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr #8
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #24
  orreq r9,r9,#1<<30

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e010] roxr.b #8, d0 uses Ope010 ----------
Ope010:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

;@ Rotate register through X:
  mov r2,#8
  mov r0,r0,lsr #24 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#9
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e010:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e018] ror.b #8, d0 uses Ope018 ----------
Ope018:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #8
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e020] asr.b d0, d0 uses Ope020 ----------
Ope020:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #24

;@ Shift register and set carry flag:
  movs r0,r0,asr r2
  mrs r9,cpsr
  tst r2,r2
  biceq r9,r9,#1<<29
  beq Ope020skipVflag
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
Ope020skipVflag:
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #24
  orreq r9,r9,#1<<30


;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e028] lsr.b d0, d0 uses Ope028 ----------
Ope028:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr
  bic r9,r9,#1<<28
  tst r2,r2
  biceq r9,r9,#1<<29
  movne r2,r9,lsr #28
  strneb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #24
  orreq r9,r9,#1<<30

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e030] roxr.b d0, d0 uses Ope030 ----------
Ope030:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
  tst r2,r2
  bne ShiftOK_e030
  adds r0,r0,#0
  mrs r9,cpsr
  ldrb r2,[r7,#0x45]
  and r2,r2,#2
  orr r9,r9,r2,lsl#28
  b Exit_e030
ShiftOK_e030:
;@ Reduce r2 until <0:
Reduce_e030:
  subs r2,r2,#9
  bpl Reduce_e030
  add r2,r2,#9 ;@ Now r2=0-8

  mov r0,r0,lsr #24 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#9
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e030:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e038] ror.b d0, d0 uses Ope038 ----------
Ope038:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  and r2,r2,#31
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
;@ Have to test shift count:
;@ because shift of 0 will not update Carry flag:
  tst r2,r2
  biceq r9,r9,#(1<<29)

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e040] asr.w #8, d0 uses Ope040 ----------
Ope040:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr #8
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e048] lsr.w #8, d0 uses Ope048 ----------
Ope048:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #8
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e050] roxr.w #8, d0 uses Ope050 ----------
Ope050:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#8
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e050:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e058] ror.w #8, d0 uses Ope058 ----------
Ope058:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #8
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e060] asr.w d0, d0 uses Ope060 ----------
Ope060:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr r2
  mrs r9,cpsr
  tst r2,r2
  biceq r9,r9,#1<<29
  beq Ope060skipVflag
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
Ope060skipVflag:
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e068] lsr.w d0, d0 uses Ope068 ----------
Ope068:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr
  bic r9,r9,#1<<28
  tst r2,r2
  biceq r9,r9,#1<<29
  movne r2,r9,lsr #28
  strneb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e070] roxr.w d0, d0 uses Ope070 ----------
Ope070:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
  tst r2,r2
  bne ShiftOK_e070
  adds r0,r0,#0
  mrs r9,cpsr
  ldrb r2,[r7,#0x45]
  and r2,r2,#2
  orr r9,r9,r2,lsl#28
  b Exit_e070
ShiftOK_e070:
;@ Reduce r2 until <0:
Reduce_e070:
  subs r2,r2,#17
  bpl Reduce_e070
  add r2,r2,#17 ;@ Now r2=0-16

  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e070:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e078] ror.w d0, d0 uses Ope078 ----------
Ope078:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  and r2,r2,#31
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
;@ Have to test shift count:
;@ because shift of 0 will not update Carry flag:
  tst r2,r2
  biceq r9,r9,#(1<<29)

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e080] asr.l #8, d0 uses Ope080 ----------
Ope080:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Shift register and set carry flag:
  movs r0,r0,asr #8
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e088] lsr.l #8, d0 uses Ope088 ----------
Ope088:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Shift register:
  movs r0,r0,lsr #8
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e090] roxr.l #8, d0 uses Ope090 ----------
Ope090:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Rotate register through X:
  mov r2,#8
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#33
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e090:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e098] ror.l #8, d0 uses Ope098 ----------
Ope098:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Rotate register:
  movs r0,r0,ror #8
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0a0] asr.l d0, d0 uses Ope0a0 ----------
Ope0a0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register and set carry flag:
  movs r0,r0,asr r2
  mrs r9,cpsr
  tst r2,r2
  biceq r9,r9,#1<<29
  beq Ope0a0skipVflag
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
Ope0a0skipVflag:
  bic r9,r9,#1<<28

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0a8] lsr.l d0, d0 uses Ope0a8 ----------
Ope0a8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr
  bic r9,r9,#1<<28
  tst r2,r2
  biceq r9,r9,#1<<29
  movne r2,r9,lsr #28
  strneb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0b0] roxr.l d0, d0 uses Ope0b0 ----------
Ope0b0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
  tst r2,r2
  bne ShiftOK_e0b0
  adds r0,r0,#0
  mrs r9,cpsr
  ldrb r2,[r7,#0x45]
  and r2,r2,#2
  orr r9,r9,r2,lsl#28
  b Exit_e0b0
ShiftOK_e0b0:
;@ Reduce r2 until <0:
Reduce_e0b0:
  subs r2,r2,#33
  bpl Reduce_e0b0
  add r2,r2,#33 ;@ Now r2=0-32

;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#33
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e0b0:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0b8] ror.l d0, d0 uses Ope0b8 ----------
Ope0b8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  and r2,r2,#31
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
;@ Have to test shift count:
;@ because shift of 0 will not update Carry flag:
  tst r2,r2
  biceq r9,r9,#(1<<29)

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0d0] asr.w (a0) uses Ope0d0 ----------
Ope0d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0d8] asr.w (a0)+ uses Ope0d8 ----------
Ope0d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0df] asr.w (a7)+ uses Ope0df ----------
Ope0df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0e0] asr.w -(a0) uses Ope0e0 ----------
Ope0e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0e7] asr.w -(a7) uses Ope0e7 ----------
Ope0e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0e8] asr.w ($3333,a0) uses Ope0e8 ----------
Ope0e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0f0] asr.w ($33,a0,d3.w*2) uses Ope0f0 ----------
Ope0f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0f8] asr.w $3333.w uses Ope0f8 ----------
Ope0f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0f9] asr.w $33333333.l uses Ope0f9 ----------
Ope0f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0fa] asr.w ($3333,pc); =3335 uses Ope0fa ----------
Ope0fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0fb] asr.w ($33,pc,d3.w*2); =35 uses Ope0fb ----------
Ope0fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e100] asl.b #8, d0 uses Ope100 ----------
Ope100:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #8
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #8
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e108] lsl.b #8, d0 uses Ope108 ----------
Ope108:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e110] roxl.b #8, d0 uses Ope110 ----------
Ope110:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

;@ Rotate register through X:
  mov r2,#8
  mov r0,r0,lsr #24 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#9
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#9
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e110:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e118] rol.b #8, d0 uses Ope118 ----------
Ope118:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

;@ Rotate register through X:
  mov r2,#8
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#8
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e118:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e120] asl.b d0, d0 uses Ope120 ----------
Ope120:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr
  tst r2,r2
  biceq r9,r9,#1<<29
  beq Ope120skipVflag
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr r2
  ands r1,lr,r1
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28
Ope120skipVflag:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e128] lsl.b d0, d0 uses Ope128 ----------
Ope128:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr
  bic r9,r9,#1<<28
  tst r2,r2
  biceq r9,r9,#1<<29
  movne r2,r9,lsr #28
  strneb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e130] roxl.b d0, d0 uses Ope130 ----------
Ope130:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
  tst r2,r2
  bne ShiftOK_e130
  adds r0,r0,#0
  mrs r9,cpsr
  ldrb r2,[r7,#0x45]
  and r2,r2,#2
  orr r9,r9,r2,lsl#28
  b Exit_e130
ShiftOK_e130:
;@ Reduce r2 until <0:
Reduce_e130:
  subs r2,r2,#9
  bpl Reduce_e130
  add r2,r2,#9 ;@ Now r2=0-8

  mov r0,r0,lsr #24 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#9
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#9
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e130:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e138] rol.b d0, d0 uses Ope138 ----------
Ope138:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
  tst r2,r2
  bne ShiftOK_e138
  adds r0,r0,#0
  mrs r9,cpsr
  b Exit_e138
ShiftOK_e138:
;@ Reduce r2 until <0:
Reduce_e138:
  subs r2,r2,#8
  bpl Reduce_e138
  add r2,r2,#8 ;@ Now r2=0-8

;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#8
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e138:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e140] asl.w #8, d0 uses Ope140 ----------
Ope140:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #8
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #8
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e148] lsl.w #8, d0 uses Ope148 ----------
Ope148:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e150] roxl.w #8, d0 uses Ope150 ----------
Ope150:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#8
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e150:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e158] rol.w #8, d0 uses Ope158 ----------
Ope158:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#8
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e158:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e160] asl.w d0, d0 uses Ope160 ----------
Ope160:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr
  tst r2,r2
  biceq r9,r9,#1<<29
  beq Ope160skipVflag
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr r2
  ands r1,lr,r1
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28
Ope160skipVflag:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e168] lsl.w d0, d0 uses Ope168 ----------
Ope168:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr
  bic r9,r9,#1<<28
  tst r2,r2
  biceq r9,r9,#1<<29
  movne r2,r9,lsr #28
  strneb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e170] roxl.w d0, d0 uses Ope170 ----------
Ope170:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
  tst r2,r2
  bne ShiftOK_e170
  adds r0,r0,#0
  mrs r9,cpsr
  ldrb r2,[r7,#0x45]
  and r2,r2,#2
  orr r9,r9,r2,lsl#28
  b Exit_e170
ShiftOK_e170:
;@ Reduce r2 until <0:
Reduce_e170:
  subs r2,r2,#17
  bpl Reduce_e170
  add r2,r2,#17 ;@ Now r2=0-16

  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e170:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e178] rol.w d0, d0 uses Ope178 ----------
Ope178:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
  tst r2,r2
  bne ShiftOK_e178
  adds r0,r0,#0
  mrs r9,cpsr
  b Exit_e178
ShiftOK_e178:
;@ Reduce r2 until <0:
Reduce_e178:
  subs r2,r2,#16
  bpl Reduce_e178
  add r2,r2,#16 ;@ Now r2=0-16

;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e178:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e180] asl.l #8, d0 uses Ope180 ----------
Ope180:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #8
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #8
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e188] lsl.l #8, d0 uses Ope188 ----------
Ope188:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e190] roxl.l #8, d0 uses Ope190 ----------
Ope190:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Rotate register through X:
  mov r2,#8
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#33
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#33
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e190:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e198] rol.l #8, d0 uses Ope198 ----------
Ope198:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Rotate register through X:
  mov r2,#8
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#32
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e198:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1a0] asl.l d0, d0 uses Ope1a0 ----------
Ope1a0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr
  tst r2,r2
  biceq r9,r9,#1<<29
  beq Ope1a0skipVflag
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr r2
  ands r1,lr,r1
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28
Ope1a0skipVflag:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1a8] lsl.l d0, d0 uses Ope1a8 ----------
Ope1a8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr
  bic r9,r9,#1<<28
  tst r2,r2
  biceq r9,r9,#1<<29
  movne r2,r9,lsr #28
  strneb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1b0] roxl.l d0, d0 uses Ope1b0 ----------
Ope1b0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
  tst r2,r2
  bne ShiftOK_e1b0
  adds r0,r0,#0
  mrs r9,cpsr
  ldrb r2,[r7,#0x45]
  and r2,r2,#2
  orr r9,r9,r2,lsl#28
  b Exit_e1b0
ShiftOK_e1b0:
;@ Reduce r2 until <0:
Reduce_e1b0:
  subs r2,r2,#33
  bpl Reduce_e1b0
  add r2,r2,#33 ;@ Now r2=0-32

;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#33
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#33
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e1b0:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1b8] rol.l d0, d0 uses Ope1b8 ----------
Ope1b8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

;@ Use Dn for count:
  ldr r2,[r7,r2,lsl #2]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
  tst r2,r2
  bne ShiftOK_e1b8
  adds r0,r0,#0
  mrs r9,cpsr
  b Exit_e1b8
ShiftOK_e1b8:
;@ Reduce r2 until <0:
Reduce_e1b8:
  subs r2,r2,#32
  bpl Reduce_e1b8
  add r2,r2,#32 ;@ Now r2=0-32

;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#32
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e1b8:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1d0] asl.w (a0) uses Ope1d0 ----------
Ope1d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #1
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1d8] asl.w (a0)+ uses Ope1d8 ----------
Ope1d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #1
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1df] asl.w (a7)+ uses Ope1df ----------
Ope1df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #1
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1e0] asl.w -(a0) uses Ope1e0 ----------
Ope1e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #1
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1e7] asl.w -(a7) uses Ope1e7 ----------
Ope1e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #1
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1e8] asl.w ($3333,a0) uses Ope1e8 ----------
Ope1e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #1
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1f0] asl.w ($33,a0,d3.w*2) uses Ope1f0 ----------
Ope1f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #1
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1f8] asl.w $3333.w uses Ope1f8 ----------
Ope1f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #1
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1f9] asl.w $33333333.l uses Ope1f9 ----------
Ope1f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #1
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1fa] asl.w ($3333,pc); =3335 uses Ope1fa ----------
Ope1fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #1
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1fb] asl.w ($33,pc,d3.w*2); =35 uses Ope1fb ----------
Ope1fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr #1
  ands r1,r1,lr
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2d0] lsr.w (a0) uses Ope2d0 ----------
Ope2d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2d8] lsr.w (a0)+ uses Ope2d8 ----------
Ope2d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2df] lsr.w (a7)+ uses Ope2df ----------
Ope2df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2e0] lsr.w -(a0) uses Ope2e0 ----------
Ope2e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2e7] lsr.w -(a7) uses Ope2e7 ----------
Ope2e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2e8] lsr.w ($3333,a0) uses Ope2e8 ----------
Ope2e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2f0] lsr.w ($33,a0,d3.w*2) uses Ope2f0 ----------
Ope2f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2f8] lsr.w $3333.w uses Ope2f8 ----------
Ope2f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2f9] lsr.w $33333333.l uses Ope2f9 ----------
Ope2f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2fa] lsr.w ($3333,pc); =3335 uses Ope2fa ----------
Ope2fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2fb] lsr.w ($33,pc,d3.w*2); =35 uses Ope2fb ----------
Ope2fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3d0] lsl.w (a0) uses Ope3d0 ----------
Ope3d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3d8] lsl.w (a0)+ uses Ope3d8 ----------
Ope3d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3df] lsl.w (a7)+ uses Ope3df ----------
Ope3df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3e0] lsl.w -(a0) uses Ope3e0 ----------
Ope3e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3e7] lsl.w -(a7) uses Ope3e7 ----------
Ope3e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3e8] lsl.w ($3333,a0) uses Ope3e8 ----------
Ope3e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3f0] lsl.w ($33,a0,d3.w*2) uses Ope3f0 ----------
Ope3f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3f8] lsl.w $3333.w uses Ope3f8 ----------
Ope3f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3f9] lsl.w $33333333.l uses Ope3f9 ----------
Ope3f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3fa] lsl.w ($3333,pc); =3335 uses Ope3fa ----------
Ope3fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3fb] lsl.w ($33,pc,d3.w*2); =35 uses Ope3fb ----------
Ope3fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4d0] roxr.w (a0) uses Ope4d0 ----------
Ope4d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e4d0:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4d8] roxr.w (a0)+ uses Ope4d8 ----------
Ope4d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e4d8:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4df] roxr.w (a7)+ uses Ope4df ----------
Ope4df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e4df:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4e0] roxr.w -(a0) uses Ope4e0 ----------
Ope4e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e4e0:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4e7] roxr.w -(a7) uses Ope4e7 ----------
Ope4e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e4e7:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4e8] roxr.w ($3333,a0) uses Ope4e8 ----------
Ope4e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e4e8:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4f0] roxr.w ($33,a0,d3.w*2) uses Ope4f0 ----------
Ope4f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e4f0:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4f8] roxr.w $3333.w uses Ope4f8 ----------
Ope4f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e4f8:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4f9] roxr.w $33333333.l uses Ope4f9 ----------
Ope4f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e4f9:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4fa] roxr.w ($3333,pc); =3335 uses Ope4fa ----------
Ope4fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e4fa:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4fb] roxr.w ($33,pc,d3.w*2); =35 uses Ope4fb ----------
Ope4fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e4fb:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5d0] roxl.w (a0) uses Ope5d0 ----------
Ope5d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e5d0:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5d8] roxl.w (a0)+ uses Ope5d8 ----------
Ope5d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e5d8:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5df] roxl.w (a7)+ uses Ope5df ----------
Ope5df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e5df:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5e0] roxl.w -(a0) uses Ope5e0 ----------
Ope5e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e5e0:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5e7] roxl.w -(a7) uses Ope5e7 ----------
Ope5e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e5e7:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5e8] roxl.w ($3333,a0) uses Ope5e8 ----------
Ope5e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e5e8:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5f0] roxl.w ($33,a0,d3.w*2) uses Ope5f0 ----------
Ope5f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e5f0:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5f8] roxl.w $3333.w uses Ope5f8 ----------
Ope5f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e5f8:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5f9] roxl.w $33333333.l uses Ope5f9 ----------
Ope5f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e5f9:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5fa] roxl.w ($3333,pc); =3335 uses Ope5fa ----------
Ope5fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e5fa:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5fb] roxl.w ($33,pc,d3.w*2); =35 uses Ope5fb ----------
Ope5fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_e5fb:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6d0] ror.w (a0) uses Ope6d0 ----------
Ope6d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6d8] ror.w (a0)+ uses Ope6d8 ----------
Ope6d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6df] ror.w (a7)+ uses Ope6df ----------
Ope6df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6e0] ror.w -(a0) uses Ope6e0 ----------
Ope6e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6e7] ror.w -(a7) uses Ope6e7 ----------
Ope6e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6e8] ror.w ($3333,a0) uses Ope6e8 ----------
Ope6e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6f0] ror.w ($33,a0,d3.w*2) uses Ope6f0 ----------
Ope6f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6f8] ror.w $3333.w uses Ope6f8 ----------
Ope6f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6f9] ror.w $33333333.l uses Ope6f9 ----------
Ope6f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6fa] ror.w ($3333,pc); =3335 uses Ope6fa ----------
Ope6fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6fb] ror.w ($33,pc,d3.w*2); =35 uses Ope6fb ----------
Ope6fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7d0] rol.w (a0) uses Ope7d0 ----------
Ope7d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e7d0:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7d8] rol.w (a0)+ uses Ope7d8 ----------
Ope7d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e7d8:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7df] rol.w (a7)+ uses Ope7df ----------
Ope7df:
;@ EaCalc : Get '(a7)+' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r10,[r7,r2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2]
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e7df:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7e0] rol.w -(a0) uses Ope7e0 ----------
Ope7e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e7e0:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7e7] rol.w -(a7) uses Ope7e7 ----------
Ope7e7:
;@ EaCalc : Get '-(a7)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r10,[r7,r2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2]
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e7e7:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7e8] rol.w ($3333,a0) uses Ope7e8 ----------
Ope7e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  ldr r2,[r7,r2]
  ldrsh r0,[r4],#2 ;@ Fetch offset
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e7e8:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7f0] rol.w ($33,a0,d3.w*2) uses Ope7f0 ----------
Ope7f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  mov r2,r2,lsl #2
  orr r2,r2,#0x20 ;@ A0-7
  ldr r2,[r7,r2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e7f0:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7f8] rol.w $3333.w uses Ope7f8 ----------
Ope7f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e7f8:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7f9] rol.w $33333333.l uses Ope7f9 ----------
Ope7f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x6c] ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e7f9:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7fa] rol.w ($3333,pc); =3335 uses Ope7fa ----------
Ope7fa:
;@ EaCalc : Get '($3333,pc)' into r10:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r10,r0,r2 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e7fa:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($3333,pc)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7fb] rol.w ($33,pc,d3.w*2); =35 uses Ope7fb ----------
Ope7fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4]
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  add r2,r2,r0,asr #24 ;@ r2=Disp+Rn
  ldr r0,[r7,#0x60] ;@ Get Memory base
  add r2,r2,r4 ;@ r2=Disp+Rn + Base+PC
  add r4,r4,#2 ;@ Increase PC
  sub r10,r2,r0 ;@ r10=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  mov lr,pc
  ldr pc,[r7,#0x84] ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16

;@ Rotate register through X:
  mov r2,#1
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_e7fb:

;@ Save shifted value back to EA:
  mov r1,r0
;@ EaWrite: Write r1 into '($33,pc,d3.w*2)' (address in r10):
  mov r0,r10
  mov r1,r1,asr #16
  mov lr,pc
  ldr pc,[r7,#0x78] ;@ Call write16(r0,r1) handler

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee00] asr.b #7, d0 uses Opee00 ----------
Opee00:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #24

;@ Shift register and set carry flag:
  movs r0,r0,asr r2
  mrs r9,cpsr
  tst r2,r2
  biceq r9,r9,#1<<29
  beq Opee00skipVflag
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
Opee00skipVflag:
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #24
  orreq r9,r9,#1<<30


;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee08] lsr.b #7, d0 uses Opee08 ----------
Opee08:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #24
  orreq r9,r9,#1<<30

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee10] roxr.b #7, d0 uses Opee10 ----------
Opee10:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
  mov r0,r0,lsr #24 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#9
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_ee10:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee18] ror.b #7, d0 uses Opee18 ----------
Opee18:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  and r2,r2,#31
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
;@ Have to test shift count:
;@ because shift of 0 will not update Carry flag:
  tst r2,r2
  biceq r9,r9,#(1<<29)

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee40] asr.w #7, d0 uses Opee40 ----------
Opee40:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register and set carry flag:
  movs r0,r0,asr r2
  mrs r9,cpsr
  tst r2,r2
  biceq r9,r9,#1<<29
  beq Opee40skipVflag
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
Opee40skipVflag:
  bic r9,r9,#1<<28
;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30


;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee48] lsr.w #7, d0 uses Opee48 ----------
Opee48:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, also copy to lowest bits (to get carry bit):
  orr r0,r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ Check if result is zero:
  movs r2,r0,lsr #16
  orreq r9,r9,#1<<30

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee50] roxr.w #7, d0 uses Opee50 ----------
Opee50:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#17
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  bic r9,r9,#(1<<28)|(1<<30)|(1<<31)
  orrmi r9,r9,#1<<31
  orreq r9,r9,#1<<30
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_ee50:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee58] ror.w #7, d0 uses Opee58 ----------
Opee58:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  and r2,r2,#31
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
;@ Have to test shift count:
;@ because shift of 0 will not update Carry flag:
  tst r2,r2
  biceq r9,r9,#(1<<29)

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee80] asr.l #7, d0 uses Opee80 ----------
Opee80:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register and set carry flag:
  movs r0,r0,asr r2
  mrs r9,cpsr
  tst r2,r2
  biceq r9,r9,#1<<29
  beq Opee80skipVflag
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
Opee80skipVflag:
  bic r9,r9,#1<<28

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee88] lsr.l #7, d0 uses Opee88 ----------
Opee88:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee90] roxr.l #7, d0 uses Opee90 ----------
Opee90:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
;@ Rotate bits:
  movs r3,r0,lsr r2 ;@ Get right part
  rsb r2,r2,#33
  mov r0,r0,lsl r2 ;@ Get left part
  orr r0,r3,r0 ;@ r0=Rotated value
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_ee90:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee98] ror.l #7, d0 uses Opee98 ----------
Opee98:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  and r2,r2,#31
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
;@ Have to test shift count:
;@ because shift of 0 will not update Carry flag:
  tst r2,r2
  biceq r9,r9,#(1<<29)

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef00] asl.b #7, d0 uses Opef00 ----------
Opef00:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr
  tst r2,r2
  biceq r9,r9,#1<<29
  beq Opef00skipVflag
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr r2
  ands r1,lr,r1
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28
Opef00skipVflag:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef08] lsl.b #7, d0 uses Opef08 ----------
Opef08:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef10] roxl.b #7, d0 uses Opef10 ----------
Opef10:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
  mov r0,r0,lsr #24 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#9
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#9
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_ef10:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef18] rol.b #7, d0 uses Opef18 ----------
Opef18:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsb r0,[r7,r10]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#8
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_ef18:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef40] asl.w #7, d0 uses Opef40 ----------
Opef40:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr
  tst r2,r2
  biceq r9,r9,#1<<29
  beq Opef40skipVflag
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr r2
  ands r1,lr,r1
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28
Opef40skipVflag:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef48] lsl.w #7, d0 uses Opef48 ----------
Opef48:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef50] roxl.w #7, d0 uses Opef50 ----------
Opef50:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
  mov r0,r0,lsr #16 ;@ Shift down
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#17
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#17
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr
  bic r9,r9,#(1<<28)
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_ef50:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef58] rol.w #7, d0 uses Opef58 ----------
Opef58:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldrsh r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#16
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_ef58:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef80] asl.l #7, d0 uses Opef80 ----------
Opef80:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift left original value required in order to calc Vflag:
  mov r1,r0
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr
  tst r2,r2
  biceq r9,r9,#1<<29
  beq Opef80skipVflag
  mov lr,r9,lsr #28
  strb lr,[r7,#0x45] ;@ Save X bit
  mov lr,#1<<31
  mov lr,lr,asr r2
  ands r1,lr,r1
  cmpne r1,lr
  orrne r9,r9,#1<<28
  biceq r9,r9,#1<<28
Opef80skipVflag:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef88] lsl.l #7, d0 uses Opef88 ----------
Opef88:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef90] roxl.l #7, d0 uses Opef90 ----------
Opef90:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#33
  mov r0,r0,lsr r2 ;@ Get right part
  orr r0,r3,r0 ;@ r0=Rotated value
  rsb r2,r2,#33
;@ Insert X bit into r2-1:
  ldrb r3,[r7,#0x45]
  sub r2,r2,#1
  and r3,r3,#2
  mov r3,r3,lsr #1
  mov r3,r3,lsl r2
  orrs r0,r0,r3

  mrs r9,cpsr
  bic r9,r9,#1<<28
  mov r2,r9,lsr #28
  strb r2,[r7,#0x45] ;@ Save X bit
Exit_ef90:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef98] rol.l #7, d0 uses Opef98 ----------
Opef98:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register through X:
;@ Rotate bits:
  movs r3,r0,lsl r2 ;@ Get left part
  rsb r2,r2,#32
  mov r0,r0,lsr r2 ;@ Get left part
  orrs r0,r3,r0 ;@ r0=Rotated value - defines NS, CV unaffected

  mrs r9,cpsr
  bic r9,r9,#(1<<28)
Exit_ef98:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrge pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ -------------------------- Jump Table --------------------------
JumpTab:
  .long Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000 ;@ 0000
  .long Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000 ;@ 0008
  .long Op0010,Op0010,Op0010,Op0010,Op0010,Op0010,Op0010,Op0010 ;@ 0010
  .long Op0018,Op0018,Op0018,Op0018,Op0018,Op0018,Op0018,Op001f ;@ 0018
  .long Op0020,Op0020,Op0020,Op0020,Op0020,Op0020,Op0020,Op0027 ;@ 0020
  .long Op0028,Op0028,Op0028,Op0028,Op0028,Op0028,Op0028,Op0028 ;@ 0028
  .long Op0030,Op0030,Op0030,Op0030,Op0030,Op0030,Op0030,Op0030 ;@ 0030
  .long Op0038,Op0039,Op003a,Op003b,Op003c,Op____,Op____,Op____ ;@ 0038
  .long Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040 ;@ 0040
  .long Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040 ;@ 0048
  .long Op0050,Op0050,Op0050,Op0050,Op0050,Op0050,Op0050,Op0050 ;@ 0050
  .long Op0058,Op0058,Op0058,Op0058,Op0058,Op0058,Op0058,Op005f ;@ 0058
  .long Op0060,Op0060,Op0060,Op0060,Op0060,Op0060,Op0060,Op0067 ;@ 0060
  .long Op0068,Op0068,Op0068,Op0068,Op0068,Op0068,Op0068,Op0068 ;@ 0068
  .long Op0070,Op0070,Op0070,Op0070,Op0070,Op0070,Op0070,Op0070 ;@ 0070
  .long Op0078,Op0079,Op007a,Op007b,Op007c,Op____,Op____,Op____ ;@ 0078
  .long Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080 ;@ 0080
  .long Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080 ;@ 0088
  .long Op0090,Op0090,Op0090,Op0090,Op0090,Op0090,Op0090,Op0090 ;@ 0090
  .long Op0098,Op0098,Op0098,Op0098,Op0098,Op0098,Op0098,Op009f ;@ 0098
  .long Op00a0,Op00a0,Op00a0,Op00a0,Op00a0,Op00a0,Op00a0,Op00a7 ;@ 00a0
  .long Op00a8,Op00a8,Op00a8,Op00a8,Op00a8,Op00a8,Op00a8,Op00a8 ;@ 00a8
  .long Op00b0,Op00b0,Op00b0,Op00b0,Op00b0,Op00b0,Op00b0,Op00b0 ;@ 00b0
  .long Op00b8,Op00b9,Op00ba,Op00bb,Op____,Op____,Op____,Op____ ;@ 00b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00f8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0100
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0108
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0110
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0118
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0120
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0128
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0130
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0138
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0140
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0148
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0150
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0158
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0160
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0168
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0170
  .long Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____ ;@ 0178
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0180
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0188
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0190
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0198
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 01a0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 01a8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 01b0
  .long Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____ ;@ 01b8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 01c0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 01c8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 01d0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 01d8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 01e0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 01e8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 01f0
  .long Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____ ;@ 01f8
  .long Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200 ;@ 0200
  .long Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200 ;@ 0208
  .long Op0210,Op0210,Op0210,Op0210,Op0210,Op0210,Op0210,Op0210 ;@ 0210
  .long Op0218,Op0218,Op0218,Op0218,Op0218,Op0218,Op0218,Op021f ;@ 0218
  .long Op0220,Op0220,Op0220,Op0220,Op0220,Op0220,Op0220,Op0227 ;@ 0220
  .long Op0228,Op0228,Op0228,Op0228,Op0228,Op0228,Op0228,Op0228 ;@ 0228
  .long Op0230,Op0230,Op0230,Op0230,Op0230,Op0230,Op0230,Op0230 ;@ 0230
  .long Op0238,Op0239,Op023a,Op023b,Op023c,Op____,Op____,Op____ ;@ 0238
  .long Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240 ;@ 0240
  .long Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240 ;@ 0248
  .long Op0250,Op0250,Op0250,Op0250,Op0250,Op0250,Op0250,Op0250 ;@ 0250
  .long Op0258,Op0258,Op0258,Op0258,Op0258,Op0258,Op0258,Op025f ;@ 0258
  .long Op0260,Op0260,Op0260,Op0260,Op0260,Op0260,Op0260,Op0267 ;@ 0260
  .long Op0268,Op0268,Op0268,Op0268,Op0268,Op0268,Op0268,Op0268 ;@ 0268
  .long Op0270,Op0270,Op0270,Op0270,Op0270,Op0270,Op0270,Op0270 ;@ 0270
  .long Op0278,Op0279,Op027a,Op027b,Op027c,Op____,Op____,Op____ ;@ 0278
  .long Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280 ;@ 0280
  .long Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280 ;@ 0288
  .long Op0290,Op0290,Op0290,Op0290,Op0290,Op0290,Op0290,Op0290 ;@ 0290
  .long Op0298,Op0298,Op0298,Op0298,Op0298,Op0298,Op0298,Op029f ;@ 0298
  .long Op02a0,Op02a0,Op02a0,Op02a0,Op02a0,Op02a0,Op02a0,Op02a7 ;@ 02a0
  .long Op02a8,Op02a8,Op02a8,Op02a8,Op02a8,Op02a8,Op02a8,Op02a8 ;@ 02a8
  .long Op02b0,Op02b0,Op02b0,Op02b0,Op02b0,Op02b0,Op02b0,Op02b0 ;@ 02b0
  .long Op02b8,Op02b9,Op02ba,Op02bb,Op____,Op____,Op____,Op____ ;@ 02b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02f8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0300
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0308
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0310
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0318
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0320
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0328
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0330
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0338
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0340
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0348
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0350
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0358
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0360
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0368
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0370
  .long Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____ ;@ 0378
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0380
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0388
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0390
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0398
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 03a0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 03a8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 03b0
  .long Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____ ;@ 03b8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 03c0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 03c8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 03d0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 03d8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 03e0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 03e8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 03f0
  .long Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____ ;@ 03f8
  .long Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400 ;@ 0400
  .long Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400 ;@ 0408
  .long Op0410,Op0410,Op0410,Op0410,Op0410,Op0410,Op0410,Op0410 ;@ 0410
  .long Op0418,Op0418,Op0418,Op0418,Op0418,Op0418,Op0418,Op041f ;@ 0418
  .long Op0420,Op0420,Op0420,Op0420,Op0420,Op0420,Op0420,Op0427 ;@ 0420
  .long Op0428,Op0428,Op0428,Op0428,Op0428,Op0428,Op0428,Op0428 ;@ 0428
  .long Op0430,Op0430,Op0430,Op0430,Op0430,Op0430,Op0430,Op0430 ;@ 0430
  .long Op0438,Op0439,Op043a,Op043b,Op____,Op____,Op____,Op____ ;@ 0438
  .long Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440 ;@ 0440
  .long Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440 ;@ 0448
  .long Op0450,Op0450,Op0450,Op0450,Op0450,Op0450,Op0450,Op0450 ;@ 0450
  .long Op0458,Op0458,Op0458,Op0458,Op0458,Op0458,Op0458,Op045f ;@ 0458
  .long Op0460,Op0460,Op0460,Op0460,Op0460,Op0460,Op0460,Op0467 ;@ 0460
  .long Op0468,Op0468,Op0468,Op0468,Op0468,Op0468,Op0468,Op0468 ;@ 0468
  .long Op0470,Op0470,Op0470,Op0470,Op0470,Op0470,Op0470,Op0470 ;@ 0470
  .long Op0478,Op0479,Op047a,Op047b,Op____,Op____,Op____,Op____ ;@ 0478
  .long Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480 ;@ 0480
  .long Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480 ;@ 0488
  .long Op0490,Op0490,Op0490,Op0490,Op0490,Op0490,Op0490,Op0490 ;@ 0490
  .long Op0498,Op0498,Op0498,Op0498,Op0498,Op0498,Op0498,Op049f ;@ 0498
  .long Op04a0,Op04a0,Op04a0,Op04a0,Op04a0,Op04a0,Op04a0,Op04a7 ;@ 04a0
  .long Op04a8,Op04a8,Op04a8,Op04a8,Op04a8,Op04a8,Op04a8,Op04a8 ;@ 04a8
  .long Op04b0,Op04b0,Op04b0,Op04b0,Op04b0,Op04b0,Op04b0,Op04b0 ;@ 04b0
  .long Op04b8,Op04b9,Op04ba,Op04bb,Op____,Op____,Op____,Op____ ;@ 04b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04f8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0500
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0508
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0510
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0518
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0520
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0528
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0530
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0538
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0540
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0548
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0550
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0558
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0560
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0568
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0570
  .long Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____ ;@ 0578
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0580
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0588
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0590
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0598
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 05a0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 05a8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 05b0
  .long Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____ ;@ 05b8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 05c0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 05c8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 05d0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 05d8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 05e0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 05e8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 05f0
  .long Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____ ;@ 05f8
  .long Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600 ;@ 0600
  .long Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600 ;@ 0608
  .long Op0610,Op0610,Op0610,Op0610,Op0610,Op0610,Op0610,Op0610 ;@ 0610
  .long Op0618,Op0618,Op0618,Op0618,Op0618,Op0618,Op0618,Op061f ;@ 0618
  .long Op0620,Op0620,Op0620,Op0620,Op0620,Op0620,Op0620,Op0627 ;@ 0620
  .long Op0628,Op0628,Op0628,Op0628,Op0628,Op0628,Op0628,Op0628 ;@ 0628
  .long Op0630,Op0630,Op0630,Op0630,Op0630,Op0630,Op0630,Op0630 ;@ 0630
  .long Op0638,Op0639,Op063a,Op063b,Op____,Op____,Op____,Op____ ;@ 0638
  .long Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640 ;@ 0640
  .long Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640 ;@ 0648
  .long Op0650,Op0650,Op0650,Op0650,Op0650,Op0650,Op0650,Op0650 ;@ 0650
  .long Op0658,Op0658,Op0658,Op0658,Op0658,Op0658,Op0658,Op065f ;@ 0658
  .long Op0660,Op0660,Op0660,Op0660,Op0660,Op0660,Op0660,Op0667 ;@ 0660
  .long Op0668,Op0668,Op0668,Op0668,Op0668,Op0668,Op0668,Op0668 ;@ 0668
  .long Op0670,Op0670,Op0670,Op0670,Op0670,Op0670,Op0670,Op0670 ;@ 0670
  .long Op0678,Op0679,Op067a,Op067b,Op____,Op____,Op____,Op____ ;@ 0678
  .long Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680 ;@ 0680
  .long Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680 ;@ 0688
  .long Op0690,Op0690,Op0690,Op0690,Op0690,Op0690,Op0690,Op0690 ;@ 0690
  .long Op0698,Op0698,Op0698,Op0698,Op0698,Op0698,Op0698,Op069f ;@ 0698
  .long Op06a0,Op06a0,Op06a0,Op06a0,Op06a0,Op06a0,Op06a0,Op06a7 ;@ 06a0
  .long Op06a8,Op06a8,Op06a8,Op06a8,Op06a8,Op06a8,Op06a8,Op06a8 ;@ 06a8
  .long Op06b0,Op06b0,Op06b0,Op06b0,Op06b0,Op06b0,Op06b0,Op06b0 ;@ 06b0
  .long Op06b8,Op06b9,Op06ba,Op06bb,Op____,Op____,Op____,Op____ ;@ 06b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06f8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0700
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0708
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0710
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0718
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0720
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0728
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0730
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0738
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0740
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0748
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0750
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0758
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0760
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0768
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0770
  .long Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____ ;@ 0778
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0780
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0788
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0790
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0798
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 07a0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 07a8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 07b0
  .long Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____ ;@ 07b8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 07c0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 07c8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 07d0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 07d8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 07e0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 07e8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 07f0
  .long Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____ ;@ 07f8
  .long Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800 ;@ 0800
  .long Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800 ;@ 0808
  .long Op0810,Op0810,Op0810,Op0810,Op0810,Op0810,Op0810,Op0810 ;@ 0810
  .long Op0818,Op0818,Op0818,Op0818,Op0818,Op0818,Op0818,Op081f ;@ 0818
  .long Op0820,Op0820,Op0820,Op0820,Op0820,Op0820,Op0820,Op0827 ;@ 0820
  .long Op0828,Op0828,Op0828,Op0828,Op0828,Op0828,Op0828,Op0828 ;@ 0828
  .long Op0830,Op0830,Op0830,Op0830,Op0830,Op0830,Op0830,Op0830 ;@ 0830
  .long Op0838,Op0839,Op083a,Op083b,Op083c,Op____,Op____,Op____ ;@ 0838
  .long Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840 ;@ 0840
  .long Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840 ;@ 0848
  .long Op0850,Op0850,Op0850,Op0850,Op0850,Op0850,Op0850,Op0850 ;@ 0850
  .long Op0858,Op0858,Op0858,Op0858,Op0858,Op0858,Op0858,Op085f ;@ 0858
  .long Op0860,Op0860,Op0860,Op0860,Op0860,Op0860,Op0860,Op0867 ;@ 0860
  .long Op0868,Op0868,Op0868,Op0868,Op0868,Op0868,Op0868,Op0868 ;@ 0868
  .long Op0870,Op0870,Op0870,Op0870,Op0870,Op0870,Op0870,Op0870 ;@ 0870
  .long Op0878,Op0879,Op087a,Op087b,Op____,Op____,Op____,Op____ ;@ 0878
  .long Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880 ;@ 0880
  .long Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880 ;@ 0888
  .long Op0890,Op0890,Op0890,Op0890,Op0890,Op0890,Op0890,Op0890 ;@ 0890
  .long Op0898,Op0898,Op0898,Op0898,Op0898,Op0898,Op0898,Op089f ;@ 0898
  .long Op08a0,Op08a0,Op08a0,Op08a0,Op08a0,Op08a0,Op08a0,Op08a7 ;@ 08a0
  .long Op08a8,Op08a8,Op08a8,Op08a8,Op08a8,Op08a8,Op08a8,Op08a8 ;@ 08a8
  .long Op08b0,Op08b0,Op08b0,Op08b0,Op08b0,Op08b0,Op08b0,Op08b0 ;@ 08b0
  .long Op08b8,Op08b9,Op08ba,Op08bb,Op____,Op____,Op____,Op____ ;@ 08b8
  .long Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0 ;@ 08c0
  .long Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0 ;@ 08c8
  .long Op08d0,Op08d0,Op08d0,Op08d0,Op08d0,Op08d0,Op08d0,Op08d0 ;@ 08d0
  .long Op08d8,Op08d8,Op08d8,Op08d8,Op08d8,Op08d8,Op08d8,Op08df ;@ 08d8
  .long Op08e0,Op08e0,Op08e0,Op08e0,Op08e0,Op08e0,Op08e0,Op08e7 ;@ 08e0
  .long Op08e8,Op08e8,Op08e8,Op08e8,Op08e8,Op08e8,Op08e8,Op08e8 ;@ 08e8
  .long Op08f0,Op08f0,Op08f0,Op08f0,Op08f0,Op08f0,Op08f0,Op08f0 ;@ 08f0
  .long Op08f8,Op08f9,Op08fa,Op08fb,Op____,Op____,Op____,Op____ ;@ 08f8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0900
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0908
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0910
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0918
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0920
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0928
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0930
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0938
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0940
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0948
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0950
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0958
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0960
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0968
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0970
  .long Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____ ;@ 0978
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0980
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0988
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0990
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0998
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 09a0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 09a8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 09b0
  .long Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____ ;@ 09b8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 09c0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 09c8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 09d0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 09d8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 09e0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 09e8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 09f0
  .long Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____ ;@ 09f8
  .long Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00 ;@ 0a00
  .long Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00 ;@ 0a08
  .long Op0a10,Op0a10,Op0a10,Op0a10,Op0a10,Op0a10,Op0a10,Op0a10 ;@ 0a10
  .long Op0a18,Op0a18,Op0a18,Op0a18,Op0a18,Op0a18,Op0a18,Op0a1f ;@ 0a18
  .long Op0a20,Op0a20,Op0a20,Op0a20,Op0a20,Op0a20,Op0a20,Op0a27 ;@ 0a20
  .long Op0a28,Op0a28,Op0a28,Op0a28,Op0a28,Op0a28,Op0a28,Op0a28 ;@ 0a28
  .long Op0a30,Op0a30,Op0a30,Op0a30,Op0a30,Op0a30,Op0a30,Op0a30 ;@ 0a30
  .long Op0a38,Op0a39,Op0a3a,Op0a3b,Op0a3c,Op____,Op____,Op____ ;@ 0a38
  .long Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40 ;@ 0a40
  .long Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40 ;@ 0a48
  .long Op0a50,Op0a50,Op0a50,Op0a50,Op0a50,Op0a50,Op0a50,Op0a50 ;@ 0a50
  .long Op0a58,Op0a58,Op0a58,Op0a58,Op0a58,Op0a58,Op0a58,Op0a5f ;@ 0a58
  .long Op0a60,Op0a60,Op0a60,Op0a60,Op0a60,Op0a60,Op0a60,Op0a67 ;@ 0a60
  .long Op0a68,Op0a68,Op0a68,Op0a68,Op0a68,Op0a68,Op0a68,Op0a68 ;@ 0a68
  .long Op0a70,Op0a70,Op0a70,Op0a70,Op0a70,Op0a70,Op0a70,Op0a70 ;@ 0a70
  .long Op0a78,Op0a79,Op0a7a,Op0a7b,Op0a7c,Op____,Op____,Op____ ;@ 0a78
  .long Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80 ;@ 0a80
  .long Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80 ;@ 0a88
  .long Op0a90,Op0a90,Op0a90,Op0a90,Op0a90,Op0a90,Op0a90,Op0a90 ;@ 0a90
  .long Op0a98,Op0a98,Op0a98,Op0a98,Op0a98,Op0a98,Op0a98,Op0a9f ;@ 0a98
  .long Op0aa0,Op0aa0,Op0aa0,Op0aa0,Op0aa0,Op0aa0,Op0aa0,Op0aa7 ;@ 0aa0
  .long Op0aa8,Op0aa8,Op0aa8,Op0aa8,Op0aa8,Op0aa8,Op0aa8,Op0aa8 ;@ 0aa8
  .long Op0ab0,Op0ab0,Op0ab0,Op0ab0,Op0ab0,Op0ab0,Op0ab0,Op0ab0 ;@ 0ab0
  .long Op0ab8,Op0ab9,Op0aba,Op0abb,Op____,Op____,Op____,Op____ ;@ 0ab8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ac0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ac8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ad0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ad8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ae0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ae8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0af0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0af8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0b00
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0b08
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0b10
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0b18
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0b20
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0b28
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0b30
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0b38
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0b40
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0b48
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0b50
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0b58
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0b60
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0b68
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0b70
  .long Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____ ;@ 0b78
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0b80
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0b88
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0b90
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0b98
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 0ba0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 0ba8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 0bb0
  .long Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____ ;@ 0bb8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 0bc0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 0bc8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 0bd0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 0bd8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 0be0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 0be8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 0bf0
  .long Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____ ;@ 0bf8
  .long Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00 ;@ 0c00
  .long Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00 ;@ 0c08
  .long Op0c10,Op0c10,Op0c10,Op0c10,Op0c10,Op0c10,Op0c10,Op0c10 ;@ 0c10
  .long Op0c18,Op0c18,Op0c18,Op0c18,Op0c18,Op0c18,Op0c18,Op0c1f ;@ 0c18
  .long Op0c20,Op0c20,Op0c20,Op0c20,Op0c20,Op0c20,Op0c20,Op0c27 ;@ 0c20
  .long Op0c28,Op0c28,Op0c28,Op0c28,Op0c28,Op0c28,Op0c28,Op0c28 ;@ 0c28
  .long Op0c30,Op0c30,Op0c30,Op0c30,Op0c30,Op0c30,Op0c30,Op0c30 ;@ 0c30
  .long Op0c38,Op0c39,Op0c3a,Op0c3b,Op0c3c,Op____,Op____,Op____ ;@ 0c38
  .long Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40 ;@ 0c40
  .long Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40 ;@ 0c48
  .long Op0c50,Op0c50,Op0c50,Op0c50,Op0c50,Op0c50,Op0c50,Op0c50 ;@ 0c50
  .long Op0c58,Op0c58,Op0c58,Op0c58,Op0c58,Op0c58,Op0c58,Op0c5f ;@ 0c58
  .long Op0c60,Op0c60,Op0c60,Op0c60,Op0c60,Op0c60,Op0c60,Op0c67 ;@ 0c60
  .long Op0c68,Op0c68,Op0c68,Op0c68,Op0c68,Op0c68,Op0c68,Op0c68 ;@ 0c68
  .long Op0c70,Op0c70,Op0c70,Op0c70,Op0c70,Op0c70,Op0c70,Op0c70 ;@ 0c70
  .long Op0c78,Op0c79,Op0c7a,Op0c7b,Op0c7c,Op____,Op____,Op____ ;@ 0c78
  .long Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80 ;@ 0c80
  .long Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80 ;@ 0c88
  .long Op0c90,Op0c90,Op0c90,Op0c90,Op0c90,Op0c90,Op0c90,Op0c90 ;@ 0c90
  .long Op0c98,Op0c98,Op0c98,Op0c98,Op0c98,Op0c98,Op0c98,Op0c9f ;@ 0c98
  .long Op0ca0,Op0ca0,Op0ca0,Op0ca0,Op0ca0,Op0ca0,Op0ca0,Op0ca7 ;@ 0ca0
  .long Op0ca8,Op0ca8,Op0ca8,Op0ca8,Op0ca8,Op0ca8,Op0ca8,Op0ca8 ;@ 0ca8
  .long Op0cb0,Op0cb0,Op0cb0,Op0cb0,Op0cb0,Op0cb0,Op0cb0,Op0cb0 ;@ 0cb0
  .long Op0cb8,Op0cb9,Op0cba,Op0cbb,Op0cbc,Op____,Op____,Op____ ;@ 0cb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ce0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ce8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cf8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0d00
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0d08
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0d10
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0d18
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0d20
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0d28
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0d30
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0d38
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0d40
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0d48
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0d50
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0d58
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0d60
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0d68
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0d70
  .long Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____ ;@ 0d78
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0d80
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0d88
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0d90
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0d98
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 0da0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 0da8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 0db0
  .long Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____ ;@ 0db8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 0dc0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 0dc8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 0dd0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 0dd8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 0de0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 0de8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 0df0
  .long Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____ ;@ 0df8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e88
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e90
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ea0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ea8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0eb0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0eb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ec0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ec8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ed0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ed8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ee0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ee8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ef0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ef8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0f00
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0f08
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0f10
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0f18
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0f20
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0f28
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0f30
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0f38
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0f40
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0f48
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0f50
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0f58
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0f60
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0f68
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0f70
  .long Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____ ;@ 0f78
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0f80
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0f88
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0f90
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0f98
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 0fa0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 0fa8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 0fb0
  .long Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____ ;@ 0fb8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 0fc0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 0fc8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 0fd0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 0fd8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 0fe0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 0fe8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 0ff0
  .long Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____ ;@ 0ff8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1000
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1008
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1010
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1018
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1020
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1028
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1030
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1038
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1040
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1048
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1050
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1058
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1060
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1068
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1070
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1078
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1080
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1088
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1090
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1098
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 10a0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 10a8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 10b0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 10b8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 10c0
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 10c8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 10d0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 10d8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 10e0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 10e8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 10f0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 10f8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1100
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1108
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1110
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1118
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1120
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1128
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1130
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1138
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1140
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1148
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1150
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1158
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1160
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1168
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1170
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1178
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1180
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1188
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1190
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1198
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 11a0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 11a8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 11b0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 11b8
  .long Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0 ;@ 11c0
  .long Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0 ;@ 11c8
  .long Op11d0,Op11d0,Op11d0,Op11d0,Op11d0,Op11d0,Op11d0,Op11d0 ;@ 11d0
  .long Op11d8,Op11d8,Op11d8,Op11d8,Op11d8,Op11d8,Op11d8,Op11df ;@ 11d8
  .long Op11e0,Op11e0,Op11e0,Op11e0,Op11e0,Op11e0,Op11e0,Op11e7 ;@ 11e0
  .long Op11e8,Op11e8,Op11e8,Op11e8,Op11e8,Op11e8,Op11e8,Op11e8 ;@ 11e8
  .long Op11f0,Op11f0,Op11f0,Op11f0,Op11f0,Op11f0,Op11f0,Op11f0 ;@ 11f0
  .long Op11f8,Op11f9,Op11fa,Op11fb,Op11fc,Op____,Op____,Op____ ;@ 11f8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1200
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1208
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1210
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1218
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1220
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1228
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1230
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1238
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1240
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1248
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1250
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1258
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1260
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1268
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1270
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1278
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1280
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1288
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1290
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1298
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 12a0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 12a8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 12b0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 12b8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 12c0
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 12c8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 12d0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 12d8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 12e0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 12e8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 12f0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 12f8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1300
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1308
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1310
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1318
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1320
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1328
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1330
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1338
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1340
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1348
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1350
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1358
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1360
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1368
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1370
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1378
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1380
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1388
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1390
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1398
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 13a0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 13a8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 13b0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 13b8
  .long Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0 ;@ 13c0
  .long Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0 ;@ 13c8
  .long Op13d0,Op13d0,Op13d0,Op13d0,Op13d0,Op13d0,Op13d0,Op13d0 ;@ 13d0
  .long Op13d8,Op13d8,Op13d8,Op13d8,Op13d8,Op13d8,Op13d8,Op13df ;@ 13d8
  .long Op13e0,Op13e0,Op13e0,Op13e0,Op13e0,Op13e0,Op13e0,Op13e7 ;@ 13e0
  .long Op13e8,Op13e8,Op13e8,Op13e8,Op13e8,Op13e8,Op13e8,Op13e8 ;@ 13e8
  .long Op13f0,Op13f0,Op13f0,Op13f0,Op13f0,Op13f0,Op13f0,Op13f0 ;@ 13f0
  .long Op13f8,Op13f9,Op13fa,Op13fb,Op13fc,Op____,Op____,Op____ ;@ 13f8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1400
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1408
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1410
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1418
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1420
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1428
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1430
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1438
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1440
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1448
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1450
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1458
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1460
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1468
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1470
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1478
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1480
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1488
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1490
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1498
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 14a0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 14a8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 14b0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 14b8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 14c0
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 14c8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 14d0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 14d8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 14e0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 14e8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 14f0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 14f8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1500
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1508
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1510
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1518
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1520
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1528
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1530
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1538
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1540
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1548
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1550
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1558
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1560
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1568
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1570
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1578
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1580
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1588
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1590
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1598
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 15a0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 15a8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 15b0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 15b8
  .long Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0 ;@ 15c0
  .long Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0 ;@ 15c8
  .long Op15d0,Op15d0,Op15d0,Op15d0,Op15d0,Op15d0,Op15d0,Op15d0 ;@ 15d0
  .long Op15d8,Op15d8,Op15d8,Op15d8,Op15d8,Op15d8,Op15d8,Op15df ;@ 15d8
  .long Op15e0,Op15e0,Op15e0,Op15e0,Op15e0,Op15e0,Op15e0,Op15e7 ;@ 15e0
  .long Op15e8,Op15e8,Op15e8,Op15e8,Op15e8,Op15e8,Op15e8,Op15e8 ;@ 15e8
  .long Op15f0,Op15f0,Op15f0,Op15f0,Op15f0,Op15f0,Op15f0,Op15f0 ;@ 15f0
  .long Op15f8,Op15f9,Op15fa,Op15fb,Op15fc,Op____,Op____,Op____ ;@ 15f8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1600
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1608
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1610
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1618
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1620
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1628
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1630
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1638
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1640
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1648
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1650
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1658
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1660
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1668
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1670
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1678
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1680
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1688
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1690
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1698
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 16a0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 16a8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 16b0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 16b8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 16c0
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 16c8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 16d0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 16d8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 16e0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 16e8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 16f0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 16f8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1700
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1708
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1710
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1718
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1720
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1728
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1730
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1738
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1740
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1748
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1750
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1758
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1760
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1768
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1770
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1778
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1780
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1788
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1790
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1798
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 17a0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 17a8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 17b0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 17b8
  .long Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0 ;@ 17c0
  .long Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0 ;@ 17c8
  .long Op17d0,Op17d0,Op17d0,Op17d0,Op17d0,Op17d0,Op17d0,Op17d0 ;@ 17d0
  .long Op17d8,Op17d8,Op17d8,Op17d8,Op17d8,Op17d8,Op17d8,Op17df ;@ 17d8
  .long Op17e0,Op17e0,Op17e0,Op17e0,Op17e0,Op17e0,Op17e0,Op17e7 ;@ 17e0
  .long Op17e8,Op17e8,Op17e8,Op17e8,Op17e8,Op17e8,Op17e8,Op17e8 ;@ 17e8
  .long Op17f0,Op17f0,Op17f0,Op17f0,Op17f0,Op17f0,Op17f0,Op17f0 ;@ 17f0
  .long Op17f8,Op17f9,Op17fa,Op17fb,Op17fc,Op____,Op____,Op____ ;@ 17f8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1800
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1808
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1810
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1818
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1820
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1828
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1830
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1838
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1840
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1848
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1850
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1858
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1860
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1868
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1870
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1878
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1880
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1888
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1890
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1898
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 18a0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 18a8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 18b0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 18b8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 18c0
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 18c8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 18d0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 18d8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 18e0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 18e8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 18f0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 18f8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1900
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1908
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1910
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1918
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1920
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1928
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1930
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1938
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1940
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1948
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1950
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1958
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1960
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1968
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1970
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1978
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1980
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1988
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1990
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1998
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 19a0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 19a8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 19b0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 19b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19f8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1a00
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1a08
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1a10
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1a18
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1a20
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1a28
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1a30
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1a38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a78
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1a80
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1a88
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1a90
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1a98
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 1aa0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 1aa8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 1ab0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 1ab8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 1ac0
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 1ac8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 1ad0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 1ad8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 1ae0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 1ae8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 1af0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 1af8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1b00
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1b08
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1b10
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1b18
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1b20
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1b28
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1b30
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1b38
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1b40
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1b48
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1b50
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1b58
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1b60
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1b68
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1b70
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1b78
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1b80
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1b88
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1b90
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1b98
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 1ba0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 1ba8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 1bb0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 1bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1bc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1bc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1bd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1bd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1be0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1be8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1bf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1bf8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1c00
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1c08
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1c10
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1c18
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1c20
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1c28
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1c30
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1c38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c78
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1c80
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1c88
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1c90
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1c98
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 1ca0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 1ca8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 1cb0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 1cb8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 1cc0
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 1cc8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 1cd0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 1cd8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 1ce0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 1ce8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 1cf0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 1cf8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1d00
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1d08
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1d10
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1d18
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1d20
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1d28
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1d30
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1d38
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1d40
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1d48
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1d50
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1d58
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1d60
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1d68
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1d70
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1d78
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1d80
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1d88
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1d90
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1d98
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 1da0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 1da8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 1db0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 1db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1dc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1dc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1dd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1dd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1de0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1de8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1df0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1df8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1e00
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1e08
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1e10
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1e18
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1e20
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1e28
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1e30
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1e38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e78
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1e80
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1e88
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1e90
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1e98
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 1ea0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 1ea8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 1eb0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 1eb8
  .long Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0 ;@ 1ec0
  .long Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0 ;@ 1ec8
  .long Op1ed0,Op1ed0,Op1ed0,Op1ed0,Op1ed0,Op1ed0,Op1ed0,Op1ed0 ;@ 1ed0
  .long Op1ed8,Op1ed8,Op1ed8,Op1ed8,Op1ed8,Op1ed8,Op1ed8,Op1edf ;@ 1ed8
  .long Op1ee0,Op1ee0,Op1ee0,Op1ee0,Op1ee0,Op1ee0,Op1ee0,Op1ee7 ;@ 1ee0
  .long Op1ee8,Op1ee8,Op1ee8,Op1ee8,Op1ee8,Op1ee8,Op1ee8,Op1ee8 ;@ 1ee8
  .long Op1ef0,Op1ef0,Op1ef0,Op1ef0,Op1ef0,Op1ef0,Op1ef0,Op1ef0 ;@ 1ef0
  .long Op1ef8,Op1ef9,Op1efa,Op1efb,Op1efc,Op____,Op____,Op____ ;@ 1ef8
  .long Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00 ;@ 1f00
  .long Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00 ;@ 1f08
  .long Op1f10,Op1f10,Op1f10,Op1f10,Op1f10,Op1f10,Op1f10,Op1f10 ;@ 1f10
  .long Op1f18,Op1f18,Op1f18,Op1f18,Op1f18,Op1f18,Op1f18,Op1f1f ;@ 1f18
  .long Op1f20,Op1f20,Op1f20,Op1f20,Op1f20,Op1f20,Op1f20,Op1f27 ;@ 1f20
  .long Op1f28,Op1f28,Op1f28,Op1f28,Op1f28,Op1f28,Op1f28,Op1f28 ;@ 1f28
  .long Op1f30,Op1f30,Op1f30,Op1f30,Op1f30,Op1f30,Op1f30,Op1f30 ;@ 1f30
  .long Op1f38,Op1f39,Op1f3a,Op1f3b,Op1f3c,Op____,Op____,Op____ ;@ 1f38
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1f40
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1f48
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1f50
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1f58
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1f60
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1f68
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1f70
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1f78
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1f80
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1f88
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1f90
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1f98
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 1fa0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 1fa8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 1fb0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 1fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1fc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1fc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1fd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1fd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1fe0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1fe8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1ff0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1ff8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2000
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2008
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2010
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f ;@ 2018
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027 ;@ 2020
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2028
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2030
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2038
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2040
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2048
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2050
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f ;@ 2058
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067 ;@ 2060
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2068
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2070
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2078
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2080
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2088
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2090
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f ;@ 2098
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7 ;@ 20a0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 20a8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 20b0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 20b8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 20c0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 20c8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 20d0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df ;@ 20d8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7 ;@ 20e0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 20e8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 20f0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 20f8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2100
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2108
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2110
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f ;@ 2118
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127 ;@ 2120
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2128
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2130
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2138
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2140
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2148
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2150
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f ;@ 2158
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167 ;@ 2160
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2168
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2170
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2178
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2180
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2188
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2190
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f ;@ 2198
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7 ;@ 21a0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 21a8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 21b0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 21b8
  .long Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0 ;@ 21c0
  .long Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0 ;@ 21c8
  .long Op21d0,Op21d0,Op21d0,Op21d0,Op21d0,Op21d0,Op21d0,Op21d0 ;@ 21d0
  .long Op21d8,Op21d8,Op21d8,Op21d8,Op21d8,Op21d8,Op21d8,Op21df ;@ 21d8
  .long Op21e0,Op21e0,Op21e0,Op21e0,Op21e0,Op21e0,Op21e0,Op21e7 ;@ 21e0
  .long Op21e8,Op21e8,Op21e8,Op21e8,Op21e8,Op21e8,Op21e8,Op21e8 ;@ 21e8
  .long Op21f0,Op21f0,Op21f0,Op21f0,Op21f0,Op21f0,Op21f0,Op21f0 ;@ 21f0
  .long Op21f8,Op21f9,Op21fa,Op21fb,Op21fc,Op____,Op____,Op____ ;@ 21f8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2200
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2208
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2210
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f ;@ 2218
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027 ;@ 2220
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2228
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2230
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2238
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2240
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2248
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2250
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f ;@ 2258
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067 ;@ 2260
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2268
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2270
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2278
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2280
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2288
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2290
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f ;@ 2298
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7 ;@ 22a0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 22a8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 22b0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 22b8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 22c0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 22c8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 22d0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df ;@ 22d8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7 ;@ 22e0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 22e8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 22f0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 22f8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2300
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2308
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2310
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f ;@ 2318
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127 ;@ 2320
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2328
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2330
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2338
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2340
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2348
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2350
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f ;@ 2358
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167 ;@ 2360
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2368
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2370
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2378
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2380
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2388
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2390
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f ;@ 2398
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7 ;@ 23a0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 23a8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 23b0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 23b8
  .long Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0 ;@ 23c0
  .long Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0 ;@ 23c8
  .long Op23d0,Op23d0,Op23d0,Op23d0,Op23d0,Op23d0,Op23d0,Op23d0 ;@ 23d0
  .long Op23d8,Op23d8,Op23d8,Op23d8,Op23d8,Op23d8,Op23d8,Op23df ;@ 23d8
  .long Op23e0,Op23e0,Op23e0,Op23e0,Op23e0,Op23e0,Op23e0,Op23e7 ;@ 23e0
  .long Op23e8,Op23e8,Op23e8,Op23e8,Op23e8,Op23e8,Op23e8,Op23e8 ;@ 23e8
  .long Op23f0,Op23f0,Op23f0,Op23f0,Op23f0,Op23f0,Op23f0,Op23f0 ;@ 23f0
  .long Op23f8,Op23f9,Op23fa,Op23fb,Op23fc,Op____,Op____,Op____ ;@ 23f8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2400
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2408
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2410
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f ;@ 2418
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027 ;@ 2420
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2428
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2430
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2438
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2440
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2448
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2450
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f ;@ 2458
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067 ;@ 2460
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2468
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2470
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2478
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2480
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2488
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2490
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f ;@ 2498
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7 ;@ 24a0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 24a8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 24b0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 24b8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 24c0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 24c8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 24d0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df ;@ 24d8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7 ;@ 24e0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 24e8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 24f0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 24f8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2500
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2508
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2510
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f ;@ 2518
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127 ;@ 2520
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2528
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2530
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2538
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2540
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2548
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2550
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f ;@ 2558
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167 ;@ 2560
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2568
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2570
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2578
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2580
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2588
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2590
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f ;@ 2598
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7 ;@ 25a0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 25a8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 25b0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 25b8
  .long Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0 ;@ 25c0
  .long Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0 ;@ 25c8
  .long Op25d0,Op25d0,Op25d0,Op25d0,Op25d0,Op25d0,Op25d0,Op25d0 ;@ 25d0
  .long Op25d8,Op25d8,Op25d8,Op25d8,Op25d8,Op25d8,Op25d8,Op25df ;@ 25d8
  .long Op25e0,Op25e0,Op25e0,Op25e0,Op25e0,Op25e0,Op25e0,Op25e7 ;@ 25e0
  .long Op25e8,Op25e8,Op25e8,Op25e8,Op25e8,Op25e8,Op25e8,Op25e8 ;@ 25e8
  .long Op25f0,Op25f0,Op25f0,Op25f0,Op25f0,Op25f0,Op25f0,Op25f0 ;@ 25f0
  .long Op25f8,Op25f9,Op25fa,Op25fb,Op25fc,Op____,Op____,Op____ ;@ 25f8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2600
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2608
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2610
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f ;@ 2618
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027 ;@ 2620
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2628
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2630
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2638
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2640
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2648
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2650
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f ;@ 2658
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067 ;@ 2660
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2668
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2670
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2678
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2680
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2688
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2690
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f ;@ 2698
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7 ;@ 26a0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 26a8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 26b0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 26b8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 26c0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 26c8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 26d0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df ;@ 26d8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7 ;@ 26e0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 26e8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 26f0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 26f8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2700
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2708
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2710
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f ;@ 2718
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127 ;@ 2720
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2728
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2730
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2738
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2740
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2748
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2750
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f ;@ 2758
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167 ;@ 2760
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2768
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2770
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2778
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2780
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2788
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2790
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f ;@ 2798
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7 ;@ 27a0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 27a8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 27b0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 27b8
  .long Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0 ;@ 27c0
  .long Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0 ;@ 27c8
  .long Op27d0,Op27d0,Op27d0,Op27d0,Op27d0,Op27d0,Op27d0,Op27d0 ;@ 27d0
  .long Op27d8,Op27d8,Op27d8,Op27d8,Op27d8,Op27d8,Op27d8,Op27df ;@ 27d8
  .long Op27e0,Op27e0,Op27e0,Op27e0,Op27e0,Op27e0,Op27e0,Op27e7 ;@ 27e0
  .long Op27e8,Op27e8,Op27e8,Op27e8,Op27e8,Op27e8,Op27e8,Op27e8 ;@ 27e8
  .long Op27f0,Op27f0,Op27f0,Op27f0,Op27f0,Op27f0,Op27f0,Op27f0 ;@ 27f0
  .long Op27f8,Op27f9,Op27fa,Op27fb,Op27fc,Op____,Op____,Op____ ;@ 27f8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2800
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2808
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2810
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f ;@ 2818
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027 ;@ 2820
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2828
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2830
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2838
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2840
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2848
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2850
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f ;@ 2858
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067 ;@ 2860
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2868
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2870
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2878
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2880
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2888
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2890
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f ;@ 2898
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7 ;@ 28a0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 28a8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 28b0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 28b8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 28c0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 28c8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 28d0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df ;@ 28d8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7 ;@ 28e0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 28e8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 28f0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 28f8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2900
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2908
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2910
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f ;@ 2918
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127 ;@ 2920
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2928
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2930
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2938
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2940
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2948
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2950
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f ;@ 2958
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167 ;@ 2960
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2968
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2970
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2978
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2980
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2988
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2990
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f ;@ 2998
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7 ;@ 29a0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 29a8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 29b0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 29b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29f8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2a00
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2a08
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2a10
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f ;@ 2a18
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027 ;@ 2a20
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2a28
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2a30
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2a38
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2a40
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2a48
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2a50
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f ;@ 2a58
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067 ;@ 2a60
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2a68
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2a70
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2a78
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2a80
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2a88
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2a90
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f ;@ 2a98
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7 ;@ 2aa0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 2aa8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 2ab0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 2ab8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 2ac0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 2ac8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 2ad0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df ;@ 2ad8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7 ;@ 2ae0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 2ae8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 2af0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 2af8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2b00
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2b08
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2b10
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f ;@ 2b18
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127 ;@ 2b20
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2b28
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2b30
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2b38
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2b40
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2b48
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2b50
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f ;@ 2b58
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167 ;@ 2b60
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2b68
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2b70
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2b78
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2b80
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2b88
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2b90
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f ;@ 2b98
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7 ;@ 2ba0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 2ba8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 2bb0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 2bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2bc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2bc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2bd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2bd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2be0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2be8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2bf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2bf8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2c00
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2c08
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2c10
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f ;@ 2c18
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027 ;@ 2c20
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2c28
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2c30
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2c38
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2c40
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2c48
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2c50
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f ;@ 2c58
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067 ;@ 2c60
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2c68
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2c70
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2c78
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2c80
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2c88
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2c90
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f ;@ 2c98
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7 ;@ 2ca0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 2ca8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 2cb0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 2cb8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 2cc0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 2cc8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 2cd0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df ;@ 2cd8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7 ;@ 2ce0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 2ce8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 2cf0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 2cf8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2d00
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2d08
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2d10
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f ;@ 2d18
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127 ;@ 2d20
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2d28
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2d30
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2d38
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2d40
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2d48
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2d50
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f ;@ 2d58
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167 ;@ 2d60
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2d68
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2d70
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2d78
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2d80
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2d88
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2d90
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f ;@ 2d98
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7 ;@ 2da0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 2da8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 2db0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 2db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2dc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2dc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2dd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2dd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2de0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2de8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2df0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2df8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2e00
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2e08
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2e10
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f ;@ 2e18
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027 ;@ 2e20
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2e28
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2e30
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2e38
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2e40
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2e48
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2e50
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f ;@ 2e58
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067 ;@ 2e60
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2e68
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2e70
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2e78
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2e80
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2e88
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2e90
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f ;@ 2e98
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7 ;@ 2ea0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 2ea8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 2eb0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 2eb8
  .long Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0 ;@ 2ec0
  .long Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0 ;@ 2ec8
  .long Op2ed0,Op2ed0,Op2ed0,Op2ed0,Op2ed0,Op2ed0,Op2ed0,Op2ed0 ;@ 2ed0
  .long Op2ed8,Op2ed8,Op2ed8,Op2ed8,Op2ed8,Op2ed8,Op2ed8,Op2edf ;@ 2ed8
  .long Op2ee0,Op2ee0,Op2ee0,Op2ee0,Op2ee0,Op2ee0,Op2ee0,Op2ee7 ;@ 2ee0
  .long Op2ee8,Op2ee8,Op2ee8,Op2ee8,Op2ee8,Op2ee8,Op2ee8,Op2ee8 ;@ 2ee8
  .long Op2ef0,Op2ef0,Op2ef0,Op2ef0,Op2ef0,Op2ef0,Op2ef0,Op2ef0 ;@ 2ef0
  .long Op2ef8,Op2ef9,Op2efa,Op2efb,Op2efc,Op____,Op____,Op____ ;@ 2ef8
  .long Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00 ;@ 2f00
  .long Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00 ;@ 2f08
  .long Op2f10,Op2f10,Op2f10,Op2f10,Op2f10,Op2f10,Op2f10,Op2f10 ;@ 2f10
  .long Op2f18,Op2f18,Op2f18,Op2f18,Op2f18,Op2f18,Op2f18,Op2f1f ;@ 2f18
  .long Op2f20,Op2f20,Op2f20,Op2f20,Op2f20,Op2f20,Op2f20,Op2f27 ;@ 2f20
  .long Op2f28,Op2f28,Op2f28,Op2f28,Op2f28,Op2f28,Op2f28,Op2f28 ;@ 2f28
  .long Op2f30,Op2f30,Op2f30,Op2f30,Op2f30,Op2f30,Op2f30,Op2f30 ;@ 2f30
  .long Op2f38,Op2f39,Op2f3a,Op2f3b,Op2f3c,Op____,Op____,Op____ ;@ 2f38
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2f40
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2f48
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2f50
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f ;@ 2f58
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167 ;@ 2f60
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2f68
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2f70
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2f78
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2f80
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2f88
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2f90
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f ;@ 2f98
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7 ;@ 2fa0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 2fa8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 2fb0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 2fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2fc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2fc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2fd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2fd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2fe0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2fe8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2ff0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2ff8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3000
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3008
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3010
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f ;@ 3018
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027 ;@ 3020
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3028
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3030
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3038
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3040
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3048
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3050
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f ;@ 3058
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067 ;@ 3060
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3068
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3070
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3078
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3080
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3088
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3090
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f ;@ 3098
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7 ;@ 30a0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 30a8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 30b0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 30b8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 30c0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 30c8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 30d0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df ;@ 30d8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7 ;@ 30e0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 30e8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 30f0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 30f8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3100
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3108
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3110
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f ;@ 3118
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127 ;@ 3120
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3128
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3130
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3138
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3140
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3148
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3150
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f ;@ 3158
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167 ;@ 3160
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3168
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3170
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3178
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3180
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3188
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3190
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f ;@ 3198
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7 ;@ 31a0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 31a8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 31b0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 31b8
  .long Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0 ;@ 31c0
  .long Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0 ;@ 31c8
  .long Op31d0,Op31d0,Op31d0,Op31d0,Op31d0,Op31d0,Op31d0,Op31d0 ;@ 31d0
  .long Op31d8,Op31d8,Op31d8,Op31d8,Op31d8,Op31d8,Op31d8,Op31df ;@ 31d8
  .long Op31e0,Op31e0,Op31e0,Op31e0,Op31e0,Op31e0,Op31e0,Op31e7 ;@ 31e0
  .long Op31e8,Op31e8,Op31e8,Op31e8,Op31e8,Op31e8,Op31e8,Op31e8 ;@ 31e8
  .long Op31f0,Op31f0,Op31f0,Op31f0,Op31f0,Op31f0,Op31f0,Op31f0 ;@ 31f0
  .long Op31f8,Op31f9,Op31fa,Op31fb,Op31fc,Op____,Op____,Op____ ;@ 31f8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3200
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3208
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3210
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f ;@ 3218
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027 ;@ 3220
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3228
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3230
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3238
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3240
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3248
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3250
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f ;@ 3258
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067 ;@ 3260
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3268
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3270
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3278
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3280
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3288
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3290
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f ;@ 3298
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7 ;@ 32a0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 32a8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 32b0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 32b8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 32c0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 32c8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 32d0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df ;@ 32d8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7 ;@ 32e0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 32e8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 32f0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 32f8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3300
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3308
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3310
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f ;@ 3318
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127 ;@ 3320
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3328
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3330
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3338
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3340
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3348
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3350
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f ;@ 3358
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167 ;@ 3360
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3368
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3370
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3378
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3380
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3388
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3390
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f ;@ 3398
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7 ;@ 33a0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 33a8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 33b0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 33b8
  .long Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0 ;@ 33c0
  .long Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0 ;@ 33c8
  .long Op33d0,Op33d0,Op33d0,Op33d0,Op33d0,Op33d0,Op33d0,Op33d0 ;@ 33d0
  .long Op33d8,Op33d8,Op33d8,Op33d8,Op33d8,Op33d8,Op33d8,Op33df ;@ 33d8
  .long Op33e0,Op33e0,Op33e0,Op33e0,Op33e0,Op33e0,Op33e0,Op33e7 ;@ 33e0
  .long Op33e8,Op33e8,Op33e8,Op33e8,Op33e8,Op33e8,Op33e8,Op33e8 ;@ 33e8
  .long Op33f0,Op33f0,Op33f0,Op33f0,Op33f0,Op33f0,Op33f0,Op33f0 ;@ 33f0
  .long Op33f8,Op33f9,Op33fa,Op33fb,Op33fc,Op____,Op____,Op____ ;@ 33f8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3400
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3408
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3410
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f ;@ 3418
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027 ;@ 3420
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3428
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3430
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3438
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3440
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3448
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3450
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f ;@ 3458
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067 ;@ 3460
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3468
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3470
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3478
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3480
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3488
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3490
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f ;@ 3498
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7 ;@ 34a0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 34a8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 34b0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 34b8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 34c0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 34c8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 34d0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df ;@ 34d8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7 ;@ 34e0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 34e8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 34f0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 34f8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3500
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3508
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3510
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f ;@ 3518
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127 ;@ 3520
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3528
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3530
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3538
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3540
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3548
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3550
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f ;@ 3558
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167 ;@ 3560
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3568
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3570
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3578
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3580
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3588
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3590
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f ;@ 3598
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7 ;@ 35a0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 35a8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 35b0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 35b8
  .long Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0 ;@ 35c0
  .long Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0 ;@ 35c8
  .long Op35d0,Op35d0,Op35d0,Op35d0,Op35d0,Op35d0,Op35d0,Op35d0 ;@ 35d0
  .long Op35d8,Op35d8,Op35d8,Op35d8,Op35d8,Op35d8,Op35d8,Op35df ;@ 35d8
  .long Op35e0,Op35e0,Op35e0,Op35e0,Op35e0,Op35e0,Op35e0,Op35e7 ;@ 35e0
  .long Op35e8,Op35e8,Op35e8,Op35e8,Op35e8,Op35e8,Op35e8,Op35e8 ;@ 35e8
  .long Op35f0,Op35f0,Op35f0,Op35f0,Op35f0,Op35f0,Op35f0,Op35f0 ;@ 35f0
  .long Op35f8,Op35f9,Op35fa,Op35fb,Op35fc,Op____,Op____,Op____ ;@ 35f8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3600
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3608
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3610
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f ;@ 3618
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027 ;@ 3620
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3628
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3630
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3638
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3640
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3648
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3650
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f ;@ 3658
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067 ;@ 3660
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3668
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3670
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3678
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3680
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3688
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3690
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f ;@ 3698
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7 ;@ 36a0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 36a8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 36b0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 36b8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 36c0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 36c8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 36d0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df ;@ 36d8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7 ;@ 36e0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 36e8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 36f0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 36f8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3700
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3708
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3710
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f ;@ 3718
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127 ;@ 3720
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3728
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3730
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3738
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3740
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3748
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3750
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f ;@ 3758
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167 ;@ 3760
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3768
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3770
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3778
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3780
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3788
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3790
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f ;@ 3798
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7 ;@ 37a0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 37a8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 37b0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 37b8
  .long Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0 ;@ 37c0
  .long Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0 ;@ 37c8
  .long Op37d0,Op37d0,Op37d0,Op37d0,Op37d0,Op37d0,Op37d0,Op37d0 ;@ 37d0
  .long Op37d8,Op37d8,Op37d8,Op37d8,Op37d8,Op37d8,Op37d8,Op37df ;@ 37d8
  .long Op37e0,Op37e0,Op37e0,Op37e0,Op37e0,Op37e0,Op37e0,Op37e7 ;@ 37e0
  .long Op37e8,Op37e8,Op37e8,Op37e8,Op37e8,Op37e8,Op37e8,Op37e8 ;@ 37e8
  .long Op37f0,Op37f0,Op37f0,Op37f0,Op37f0,Op37f0,Op37f0,Op37f0 ;@ 37f0
  .long Op37f8,Op37f9,Op37fa,Op37fb,Op37fc,Op____,Op____,Op____ ;@ 37f8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3800
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3808
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3810
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f ;@ 3818
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027 ;@ 3820
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3828
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3830
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3838
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3840
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3848
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3850
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f ;@ 3858
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067 ;@ 3860
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3868
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3870
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3878
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3880
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3888
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3890
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f ;@ 3898
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7 ;@ 38a0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 38a8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 38b0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 38b8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 38c0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 38c8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 38d0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df ;@ 38d8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7 ;@ 38e0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 38e8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 38f0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 38f8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3900
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3908
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3910
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f ;@ 3918
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127 ;@ 3920
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3928
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3930
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3938
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3940
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3948
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3950
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f ;@ 3958
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167 ;@ 3960
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3968
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3970
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3978
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3980
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3988
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3990
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f ;@ 3998
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7 ;@ 39a0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 39a8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 39b0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 39b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39f8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3a00
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3a08
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3a10
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f ;@ 3a18
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027 ;@ 3a20
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3a28
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3a30
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3a38
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3a40
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3a48
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3a50
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f ;@ 3a58
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067 ;@ 3a60
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3a68
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3a70
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3a78
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3a80
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3a88
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3a90
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f ;@ 3a98
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7 ;@ 3aa0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 3aa8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 3ab0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 3ab8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 3ac0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 3ac8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 3ad0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df ;@ 3ad8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7 ;@ 3ae0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 3ae8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 3af0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 3af8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3b00
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3b08
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3b10
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f ;@ 3b18
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127 ;@ 3b20
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3b28
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3b30
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3b38
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3b40
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3b48
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3b50
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f ;@ 3b58
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167 ;@ 3b60
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3b68
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3b70
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3b78
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3b80
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3b88
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3b90
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f ;@ 3b98
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7 ;@ 3ba0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 3ba8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 3bb0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 3bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3bc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3bc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3bd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3bd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3be0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3be8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3bf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3bf8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3c00
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3c08
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3c10
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f ;@ 3c18
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027 ;@ 3c20
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3c28
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3c30
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3c38
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3c40
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3c48
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3c50
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f ;@ 3c58
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067 ;@ 3c60
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3c68
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3c70
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3c78
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3c80
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3c88
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3c90
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f ;@ 3c98
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7 ;@ 3ca0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 3ca8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 3cb0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 3cb8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 3cc0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 3cc8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 3cd0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df ;@ 3cd8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7 ;@ 3ce0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 3ce8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 3cf0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 3cf8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3d00
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3d08
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3d10
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f ;@ 3d18
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127 ;@ 3d20
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3d28
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3d30
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3d38
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3d40
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3d48
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3d50
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f ;@ 3d58
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167 ;@ 3d60
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3d68
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3d70
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3d78
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3d80
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3d88
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3d90
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f ;@ 3d98
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7 ;@ 3da0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 3da8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 3db0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 3db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3dc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3dc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3dd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3dd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3de0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3de8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3df0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3df8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3e00
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3e08
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3e10
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f ;@ 3e18
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027 ;@ 3e20
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3e28
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3e30
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3e38
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3e40
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3e48
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3e50
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f ;@ 3e58
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067 ;@ 3e60
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3e68
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3e70
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3e78
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3e80
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3e88
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3e90
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f ;@ 3e98
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7 ;@ 3ea0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 3ea8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 3eb0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 3eb8
  .long Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0 ;@ 3ec0
  .long Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0 ;@ 3ec8
  .long Op3ed0,Op3ed0,Op3ed0,Op3ed0,Op3ed0,Op3ed0,Op3ed0,Op3ed0 ;@ 3ed0
  .long Op3ed8,Op3ed8,Op3ed8,Op3ed8,Op3ed8,Op3ed8,Op3ed8,Op3edf ;@ 3ed8
  .long Op3ee0,Op3ee0,Op3ee0,Op3ee0,Op3ee0,Op3ee0,Op3ee0,Op3ee7 ;@ 3ee0
  .long Op3ee8,Op3ee8,Op3ee8,Op3ee8,Op3ee8,Op3ee8,Op3ee8,Op3ee8 ;@ 3ee8
  .long Op3ef0,Op3ef0,Op3ef0,Op3ef0,Op3ef0,Op3ef0,Op3ef0,Op3ef0 ;@ 3ef0
  .long Op3ef8,Op3ef9,Op3efa,Op3efb,Op3efc,Op____,Op____,Op____ ;@ 3ef8
  .long Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00 ;@ 3f00
  .long Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00 ;@ 3f08
  .long Op3f10,Op3f10,Op3f10,Op3f10,Op3f10,Op3f10,Op3f10,Op3f10 ;@ 3f10
  .long Op3f18,Op3f18,Op3f18,Op3f18,Op3f18,Op3f18,Op3f18,Op3f1f ;@ 3f18
  .long Op3f20,Op3f20,Op3f20,Op3f20,Op3f20,Op3f20,Op3f20,Op3f27 ;@ 3f20
  .long Op3f28,Op3f28,Op3f28,Op3f28,Op3f28,Op3f28,Op3f28,Op3f28 ;@ 3f28
  .long Op3f30,Op3f30,Op3f30,Op3f30,Op3f30,Op3f30,Op3f30,Op3f30 ;@ 3f30
  .long Op3f38,Op3f39,Op3f3a,Op3f3b,Op3f3c,Op____,Op____,Op____ ;@ 3f38
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3f40
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3f48
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3f50
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f ;@ 3f58
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167 ;@ 3f60
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3f68
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3f70
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3f78
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3f80
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3f88
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3f90
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f ;@ 3f98
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7 ;@ 3fa0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 3fa8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 3fb0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 3fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3fc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3fc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3fd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3fd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3fe0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3fe8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3ff0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3ff8
  .long Op4000,Op4000,Op4000,Op4000,Op4000,Op4000,Op4000,Op4000 ;@ 4000
  .long Op4000,Op4000,Op4000,Op4000,Op4000,Op4000,Op4000,Op4000 ;@ 4008
  .long Op4010,Op4010,Op4010,Op4010,Op4010,Op4010,Op4010,Op4010 ;@ 4010
  .long Op4018,Op4018,Op4018,Op4018,Op4018,Op4018,Op4018,Op401f ;@ 4018
  .long Op4020,Op4020,Op4020,Op4020,Op4020,Op4020,Op4020,Op4027 ;@ 4020
  .long Op4028,Op4028,Op4028,Op4028,Op4028,Op4028,Op4028,Op4028 ;@ 4028
  .long Op4030,Op4030,Op4030,Op4030,Op4030,Op4030,Op4030,Op4030 ;@ 4030
  .long Op4038,Op4039,Op403a,Op403b,Op____,Op____,Op____,Op____ ;@ 4038
  .long Op4040,Op4040,Op4040,Op4040,Op4040,Op4040,Op4040,Op4040 ;@ 4040
  .long Op4040,Op4040,Op4040,Op4040,Op4040,Op4040,Op4040,Op4040 ;@ 4048
  .long Op4050,Op4050,Op4050,Op4050,Op4050,Op4050,Op4050,Op4050 ;@ 4050
  .long Op4058,Op4058,Op4058,Op4058,Op4058,Op4058,Op4058,Op405f ;@ 4058
  .long Op4060,Op4060,Op4060,Op4060,Op4060,Op4060,Op4060,Op4067 ;@ 4060
  .long Op4068,Op4068,Op4068,Op4068,Op4068,Op4068,Op4068,Op4068 ;@ 4068
  .long Op4070,Op4070,Op4070,Op4070,Op4070,Op4070,Op4070,Op4070 ;@ 4070
  .long Op4078,Op4079,Op407a,Op407b,Op____,Op____,Op____,Op____ ;@ 4078
  .long Op4080,Op4080,Op4080,Op4080,Op4080,Op4080,Op4080,Op4080 ;@ 4080
  .long Op4080,Op4080,Op4080,Op4080,Op4080,Op4080,Op4080,Op4080 ;@ 4088
  .long Op4090,Op4090,Op4090,Op4090,Op4090,Op4090,Op4090,Op4090 ;@ 4090
  .long Op4098,Op4098,Op4098,Op4098,Op4098,Op4098,Op4098,Op409f ;@ 4098
  .long Op40a0,Op40a0,Op40a0,Op40a0,Op40a0,Op40a0,Op40a0,Op40a7 ;@ 40a0
  .long Op40a8,Op40a8,Op40a8,Op40a8,Op40a8,Op40a8,Op40a8,Op40a8 ;@ 40a8
  .long Op40b0,Op40b0,Op40b0,Op40b0,Op40b0,Op40b0,Op40b0,Op40b0 ;@ 40b0
  .long Op40b8,Op40b9,Op40ba,Op40bb,Op____,Op____,Op____,Op____ ;@ 40b8
  .long Op40c0,Op40c0,Op40c0,Op40c0,Op40c0,Op40c0,Op40c0,Op40c0 ;@ 40c0
  .long Op40c0,Op40c0,Op40c0,Op40c0,Op40c0,Op40c0,Op40c0,Op40c0 ;@ 40c8
  .long Op40d0,Op40d0,Op40d0,Op40d0,Op40d0,Op40d0,Op40d0,Op40d0 ;@ 40d0
  .long Op40d8,Op40d8,Op40d8,Op40d8,Op40d8,Op40d8,Op40d8,Op40df ;@ 40d8
  .long Op40e0,Op40e0,Op40e0,Op40e0,Op40e0,Op40e0,Op40e0,Op40e7 ;@ 40e0
  .long Op40e8,Op40e8,Op40e8,Op40e8,Op40e8,Op40e8,Op40e8,Op40e8 ;@ 40e8
  .long Op40f0,Op40f0,Op40f0,Op40f0,Op40f0,Op40f0,Op40f0,Op40f0 ;@ 40f0
  .long Op40f8,Op40f9,Op40fa,Op40fb,Op____,Op____,Op____,Op____ ;@ 40f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4100
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4108
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4110
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4118
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4120
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4128
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4130
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4138
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4140
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4148
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4150
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4158
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4160
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4168
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4170
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4178
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4180
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4188
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4190
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4198
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 41a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 41a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 41b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 41b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 41c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 41c8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 41d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 41d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 41e0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 41e8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 41f0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 41f8
  .long Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200 ;@ 4200
  .long Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200 ;@ 4208
  .long Op4210,Op4210,Op4210,Op4210,Op4210,Op4210,Op4210,Op4210 ;@ 4210
  .long Op4218,Op4218,Op4218,Op4218,Op4218,Op4218,Op4218,Op421f ;@ 4218
  .long Op4220,Op4220,Op4220,Op4220,Op4220,Op4220,Op4220,Op4227 ;@ 4220
  .long Op4228,Op4228,Op4228,Op4228,Op4228,Op4228,Op4228,Op4228 ;@ 4228
  .long Op4230,Op4230,Op4230,Op4230,Op4230,Op4230,Op4230,Op4230 ;@ 4230
  .long Op4238,Op4239,Op423a,Op423b,Op____,Op____,Op____,Op____ ;@ 4238
  .long Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240 ;@ 4240
  .long Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240 ;@ 4248
  .long Op4250,Op4250,Op4250,Op4250,Op4250,Op4250,Op4250,Op4250 ;@ 4250
  .long Op4258,Op4258,Op4258,Op4258,Op4258,Op4258,Op4258,Op425f ;@ 4258
  .long Op4260,Op4260,Op4260,Op4260,Op4260,Op4260,Op4260,Op4267 ;@ 4260
  .long Op4268,Op4268,Op4268,Op4268,Op4268,Op4268,Op4268,Op4268 ;@ 4268
  .long Op4270,Op4270,Op4270,Op4270,Op4270,Op4270,Op4270,Op4270 ;@ 4270
  .long Op4278,Op4279,Op427a,Op427b,Op____,Op____,Op____,Op____ ;@ 4278
  .long Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280 ;@ 4280
  .long Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280 ;@ 4288
  .long Op4290,Op4290,Op4290,Op4290,Op4290,Op4290,Op4290,Op4290 ;@ 4290
  .long Op4298,Op4298,Op4298,Op4298,Op4298,Op4298,Op4298,Op429f ;@ 4298
  .long Op42a0,Op42a0,Op42a0,Op42a0,Op42a0,Op42a0,Op42a0,Op42a7 ;@ 42a0
  .long Op42a8,Op42a8,Op42a8,Op42a8,Op42a8,Op42a8,Op42a8,Op42a8 ;@ 42a8
  .long Op42b0,Op42b0,Op42b0,Op42b0,Op42b0,Op42b0,Op42b0,Op42b0 ;@ 42b0
  .long Op42b8,Op42b9,Op42ba,Op42bb,Op____,Op____,Op____,Op____ ;@ 42b8
  .long Op42c0,Op42c0,Op42c0,Op42c0,Op42c0,Op42c0,Op42c0,Op42c0 ;@ 42c0
  .long Op42c0,Op42c0,Op42c0,Op42c0,Op42c0,Op42c0,Op42c0,Op42c0 ;@ 42c8
  .long Op42d0,Op42d0,Op42d0,Op42d0,Op42d0,Op42d0,Op42d0,Op42d0 ;@ 42d0
  .long Op42d8,Op42d8,Op42d8,Op42d8,Op42d8,Op42d8,Op42d8,Op42df ;@ 42d8
  .long Op42e0,Op42e0,Op42e0,Op42e0,Op42e0,Op42e0,Op42e0,Op42e7 ;@ 42e0
  .long Op42e8,Op42e8,Op42e8,Op42e8,Op42e8,Op42e8,Op42e8,Op42e8 ;@ 42e8
  .long Op42f0,Op42f0,Op42f0,Op42f0,Op42f0,Op42f0,Op42f0,Op42f0 ;@ 42f0
  .long Op42f8,Op42f9,Op42fa,Op42fb,Op____,Op____,Op____,Op____ ;@ 42f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4300
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4308
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4310
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4318
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4320
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4328
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4330
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4338
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4340
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4348
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4350
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4358
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4360
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4368
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4370
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4378
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4380
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4388
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4390
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4398
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 43a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 43a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 43b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 43b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 43c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 43c8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 43d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 43d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 43e0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 43e8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 43f0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 43f8
  .long Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400 ;@ 4400
  .long Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400 ;@ 4408
  .long Op4410,Op4410,Op4410,Op4410,Op4410,Op4410,Op4410,Op4410 ;@ 4410
  .long Op4418,Op4418,Op4418,Op4418,Op4418,Op4418,Op4418,Op441f ;@ 4418
  .long Op4420,Op4420,Op4420,Op4420,Op4420,Op4420,Op4420,Op4427 ;@ 4420
  .long Op4428,Op4428,Op4428,Op4428,Op4428,Op4428,Op4428,Op4428 ;@ 4428
  .long Op4430,Op4430,Op4430,Op4430,Op4430,Op4430,Op4430,Op4430 ;@ 4430
  .long Op4438,Op4439,Op443a,Op443b,Op____,Op____,Op____,Op____ ;@ 4438
  .long Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440 ;@ 4440
  .long Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440 ;@ 4448
  .long Op4450,Op4450,Op4450,Op4450,Op4450,Op4450,Op4450,Op4450 ;@ 4450
  .long Op4458,Op4458,Op4458,Op4458,Op4458,Op4458,Op4458,Op445f ;@ 4458
  .long Op4460,Op4460,Op4460,Op4460,Op4460,Op4460,Op4460,Op4467 ;@ 4460
  .long Op4468,Op4468,Op4468,Op4468,Op4468,Op4468,Op4468,Op4468 ;@ 4468
  .long Op4470,Op4470,Op4470,Op4470,Op4470,Op4470,Op4470,Op4470 ;@ 4470
  .long Op4478,Op4479,Op447a,Op447b,Op____,Op____,Op____,Op____ ;@ 4478
  .long Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480 ;@ 4480
  .long Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480 ;@ 4488
  .long Op4490,Op4490,Op4490,Op4490,Op4490,Op4490,Op4490,Op4490 ;@ 4490
  .long Op4498,Op4498,Op4498,Op4498,Op4498,Op4498,Op4498,Op449f ;@ 4498
  .long Op44a0,Op44a0,Op44a0,Op44a0,Op44a0,Op44a0,Op44a0,Op44a7 ;@ 44a0
  .long Op44a8,Op44a8,Op44a8,Op44a8,Op44a8,Op44a8,Op44a8,Op44a8 ;@ 44a8
  .long Op44b0,Op44b0,Op44b0,Op44b0,Op44b0,Op44b0,Op44b0,Op44b0 ;@ 44b0
  .long Op44b8,Op44b9,Op44ba,Op44bb,Op____,Op____,Op____,Op____ ;@ 44b8
  .long Op44c0,Op44c0,Op44c0,Op44c0,Op44c0,Op44c0,Op44c0,Op44c0 ;@ 44c0
  .long Op44c0,Op44c0,Op44c0,Op44c0,Op44c0,Op44c0,Op44c0,Op44c0 ;@ 44c8
  .long Op44d0,Op44d0,Op44d0,Op44d0,Op44d0,Op44d0,Op44d0,Op44d0 ;@ 44d0
  .long Op44d8,Op44d8,Op44d8,Op44d8,Op44d8,Op44d8,Op44d8,Op44df ;@ 44d8
  .long Op44e0,Op44e0,Op44e0,Op44e0,Op44e0,Op44e0,Op44e0,Op44e7 ;@ 44e0
  .long Op44e8,Op44e8,Op44e8,Op44e8,Op44e8,Op44e8,Op44e8,Op44e8 ;@ 44e8
  .long Op44f0,Op44f0,Op44f0,Op44f0,Op44f0,Op44f0,Op44f0,Op44f0 ;@ 44f0
  .long Op44f8,Op44f9,Op44fa,Op44fb,Op44fc,Op____,Op____,Op____ ;@ 44f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4500
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4508
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4510
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4518
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4520
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4528
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4530
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4538
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4540
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4548
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4550
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4558
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4560
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4568
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4570
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4578
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4580
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4588
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4590
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4598
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 45a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 45a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 45b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 45b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 45c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 45c8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 45d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 45d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 45e0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 45e8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 45f0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 45f8
  .long Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600 ;@ 4600
  .long Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600 ;@ 4608
  .long Op4610,Op4610,Op4610,Op4610,Op4610,Op4610,Op4610,Op4610 ;@ 4610
  .long Op4618,Op4618,Op4618,Op4618,Op4618,Op4618,Op4618,Op461f ;@ 4618
  .long Op4620,Op4620,Op4620,Op4620,Op4620,Op4620,Op4620,Op4627 ;@ 4620
  .long Op4628,Op4628,Op4628,Op4628,Op4628,Op4628,Op4628,Op4628 ;@ 4628
  .long Op4630,Op4630,Op4630,Op4630,Op4630,Op4630,Op4630,Op4630 ;@ 4630
  .long Op4638,Op4639,Op463a,Op463b,Op____,Op____,Op____,Op____ ;@ 4638
  .long Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640 ;@ 4640
  .long Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640 ;@ 4648
  .long Op4650,Op4650,Op4650,Op4650,Op4650,Op4650,Op4650,Op4650 ;@ 4650
  .long Op4658,Op4658,Op4658,Op4658,Op4658,Op4658,Op4658,Op465f ;@ 4658
  .long Op4660,Op4660,Op4660,Op4660,Op4660,Op4660,Op4660,Op4667 ;@ 4660
  .long Op4668,Op4668,Op4668,Op4668,Op4668,Op4668,Op4668,Op4668 ;@ 4668
  .long Op4670,Op4670,Op4670,Op4670,Op4670,Op4670,Op4670,Op4670 ;@ 4670
  .long Op4678,Op4679,Op467a,Op467b,Op____,Op____,Op____,Op____ ;@ 4678
  .long Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680 ;@ 4680
  .long Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680 ;@ 4688
  .long Op4690,Op4690,Op4690,Op4690,Op4690,Op4690,Op4690,Op4690 ;@ 4690
  .long Op4698,Op4698,Op4698,Op4698,Op4698,Op4698,Op4698,Op469f ;@ 4698
  .long Op46a0,Op46a0,Op46a0,Op46a0,Op46a0,Op46a0,Op46a0,Op46a7 ;@ 46a0
  .long Op46a8,Op46a8,Op46a8,Op46a8,Op46a8,Op46a8,Op46a8,Op46a8 ;@ 46a8
  .long Op46b0,Op46b0,Op46b0,Op46b0,Op46b0,Op46b0,Op46b0,Op46b0 ;@ 46b0
  .long Op46b8,Op46b9,Op46ba,Op46bb,Op____,Op____,Op____,Op____ ;@ 46b8
  .long Op46c0,Op46c0,Op46c0,Op46c0,Op46c0,Op46c0,Op46c0,Op46c0 ;@ 46c0
  .long Op46c0,Op46c0,Op46c0,Op46c0,Op46c0,Op46c0,Op46c0,Op46c0 ;@ 46c8
  .long Op46d0,Op46d0,Op46d0,Op46d0,Op46d0,Op46d0,Op46d0,Op46d0 ;@ 46d0
  .long Op46d8,Op46d8,Op46d8,Op46d8,Op46d8,Op46d8,Op46d8,Op46df ;@ 46d8
  .long Op46e0,Op46e0,Op46e0,Op46e0,Op46e0,Op46e0,Op46e0,Op46e7 ;@ 46e0
  .long Op46e8,Op46e8,Op46e8,Op46e8,Op46e8,Op46e8,Op46e8,Op46e8 ;@ 46e8
  .long Op46f0,Op46f0,Op46f0,Op46f0,Op46f0,Op46f0,Op46f0,Op46f0 ;@ 46f0
  .long Op46f8,Op46f9,Op46fa,Op46fb,Op46fc,Op____,Op____,Op____ ;@ 46f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4700
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4708
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4710
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4718
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4720
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4728
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4730
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4738
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4740
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4748
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4750
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4758
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4760
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4768
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4770
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4778
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4780
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4788
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4790
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4798
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 47a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 47a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 47b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 47b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 47c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 47c8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 47d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 47d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 47e0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 47e8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 47f0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 47f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4800
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4808
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4810
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4818
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4820
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4828
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4830
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4838
  .long Op4840,Op4840,Op4840,Op4840,Op4840,Op4840,Op4840,Op4840 ;@ 4840
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4848
  .long Op4850,Op4850,Op4850,Op4850,Op4850,Op4850,Op4850,Op4850 ;@ 4850
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4858
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4860
  .long Op4868,Op4868,Op4868,Op4868,Op4868,Op4868,Op4868,Op4868 ;@ 4868
  .long Op4870,Op4870,Op4870,Op4870,Op4870,Op4870,Op4870,Op4870 ;@ 4870
  .long Op4878,Op4879,Op487a,Op487b,Op____,Op____,Op____,Op____ ;@ 4878
  .long Op4880,Op4880,Op4880,Op4880,Op4880,Op4880,Op4880,Op4880 ;@ 4880
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4888
  .long Op4890,Op4890,Op4890,Op4890,Op4890,Op4890,Op4890,Op4890 ;@ 4890
  .long Op4898,Op4898,Op4898,Op4898,Op4898,Op4898,Op4898,Op489f ;@ 4898
  .long Op48a0,Op48a0,Op48a0,Op48a0,Op48a0,Op48a0,Op48a0,Op48a7 ;@ 48a0
  .long Op48a8,Op48a8,Op48a8,Op48a8,Op48a8,Op48a8,Op48a8,Op48a8 ;@ 48a8
  .long Op48b0,Op48b0,Op48b0,Op48b0,Op48b0,Op48b0,Op48b0,Op48b0 ;@ 48b0
  .long Op48b8,Op48b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 48b8
  .long Op48c0,Op48c0,Op48c0,Op48c0,Op48c0,Op48c0,Op48c0,Op48c0 ;@ 48c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 48c8
  .long Op48d0,Op48d0,Op48d0,Op48d0,Op48d0,Op48d0,Op48d0,Op48d0 ;@ 48d0
  .long Op48d8,Op48d8,Op48d8,Op48d8,Op48d8,Op48d8,Op48d8,Op48df ;@ 48d8
  .long Op48e0,Op48e0,Op48e0,Op48e0,Op48e0,Op48e0,Op48e0,Op48e7 ;@ 48e0
  .long Op48e8,Op48e8,Op48e8,Op48e8,Op48e8,Op48e8,Op48e8,Op48e8 ;@ 48e8
  .long Op48f0,Op48f0,Op48f0,Op48f0,Op48f0,Op48f0,Op48f0,Op48f0 ;@ 48f0
  .long Op48f8,Op48f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 48f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4900
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4908
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4910
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4918
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4920
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4928
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4930
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4938
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4940
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4948
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4950
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4958
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4960
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4968
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4970
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4978
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4980
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4988
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4990
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4998
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 49a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 49a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 49b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 49b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 49c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 49c8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 49d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 49d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 49e0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 49e8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 49f0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 49f8
  .long Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00 ;@ 4a00
  .long Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00 ;@ 4a08
  .long Op4a10,Op4a10,Op4a10,Op4a10,Op4a10,Op4a10,Op4a10,Op4a10 ;@ 4a10
  .long Op4a18,Op4a18,Op4a18,Op4a18,Op4a18,Op4a18,Op4a18,Op4a1f ;@ 4a18
  .long Op4a20,Op4a20,Op4a20,Op4a20,Op4a20,Op4a20,Op4a20,Op4a27 ;@ 4a20
  .long Op4a28,Op4a28,Op4a28,Op4a28,Op4a28,Op4a28,Op4a28,Op4a28 ;@ 4a28
  .long Op4a30,Op4a30,Op4a30,Op4a30,Op4a30,Op4a30,Op4a30,Op4a30 ;@ 4a30
  .long Op4a38,Op4a39,Op4a3a,Op4a3b,Op____,Op____,Op____,Op____ ;@ 4a38
  .long Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40 ;@ 4a40
  .long Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40 ;@ 4a48
  .long Op4a50,Op4a50,Op4a50,Op4a50,Op4a50,Op4a50,Op4a50,Op4a50 ;@ 4a50
  .long Op4a58,Op4a58,Op4a58,Op4a58,Op4a58,Op4a58,Op4a58,Op4a5f ;@ 4a58
  .long Op4a60,Op4a60,Op4a60,Op4a60,Op4a60,Op4a60,Op4a60,Op4a67 ;@ 4a60
  .long Op4a68,Op4a68,Op4a68,Op4a68,Op4a68,Op4a68,Op4a68,Op4a68 ;@ 4a68
  .long Op4a70,Op4a70,Op4a70,Op4a70,Op4a70,Op4a70,Op4a70,Op4a70 ;@ 4a70
  .long Op4a78,Op4a79,Op4a7a,Op4a7b,Op____,Op____,Op____,Op____ ;@ 4a78
  .long Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80 ;@ 4a80
  .long Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80 ;@ 4a88
  .long Op4a90,Op4a90,Op4a90,Op4a90,Op4a90,Op4a90,Op4a90,Op4a90 ;@ 4a90
  .long Op4a98,Op4a98,Op4a98,Op4a98,Op4a98,Op4a98,Op4a98,Op4a9f ;@ 4a98
  .long Op4aa0,Op4aa0,Op4aa0,Op4aa0,Op4aa0,Op4aa0,Op4aa0,Op4aa7 ;@ 4aa0
  .long Op4aa8,Op4aa8,Op4aa8,Op4aa8,Op4aa8,Op4aa8,Op4aa8,Op4aa8 ;@ 4aa8
  .long Op4ab0,Op4ab0,Op4ab0,Op4ab0,Op4ab0,Op4ab0,Op4ab0,Op4ab0 ;@ 4ab0
  .long Op4ab8,Op4ab9,Op4aba,Op4abb,Op____,Op____,Op____,Op____ ;@ 4ab8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ac0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ac8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ad0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ad8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ae0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ae8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4af0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4af8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b88
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b90
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ba0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ba8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4bb0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4bc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4bc8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 4bd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4bd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4be0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 4be8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 4bf0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 4bf8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c88
  .long Op4c90,Op4c90,Op4c90,Op4c90,Op4c90,Op4c90,Op4c90,Op4c90 ;@ 4c90
  .long Op4c98,Op4c98,Op4c98,Op4c98,Op4c98,Op4c98,Op4c98,Op4c9f ;@ 4c98
  .long Op4ca0,Op4ca0,Op4ca0,Op4ca0,Op4ca0,Op4ca0,Op4ca0,Op4ca7 ;@ 4ca0
  .long Op4ca8,Op4ca8,Op4ca8,Op4ca8,Op4ca8,Op4ca8,Op4ca8,Op4ca8 ;@ 4ca8
  .long Op4cb0,Op4cb0,Op4cb0,Op4cb0,Op4cb0,Op4cb0,Op4cb0,Op4cb0 ;@ 4cb0
  .long Op4cb8,Op4cb9,Op4cba,Op4cbb,Op____,Op____,Op____,Op____ ;@ 4cb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4cc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4cc8
  .long Op4cd0,Op4cd0,Op4cd0,Op4cd0,Op4cd0,Op4cd0,Op4cd0,Op4cd0 ;@ 4cd0
  .long Op4cd8,Op4cd8,Op4cd8,Op4cd8,Op4cd8,Op4cd8,Op4cd8,Op4cdf ;@ 4cd8
  .long Op4ce0,Op4ce0,Op4ce0,Op4ce0,Op4ce0,Op4ce0,Op4ce0,Op4ce7 ;@ 4ce0
  .long Op4ce8,Op4ce8,Op4ce8,Op4ce8,Op4ce8,Op4ce8,Op4ce8,Op4ce8 ;@ 4ce8
  .long Op4cf0,Op4cf0,Op4cf0,Op4cf0,Op4cf0,Op4cf0,Op4cf0,Op4cf0 ;@ 4cf0
  .long Op4cf8,Op4cf9,Op4cfa,Op4cfb,Op____,Op____,Op____,Op____ ;@ 4cf8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d88
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d90
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4da0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4da8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4db0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4dc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4dc8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 4dd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4dd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4de0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 4de8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 4df0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 4df8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e38
  .long Op4e40,Op4e40,Op4e40,Op4e40,Op4e40,Op4e40,Op4e40,Op4e40 ;@ 4e40
  .long Op4e40,Op4e40,Op4e40,Op4e40,Op4e40,Op4e40,Op4e40,Op4e40 ;@ 4e48
  .long Op4e50,Op4e50,Op4e50,Op4e50,Op4e50,Op4e50,Op4e50,Op4e50 ;@ 4e50
  .long Op4e58,Op4e58,Op4e58,Op4e58,Op4e58,Op4e58,Op4e58,Op4e58 ;@ 4e58
  .long Op4e60,Op4e60,Op4e60,Op4e60,Op4e60,Op4e60,Op4e60,Op4e60 ;@ 4e60
  .long Op4e68,Op4e68,Op4e68,Op4e68,Op4e68,Op4e68,Op4e68,Op4e68 ;@ 4e68
  .long Op4e70,Op4e71,Op4e72,Op4e73,Op____,Op4e75,Op____,Op4e77 ;@ 4e70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e88
  .long Op4e90,Op4e90,Op4e90,Op4e90,Op4e90,Op4e90,Op4e90,Op4e90 ;@ 4e90
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ea0
  .long Op4ea8,Op4ea8,Op4ea8,Op4ea8,Op4ea8,Op4ea8,Op4ea8,Op4ea8 ;@ 4ea8
  .long Op4eb0,Op4eb0,Op4eb0,Op4eb0,Op4eb0,Op4eb0,Op4eb0,Op4eb0 ;@ 4eb0
  .long Op4eb8,Op4eb9,Op4eba,Op4ebb,Op____,Op____,Op____,Op____ ;@ 4eb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ec0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ec8
  .long Op4ed0,Op4ed0,Op4ed0,Op4ed0,Op4ed0,Op4ed0,Op4ed0,Op4ed0 ;@ 4ed0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ed8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ee0
  .long Op4ee8,Op4ee8,Op4ee8,Op4ee8,Op4ee8,Op4ee8,Op4ee8,Op4ee8 ;@ 4ee8
  .long Op4ef0,Op4ef0,Op4ef0,Op4ef0,Op4ef0,Op4ef0,Op4ef0,Op4ef0 ;@ 4ef0
  .long Op4ef8,Op4ef9,Op4efa,Op4efb,Op____,Op____,Op____,Op____ ;@ 4ef8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f88
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f90
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4fa0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4fa8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4fb0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4fc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4fc8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 4fd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4fd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4fe0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 4fe8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 4ff0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 4ff8
  .long Op5000,Op5000,Op5000,Op5000,Op5000,Op5000,Op5000,Op5000 ;@ 5000
  .long Op5008,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008 ;@ 5008
  .long Op5010,Op5010,Op5010,Op5010,Op5010,Op5010,Op5010,Op5010 ;@ 5010
  .long Op5018,Op5018,Op5018,Op5018,Op5018,Op5018,Op5018,Op5018 ;@ 5018
  .long Op5020,Op5020,Op5020,Op5020,Op5020,Op5020,Op5020,Op5020 ;@ 5020
  .long Op5028,Op5028,Op5028,Op5028,Op5028,Op5028,Op5028,Op5028 ;@ 5028
  .long Op5030,Op5030,Op5030,Op5030,Op5030,Op5030,Op5030,Op5030 ;@ 5030
  .long Op5038,Op5039,Op503a,Op503b,Op____,Op____,Op____,Op____ ;@ 5038
  .long Op5040,Op5040,Op5040,Op5040,Op5040,Op5040,Op5040,Op5040 ;@ 5040
  .long Op5008,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008 ;@ 5048
  .long Op5050,Op5050,Op5050,Op5050,Op5050,Op5050,Op5050,Op5050 ;@ 5050
  .long Op5058,Op5058,Op5058,Op5058,Op5058,Op5058,Op5058,Op5058 ;@ 5058
  .long Op5060,Op5060,Op5060,Op5060,Op5060,Op5060,Op5060,Op5060 ;@ 5060
  .long Op5068,Op5068,Op5068,Op5068,Op5068,Op5068,Op5068,Op5068 ;@ 5068
  .long Op5070,Op5070,Op5070,Op5070,Op5070,Op5070,Op5070,Op5070 ;@ 5070
  .long Op5078,Op5079,Op507a,Op507b,Op____,Op____,Op____,Op____ ;@ 5078
  .long Op5080,Op5080,Op5080,Op5080,Op5080,Op5080,Op5080,Op5080 ;@ 5080
  .long Op5008,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008 ;@ 5088
  .long Op5090,Op5090,Op5090,Op5090,Op5090,Op5090,Op5090,Op5090 ;@ 5090
  .long Op5098,Op5098,Op5098,Op5098,Op5098,Op5098,Op5098,Op5098 ;@ 5098
  .long Op50a0,Op50a0,Op50a0,Op50a0,Op50a0,Op50a0,Op50a0,Op50a0 ;@ 50a0
  .long Op50a8,Op50a8,Op50a8,Op50a8,Op50a8,Op50a8,Op50a8,Op50a8 ;@ 50a8
  .long Op50b0,Op50b0,Op50b0,Op50b0,Op50b0,Op50b0,Op50b0,Op50b0 ;@ 50b0
  .long Op50b8,Op50b9,Op50ba,Op50bb,Op____,Op____,Op____,Op____ ;@ 50b8
  .long Op50c0,Op50c0,Op50c0,Op50c0,Op50c0,Op50c0,Op50c0,Op50c0 ;@ 50c0
  .long Op50c8,Op50c8,Op50c8,Op50c8,Op50c8,Op50c8,Op50c8,Op50c8 ;@ 50c8
  .long Op50d0,Op50d0,Op50d0,Op50d0,Op50d0,Op50d0,Op50d0,Op50d0 ;@ 50d0
  .long Op50d8,Op50d8,Op50d8,Op50d8,Op50d8,Op50d8,Op50d8,Op50df ;@ 50d8
  .long Op50e0,Op50e0,Op50e0,Op50e0,Op50e0,Op50e0,Op50e0,Op50e7 ;@ 50e0
  .long Op50e8,Op50e8,Op50e8,Op50e8,Op50e8,Op50e8,Op50e8,Op50e8 ;@ 50e8
  .long Op50f0,Op50f0,Op50f0,Op50f0,Op50f0,Op50f0,Op50f0,Op50f0 ;@ 50f0
  .long Op50f8,Op50f9,Op50fa,Op50fb,Op____,Op____,Op____,Op____ ;@ 50f8
  .long Op5100,Op5100,Op5100,Op5100,Op5100,Op5100,Op5100,Op5100 ;@ 5100
  .long Op5108,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108 ;@ 5108
  .long Op5110,Op5110,Op5110,Op5110,Op5110,Op5110,Op5110,Op5110 ;@ 5110
  .long Op5118,Op5118,Op5118,Op5118,Op5118,Op5118,Op5118,Op5118 ;@ 5118
  .long Op5120,Op5120,Op5120,Op5120,Op5120,Op5120,Op5120,Op5120 ;@ 5120
  .long Op5128,Op5128,Op5128,Op5128,Op5128,Op5128,Op5128,Op5128 ;@ 5128
  .long Op5130,Op5130,Op5130,Op5130,Op5130,Op5130,Op5130,Op5130 ;@ 5130
  .long Op5138,Op5139,Op513a,Op513b,Op____,Op____,Op____,Op____ ;@ 5138
  .long Op5140,Op5140,Op5140,Op5140,Op5140,Op5140,Op5140,Op5140 ;@ 5140
  .long Op5108,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108 ;@ 5148
  .long Op5150,Op5150,Op5150,Op5150,Op5150,Op5150,Op5150,Op5150 ;@ 5150
  .long Op5158,Op5158,Op5158,Op5158,Op5158,Op5158,Op5158,Op5158 ;@ 5158
  .long Op5160,Op5160,Op5160,Op5160,Op5160,Op5160,Op5160,Op5160 ;@ 5160
  .long Op5168,Op5168,Op5168,Op5168,Op5168,Op5168,Op5168,Op5168 ;@ 5168
  .long Op5170,Op5170,Op5170,Op5170,Op5170,Op5170,Op5170,Op5170 ;@ 5170
  .long Op5178,Op5179,Op517a,Op517b,Op____,Op____,Op____,Op____ ;@ 5178
  .long Op5180,Op5180,Op5180,Op5180,Op5180,Op5180,Op5180,Op5180 ;@ 5180
  .long Op5108,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108 ;@ 5188
  .long Op5190,Op5190,Op5190,Op5190,Op5190,Op5190,Op5190,Op5190 ;@ 5190
  .long Op5198,Op5198,Op5198,Op5198,Op5198,Op5198,Op5198,Op5198 ;@ 5198
  .long Op51a0,Op51a0,Op51a0,Op51a0,Op51a0,Op51a0,Op51a0,Op51a0 ;@ 51a0
  .long Op51a8,Op51a8,Op51a8,Op51a8,Op51a8,Op51a8,Op51a8,Op51a8 ;@ 51a8
  .long Op51b0,Op51b0,Op51b0,Op51b0,Op51b0,Op51b0,Op51b0,Op51b0 ;@ 51b0
  .long Op51b8,Op51b9,Op51ba,Op51bb,Op____,Op____,Op____,Op____ ;@ 51b8
  .long Op51c0,Op51c0,Op51c0,Op51c0,Op51c0,Op51c0,Op51c0,Op51c0 ;@ 51c0
  .long Op51c8,Op51c8,Op51c8,Op51c8,Op51c8,Op51c8,Op51c8,Op51c8 ;@ 51c8
  .long Op51d0,Op51d0,Op51d0,Op51d0,Op51d0,Op51d0,Op51d0,Op51d0 ;@ 51d0
  .long Op51d8,Op51d8,Op51d8,Op51d8,Op51d8,Op51d8,Op51d8,Op51df ;@ 51d8
  .long Op51e0,Op51e0,Op51e0,Op51e0,Op51e0,Op51e0,Op51e0,Op51e7 ;@ 51e0
  .long Op51e8,Op51e8,Op51e8,Op51e8,Op51e8,Op51e8,Op51e8,Op51e8 ;@ 51e8
  .long Op51f0,Op51f0,Op51f0,Op51f0,Op51f0,Op51f0,Op51f0,Op51f0 ;@ 51f0
  .long Op51f8,Op51f9,Op51fa,Op51fb,Op____,Op____,Op____,Op____ ;@ 51f8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5200
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5208
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5210
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18 ;@ 5218
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20 ;@ 5220
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5228
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5230
  .long Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____ ;@ 5238
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5240
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5248
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5250
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5258
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5260
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5268
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5270
  .long Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____ ;@ 5278
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5280
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5288
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5290
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5298
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 52a0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 52a8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 52b0
  .long Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____ ;@ 52b8
  .long Op52c0,Op52c0,Op52c0,Op52c0,Op52c0,Op52c0,Op52c0,Op52c0 ;@ 52c0
  .long Op52c8,Op52c8,Op52c8,Op52c8,Op52c8,Op52c8,Op52c8,Op52c8 ;@ 52c8
  .long Op52d0,Op52d0,Op52d0,Op52d0,Op52d0,Op52d0,Op52d0,Op52d0 ;@ 52d0
  .long Op52d8,Op52d8,Op52d8,Op52d8,Op52d8,Op52d8,Op52d8,Op52df ;@ 52d8
  .long Op52e0,Op52e0,Op52e0,Op52e0,Op52e0,Op52e0,Op52e0,Op52e7 ;@ 52e0
  .long Op52e8,Op52e8,Op52e8,Op52e8,Op52e8,Op52e8,Op52e8,Op52e8 ;@ 52e8
  .long Op52f0,Op52f0,Op52f0,Op52f0,Op52f0,Op52f0,Op52f0,Op52f0 ;@ 52f0
  .long Op52f8,Op52f9,Op52fa,Op52fb,Op____,Op____,Op____,Op____ ;@ 52f8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5300
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5308
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5310
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18 ;@ 5318
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20 ;@ 5320
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5328
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5330
  .long Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____ ;@ 5338
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5340
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5348
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5350
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5358
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5360
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5368
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5370
  .long Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____ ;@ 5378
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5380
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5388
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5390
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5398
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 53a0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 53a8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 53b0
  .long Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____ ;@ 53b8
  .long Op53c0,Op53c0,Op53c0,Op53c0,Op53c0,Op53c0,Op53c0,Op53c0 ;@ 53c0
  .long Op53c8,Op53c8,Op53c8,Op53c8,Op53c8,Op53c8,Op53c8,Op53c8 ;@ 53c8
  .long Op53d0,Op53d0,Op53d0,Op53d0,Op53d0,Op53d0,Op53d0,Op53d0 ;@ 53d0
  .long Op53d8,Op53d8,Op53d8,Op53d8,Op53d8,Op53d8,Op53d8,Op53df ;@ 53d8
  .long Op53e0,Op53e0,Op53e0,Op53e0,Op53e0,Op53e0,Op53e0,Op53e7 ;@ 53e0
  .long Op53e8,Op53e8,Op53e8,Op53e8,Op53e8,Op53e8,Op53e8,Op53e8 ;@ 53e8
  .long Op53f0,Op53f0,Op53f0,Op53f0,Op53f0,Op53f0,Op53f0,Op53f0 ;@ 53f0
  .long Op53f8,Op53f9,Op53fa,Op53fb,Op____,Op____,Op____,Op____ ;@ 53f8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5400
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5408
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5410
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18 ;@ 5418
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20 ;@ 5420
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5428
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5430
  .long Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____ ;@ 5438
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5440
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5448
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5450
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5458
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5460
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5468
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5470
  .long Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____ ;@ 5478
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5480
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5488
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5490
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5498
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 54a0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 54a8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 54b0
  .long Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____ ;@ 54b8
  .long Op54c0,Op54c0,Op54c0,Op54c0,Op54c0,Op54c0,Op54c0,Op54c0 ;@ 54c0
  .long Op54c8,Op54c8,Op54c8,Op54c8,Op54c8,Op54c8,Op54c8,Op54c8 ;@ 54c8
  .long Op54d0,Op54d0,Op54d0,Op54d0,Op54d0,Op54d0,Op54d0,Op54d0 ;@ 54d0
  .long Op54d8,Op54d8,Op54d8,Op54d8,Op54d8,Op54d8,Op54d8,Op54df ;@ 54d8
  .long Op54e0,Op54e0,Op54e0,Op54e0,Op54e0,Op54e0,Op54e0,Op54e7 ;@ 54e0
  .long Op54e8,Op54e8,Op54e8,Op54e8,Op54e8,Op54e8,Op54e8,Op54e8 ;@ 54e8
  .long Op54f0,Op54f0,Op54f0,Op54f0,Op54f0,Op54f0,Op54f0,Op54f0 ;@ 54f0
  .long Op54f8,Op54f9,Op54fa,Op54fb,Op____,Op____,Op____,Op____ ;@ 54f8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5500
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5508
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5510
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18 ;@ 5518
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20 ;@ 5520
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5528
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5530
  .long Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____ ;@ 5538
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5540
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5548
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5550
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5558
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5560
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5568
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5570
  .long Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____ ;@ 5578
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5580
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5588
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5590
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5598
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 55a0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 55a8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 55b0
  .long Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____ ;@ 55b8
  .long Op55c0,Op55c0,Op55c0,Op55c0,Op55c0,Op55c0,Op55c0,Op55c0 ;@ 55c0
  .long Op55c8,Op55c8,Op55c8,Op55c8,Op55c8,Op55c8,Op55c8,Op55c8 ;@ 55c8
  .long Op55d0,Op55d0,Op55d0,Op55d0,Op55d0,Op55d0,Op55d0,Op55d0 ;@ 55d0
  .long Op55d8,Op55d8,Op55d8,Op55d8,Op55d8,Op55d8,Op55d8,Op55df ;@ 55d8
  .long Op55e0,Op55e0,Op55e0,Op55e0,Op55e0,Op55e0,Op55e0,Op55e7 ;@ 55e0
  .long Op55e8,Op55e8,Op55e8,Op55e8,Op55e8,Op55e8,Op55e8,Op55e8 ;@ 55e8
  .long Op55f0,Op55f0,Op55f0,Op55f0,Op55f0,Op55f0,Op55f0,Op55f0 ;@ 55f0
  .long Op55f8,Op55f9,Op55fa,Op55fb,Op____,Op____,Op____,Op____ ;@ 55f8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5600
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5608
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5610
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18 ;@ 5618
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20 ;@ 5620
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5628
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5630
  .long Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____ ;@ 5638
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5640
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5648
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5650
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5658
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5660
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5668
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5670
  .long Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____ ;@ 5678
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5680
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5688
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5690
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5698
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 56a0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 56a8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 56b0
  .long Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____ ;@ 56b8
  .long Op56c0,Op56c0,Op56c0,Op56c0,Op56c0,Op56c0,Op56c0,Op56c0 ;@ 56c0
  .long Op56c8,Op56c8,Op56c8,Op56c8,Op56c8,Op56c8,Op56c8,Op56c8 ;@ 56c8
  .long Op56d0,Op56d0,Op56d0,Op56d0,Op56d0,Op56d0,Op56d0,Op56d0 ;@ 56d0
  .long Op56d8,Op56d8,Op56d8,Op56d8,Op56d8,Op56d8,Op56d8,Op56df ;@ 56d8
  .long Op56e0,Op56e0,Op56e0,Op56e0,Op56e0,Op56e0,Op56e0,Op56e7 ;@ 56e0
  .long Op56e8,Op56e8,Op56e8,Op56e8,Op56e8,Op56e8,Op56e8,Op56e8 ;@ 56e8
  .long Op56f0,Op56f0,Op56f0,Op56f0,Op56f0,Op56f0,Op56f0,Op56f0 ;@ 56f0
  .long Op56f8,Op56f9,Op56fa,Op56fb,Op____,Op____,Op____,Op____ ;@ 56f8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5700
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5708
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5710
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18 ;@ 5718
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20 ;@ 5720
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5728
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5730
  .long Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____ ;@ 5738
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5740
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5748
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5750
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5758
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5760
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5768
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5770
  .long Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____ ;@ 5778
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5780
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5788
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5790
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5798
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 57a0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 57a8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 57b0
  .long Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____ ;@ 57b8
  .long Op57c0,Op57c0,Op57c0,Op57c0,Op57c0,Op57c0,Op57c0,Op57c0 ;@ 57c0
  .long Op57c8,Op57c8,Op57c8,Op57c8,Op57c8,Op57c8,Op57c8,Op57c8 ;@ 57c8
  .long Op57d0,Op57d0,Op57d0,Op57d0,Op57d0,Op57d0,Op57d0,Op57d0 ;@ 57d0
  .long Op57d8,Op57d8,Op57d8,Op57d8,Op57d8,Op57d8,Op57d8,Op57df ;@ 57d8
  .long Op57e0,Op57e0,Op57e0,Op57e0,Op57e0,Op57e0,Op57e0,Op57e7 ;@ 57e0
  .long Op57e8,Op57e8,Op57e8,Op57e8,Op57e8,Op57e8,Op57e8,Op57e8 ;@ 57e8
  .long Op57f0,Op57f0,Op57f0,Op57f0,Op57f0,Op57f0,Op57f0,Op57f0 ;@ 57f0
  .long Op57f8,Op57f9,Op57fa,Op57fb,Op____,Op____,Op____,Op____ ;@ 57f8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5800
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5808
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5810
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18 ;@ 5818
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20 ;@ 5820
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5828
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5830
  .long Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____ ;@ 5838
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5840
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5848
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5850
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5858
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5860
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5868
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5870
  .long Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____ ;@ 5878
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5880
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5888
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5890
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5898
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 58a0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 58a8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 58b0
  .long Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____ ;@ 58b8
  .long Op58c0,Op58c0,Op58c0,Op58c0,Op58c0,Op58c0,Op58c0,Op58c0 ;@ 58c0
  .long Op58c8,Op58c8,Op58c8,Op58c8,Op58c8,Op58c8,Op58c8,Op58c8 ;@ 58c8
  .long Op58d0,Op58d0,Op58d0,Op58d0,Op58d0,Op58d0,Op58d0,Op58d0 ;@ 58d0
  .long Op58d8,Op58d8,Op58d8,Op58d8,Op58d8,Op58d8,Op58d8,Op58df ;@ 58d8
  .long Op58e0,Op58e0,Op58e0,Op58e0,Op58e0,Op58e0,Op58e0,Op58e7 ;@ 58e0
  .long Op58e8,Op58e8,Op58e8,Op58e8,Op58e8,Op58e8,Op58e8,Op58e8 ;@ 58e8
  .long Op58f0,Op58f0,Op58f0,Op58f0,Op58f0,Op58f0,Op58f0,Op58f0 ;@ 58f0
  .long Op58f8,Op58f9,Op58fa,Op58fb,Op____,Op____,Op____,Op____ ;@ 58f8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5900
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5908
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5910
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18 ;@ 5918
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20 ;@ 5920
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5928
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5930
  .long Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____ ;@ 5938
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5940
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5948
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5950
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5958
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5960
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5968
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5970
  .long Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____ ;@ 5978
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5980
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5988
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5990
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5998
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 59a0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 59a8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 59b0
  .long Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____ ;@ 59b8
  .long Op59c0,Op59c0,Op59c0,Op59c0,Op59c0,Op59c0,Op59c0,Op59c0 ;@ 59c0
  .long Op59c8,Op59c8,Op59c8,Op59c8,Op59c8,Op59c8,Op59c8,Op59c8 ;@ 59c8
  .long Op59d0,Op59d0,Op59d0,Op59d0,Op59d0,Op59d0,Op59d0,Op59d0 ;@ 59d0
  .long Op59d8,Op59d8,Op59d8,Op59d8,Op59d8,Op59d8,Op59d8,Op59df ;@ 59d8
  .long Op59e0,Op59e0,Op59e0,Op59e0,Op59e0,Op59e0,Op59e0,Op59e7 ;@ 59e0
  .long Op59e8,Op59e8,Op59e8,Op59e8,Op59e8,Op59e8,Op59e8,Op59e8 ;@ 59e8
  .long Op59f0,Op59f0,Op59f0,Op59f0,Op59f0,Op59f0,Op59f0,Op59f0 ;@ 59f0
  .long Op59f8,Op59f9,Op59fa,Op59fb,Op____,Op____,Op____,Op____ ;@ 59f8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5a00
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5a08
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5a10
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18 ;@ 5a18
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20 ;@ 5a20
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5a28
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5a30
  .long Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____ ;@ 5a38
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5a40
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5a48
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5a50
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5a58
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5a60
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5a68
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5a70
  .long Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____ ;@ 5a78
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5a80
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5a88
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5a90
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5a98
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 5aa0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 5aa8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 5ab0
  .long Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____ ;@ 5ab8
  .long Op5ac0,Op5ac0,Op5ac0,Op5ac0,Op5ac0,Op5ac0,Op5ac0,Op5ac0 ;@ 5ac0
  .long Op5ac8,Op5ac8,Op5ac8,Op5ac8,Op5ac8,Op5ac8,Op5ac8,Op5ac8 ;@ 5ac8
  .long Op5ad0,Op5ad0,Op5ad0,Op5ad0,Op5ad0,Op5ad0,Op5ad0,Op5ad0 ;@ 5ad0
  .long Op5ad8,Op5ad8,Op5ad8,Op5ad8,Op5ad8,Op5ad8,Op5ad8,Op5adf ;@ 5ad8
  .long Op5ae0,Op5ae0,Op5ae0,Op5ae0,Op5ae0,Op5ae0,Op5ae0,Op5ae7 ;@ 5ae0
  .long Op5ae8,Op5ae8,Op5ae8,Op5ae8,Op5ae8,Op5ae8,Op5ae8,Op5ae8 ;@ 5ae8
  .long Op5af0,Op5af0,Op5af0,Op5af0,Op5af0,Op5af0,Op5af0,Op5af0 ;@ 5af0
  .long Op5af8,Op5af9,Op5afa,Op5afb,Op____,Op____,Op____,Op____ ;@ 5af8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5b00
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5b08
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5b10
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18 ;@ 5b18
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20 ;@ 5b20
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5b28
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5b30
  .long Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____ ;@ 5b38
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5b40
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5b48
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5b50
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5b58
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5b60
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5b68
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5b70
  .long Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____ ;@ 5b78
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5b80
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5b88
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5b90
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5b98
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 5ba0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 5ba8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 5bb0
  .long Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____ ;@ 5bb8
  .long Op5bc0,Op5bc0,Op5bc0,Op5bc0,Op5bc0,Op5bc0,Op5bc0,Op5bc0 ;@ 5bc0
  .long Op5bc8,Op5bc8,Op5bc8,Op5bc8,Op5bc8,Op5bc8,Op5bc8,Op5bc8 ;@ 5bc8
  .long Op5bd0,Op5bd0,Op5bd0,Op5bd0,Op5bd0,Op5bd0,Op5bd0,Op5bd0 ;@ 5bd0
  .long Op5bd8,Op5bd8,Op5bd8,Op5bd8,Op5bd8,Op5bd8,Op5bd8,Op5bdf ;@ 5bd8
  .long Op5be0,Op5be0,Op5be0,Op5be0,Op5be0,Op5be0,Op5be0,Op5be7 ;@ 5be0
  .long Op5be8,Op5be8,Op5be8,Op5be8,Op5be8,Op5be8,Op5be8,Op5be8 ;@ 5be8
  .long Op5bf0,Op5bf0,Op5bf0,Op5bf0,Op5bf0,Op5bf0,Op5bf0,Op5bf0 ;@ 5bf0
  .long Op5bf8,Op5bf9,Op5bfa,Op5bfb,Op____,Op____,Op____,Op____ ;@ 5bf8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5c00
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5c08
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5c10
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18 ;@ 5c18
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20 ;@ 5c20
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5c28
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5c30
  .long Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____ ;@ 5c38
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5c40
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5c48
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5c50
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5c58
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5c60
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5c68
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5c70
  .long Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____ ;@ 5c78
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5c80
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5c88
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5c90
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5c98
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 5ca0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 5ca8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 5cb0
  .long Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____ ;@ 5cb8
  .long Op5cc0,Op5cc0,Op5cc0,Op5cc0,Op5cc0,Op5cc0,Op5cc0,Op5cc0 ;@ 5cc0
  .long Op5cc8,Op5cc8,Op5cc8,Op5cc8,Op5cc8,Op5cc8,Op5cc8,Op5cc8 ;@ 5cc8
  .long Op5cd0,Op5cd0,Op5cd0,Op5cd0,Op5cd0,Op5cd0,Op5cd0,Op5cd0 ;@ 5cd0
  .long Op5cd8,Op5cd8,Op5cd8,Op5cd8,Op5cd8,Op5cd8,Op5cd8,Op5cdf ;@ 5cd8
  .long Op5ce0,Op5ce0,Op5ce0,Op5ce0,Op5ce0,Op5ce0,Op5ce0,Op5ce7 ;@ 5ce0
  .long Op5ce8,Op5ce8,Op5ce8,Op5ce8,Op5ce8,Op5ce8,Op5ce8,Op5ce8 ;@ 5ce8
  .long Op5cf0,Op5cf0,Op5cf0,Op5cf0,Op5cf0,Op5cf0,Op5cf0,Op5cf0 ;@ 5cf0
  .long Op5cf8,Op5cf9,Op5cfa,Op5cfb,Op____,Op____,Op____,Op____ ;@ 5cf8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5d00
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5d08
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5d10
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18 ;@ 5d18
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20 ;@ 5d20
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5d28
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5d30
  .long Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____ ;@ 5d38
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5d40
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5d48
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5d50
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5d58
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5d60
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5d68
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5d70
  .long Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____ ;@ 5d78
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5d80
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5d88
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5d90
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5d98
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 5da0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 5da8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 5db0
  .long Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____ ;@ 5db8
  .long Op5dc0,Op5dc0,Op5dc0,Op5dc0,Op5dc0,Op5dc0,Op5dc0,Op5dc0 ;@ 5dc0
  .long Op5dc8,Op5dc8,Op5dc8,Op5dc8,Op5dc8,Op5dc8,Op5dc8,Op5dc8 ;@ 5dc8
  .long Op5dd0,Op5dd0,Op5dd0,Op5dd0,Op5dd0,Op5dd0,Op5dd0,Op5dd0 ;@ 5dd0
  .long Op5dd8,Op5dd8,Op5dd8,Op5dd8,Op5dd8,Op5dd8,Op5dd8,Op5ddf ;@ 5dd8
  .long Op5de0,Op5de0,Op5de0,Op5de0,Op5de0,Op5de0,Op5de0,Op5de7 ;@ 5de0
  .long Op5de8,Op5de8,Op5de8,Op5de8,Op5de8,Op5de8,Op5de8,Op5de8 ;@ 5de8
  .long Op5df0,Op5df0,Op5df0,Op5df0,Op5df0,Op5df0,Op5df0,Op5df0 ;@ 5df0
  .long Op5df8,Op5df9,Op5dfa,Op5dfb,Op____,Op____,Op____,Op____ ;@ 5df8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5e00
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5e08
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5e10
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18 ;@ 5e18
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20 ;@ 5e20
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5e28
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5e30
  .long Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____ ;@ 5e38
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5e40
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5e48
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5e50
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5e58
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5e60
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5e68
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5e70
  .long Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____ ;@ 5e78
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5e80
  .long Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08 ;@ 5e88
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5e90
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5e98
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 5ea0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 5ea8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 5eb0
  .long Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____ ;@ 5eb8
  .long Op5ec0,Op5ec0,Op5ec0,Op5ec0,Op5ec0,Op5ec0,Op5ec0,Op5ec0 ;@ 5ec0
  .long Op5ec8,Op5ec8,Op5ec8,Op5ec8,Op5ec8,Op5ec8,Op5ec8,Op5ec8 ;@ 5ec8
  .long Op5ed0,Op5ed0,Op5ed0,Op5ed0,Op5ed0,Op5ed0,Op5ed0,Op5ed0 ;@ 5ed0
  .long Op5ed8,Op5ed8,Op5ed8,Op5ed8,Op5ed8,Op5ed8,Op5ed8,Op5edf ;@ 5ed8
  .long Op5ee0,Op5ee0,Op5ee0,Op5ee0,Op5ee0,Op5ee0,Op5ee0,Op5ee7 ;@ 5ee0
  .long Op5ee8,Op5ee8,Op5ee8,Op5ee8,Op5ee8,Op5ee8,Op5ee8,Op5ee8 ;@ 5ee8
  .long Op5ef0,Op5ef0,Op5ef0,Op5ef0,Op5ef0,Op5ef0,Op5ef0,Op5ef0 ;@ 5ef0
  .long Op5ef8,Op5ef9,Op5efa,Op5efb,Op____,Op____,Op____,Op____ ;@ 5ef8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5f00
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5f08
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5f10
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18 ;@ 5f18
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20 ;@ 5f20
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5f28
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5f30
  .long Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____ ;@ 5f38
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5f40
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5f48
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5f50
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5f58
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5f60
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5f68
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5f70
  .long Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____ ;@ 5f78
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5f80
  .long Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08 ;@ 5f88
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5f90
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5f98
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 5fa0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 5fa8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 5fb0
  .long Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____ ;@ 5fb8
  .long Op5fc0,Op5fc0,Op5fc0,Op5fc0,Op5fc0,Op5fc0,Op5fc0,Op5fc0 ;@ 5fc0
  .long Op5fc8,Op5fc8,Op5fc8,Op5fc8,Op5fc8,Op5fc8,Op5fc8,Op5fc8 ;@ 5fc8
  .long Op5fd0,Op5fd0,Op5fd0,Op5fd0,Op5fd0,Op5fd0,Op5fd0,Op5fd0 ;@ 5fd0
  .long Op5fd8,Op5fd8,Op5fd8,Op5fd8,Op5fd8,Op5fd8,Op5fd8,Op5fdf ;@ 5fd8
  .long Op5fe0,Op5fe0,Op5fe0,Op5fe0,Op5fe0,Op5fe0,Op5fe0,Op5fe7 ;@ 5fe0
  .long Op5fe8,Op5fe8,Op5fe8,Op5fe8,Op5fe8,Op5fe8,Op5fe8,Op5fe8 ;@ 5fe8
  .long Op5ff0,Op5ff0,Op5ff0,Op5ff0,Op5ff0,Op5ff0,Op5ff0,Op5ff0 ;@ 5ff0
  .long Op5ff8,Op5ff9,Op5ffa,Op5ffb,Op____,Op____,Op____,Op____ ;@ 5ff8
  .long Op6000,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6000
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6008
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6010
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6018
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6020
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6028
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6030
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6038
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6040
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6048
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6050
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6058
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6060
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6068
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6070
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6078
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6080
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6088
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6090
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6098
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 60a0
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 60a8
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 60b0
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 60b8
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 60c0
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 60c8
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 60d0
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 60d8
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 60e0
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 60e8
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 60f0
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op60ff ;@ 60f8
  .long Op6100,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6100
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6108
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6110
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6118
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6120
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6128
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6130
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6138
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6140
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6148
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6150
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6158
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6160
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6168
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6170
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6178
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6180
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6188
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6190
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6198
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 61a0
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 61a8
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 61b0
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 61b8
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 61c0
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 61c8
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 61d0
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 61d8
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 61e0
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 61e8
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 61f0
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op61ff ;@ 61f8
  .long Op6200,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6200
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6208
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6210
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6218
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6220
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6228
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6230
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6238
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6240
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6248
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6250
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6258
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6260
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6268
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6270
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6278
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6280
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6288
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6290
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6298
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 62a0
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 62a8
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 62b0
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 62b8
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 62c0
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 62c8
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 62d0
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 62d8
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 62e0
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 62e8
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 62f0
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op62ff ;@ 62f8
  .long Op6300,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6300
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6308
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6310
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6318
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6320
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6328
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6330
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6338
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6340
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6348
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6350
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6358
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6360
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6368
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6370
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6378
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6380
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6388
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6390
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6398
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 63a0
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 63a8
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 63b0
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 63b8
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 63c0
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 63c8
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 63d0
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 63d8
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 63e0
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 63e8
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 63f0
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op63ff ;@ 63f8
  .long Op6400,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6400
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6408
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6410
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6418
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6420
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6428
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6430
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6438
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6440
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6448
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6450
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6458
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6460
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6468
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6470
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6478
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6480
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6488
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6490
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6498
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 64a0
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 64a8
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 64b0
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 64b8
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 64c0
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 64c8
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 64d0
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 64d8
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 64e0
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 64e8
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 64f0
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op64ff ;@ 64f8
  .long Op6500,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6500
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6508
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6510
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6518
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6520
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6528
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6530
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6538
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6540
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6548
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6550
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6558
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6560
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6568
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6570
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6578
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6580
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6588
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6590
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6598
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 65a0
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 65a8
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 65b0
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 65b8
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 65c0
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 65c8
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 65d0
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 65d8
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 65e0
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 65e8
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 65f0
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op65ff ;@ 65f8
  .long Op6600,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6600
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6608
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6610
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6618
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6620
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6628
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6630
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6638
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6640
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6648
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6650
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6658
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6660
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6668
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6670
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6678
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6680
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6688
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6690
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6698
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 66a0
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 66a8
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 66b0
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 66b8
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 66c0
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 66c8
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 66d0
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 66d8
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 66e0
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 66e8
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 66f0
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op66ff ;@ 66f8
  .long Op6700,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6700
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6708
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6710
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6718
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6720
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6728
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6730
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6738
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6740
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6748
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6750
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6758
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6760
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6768
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6770
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6778
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6780
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6788
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6790
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6798
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 67a0
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 67a8
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 67b0
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 67b8
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 67c0
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 67c8
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 67d0
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 67d8
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 67e0
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 67e8
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 67f0
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op67ff ;@ 67f8
  .long Op6800,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6800
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6808
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6810
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6818
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6820
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6828
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6830
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6838
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6840
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6848
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6850
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6858
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6860
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6868
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6870
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6878
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6880
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6888
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6890
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6898
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 68a0
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 68a8
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 68b0
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 68b8
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 68c0
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 68c8
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 68d0
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 68d8
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 68e0
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 68e8
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 68f0
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op68ff ;@ 68f8
  .long Op6900,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6900
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6908
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6910
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6918
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6920
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6928
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6930
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6938
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6940
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6948
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6950
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6958
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6960
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6968
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6970
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6978
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6980
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6988
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6990
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6998
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 69a0
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 69a8
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 69b0
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 69b8
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 69c0
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 69c8
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 69d0
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 69d8
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 69e0
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 69e8
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 69f0
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op69ff ;@ 69f8
  .long Op6a00,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a00
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a08
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a10
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a18
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a20
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a28
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a30
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a38
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a40
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a48
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a50
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a58
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a60
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a68
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a70
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a78
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a80
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a88
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a90
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a98
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6aa0
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6aa8
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6ab0
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6ab8
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6ac0
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6ac8
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6ad0
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6ad8
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6ae0
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6ae8
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6af0
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6aff ;@ 6af8
  .long Op6b00,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b00
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b08
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b10
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b18
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b20
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b28
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b30
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b38
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b40
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b48
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b50
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b58
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b60
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b68
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b70
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b78
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b80
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b88
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b90
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b98
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6ba0
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6ba8
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6bb0
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6bb8
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6bc0
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6bc8
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6bd0
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6bd8
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6be0
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6be8
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6bf0
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6bff ;@ 6bf8
  .long Op6c00,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c00
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c08
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c10
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c18
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c20
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c28
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c30
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c38
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c40
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c48
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c50
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c58
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c60
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c68
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c70
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c78
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c80
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c88
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c90
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c98
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6ca0
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6ca8
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6cb0
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6cb8
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6cc0
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6cc8
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6cd0
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6cd8
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6ce0
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6ce8
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6cf0
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6cff ;@ 6cf8
  .long Op6d00,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d00
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d08
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d10
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d18
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d20
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d28
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d30
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d38
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d40
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d48
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d50
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d58
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d60
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d68
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d70
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d78
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d80
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d88
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d90
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d98
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6da0
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6da8
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6db0
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6db8
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6dc0
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6dc8
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6dd0
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6dd8
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6de0
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6de8
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6df0
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6dff ;@ 6df8
  .long Op6e00,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e00
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e08
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e10
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e18
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e20
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e28
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e30
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e38
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e40
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e48
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e50
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e58
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e60
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e68
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e70
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e78
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e80
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e88
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e90
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e98
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6ea0
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6ea8
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6eb0
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6eb8
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6ec0
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6ec8
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6ed0
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6ed8
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6ee0
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6ee8
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6ef0
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6eff ;@ 6ef8
  .long Op6f00,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f00
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f08
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f10
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f18
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f20
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f28
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f30
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f38
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f40
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f48
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f50
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f58
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f60
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f68
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f70
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f78
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f80
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f88
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f90
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f98
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6fa0
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6fa8
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6fb0
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6fb8
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6fc0
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6fc8
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6fd0
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6fd8
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6fe0
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6fe8
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6ff0
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6fff ;@ 6ff8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7000
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7008
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7010
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7018
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7020
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7028
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7030
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7038
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7040
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7048
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7050
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7058
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7060
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7068
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7070
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7078
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7080
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7088
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7090
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7098
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70a0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70a8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70b0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70c0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70c8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70d0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70d8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70e0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70e8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70f0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7100
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7108
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7110
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7118
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7120
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7128
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7130
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7138
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7140
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7148
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7150
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7158
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7160
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7168
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7170
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7178
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7180
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7188
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7190
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7198
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7200
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7208
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7210
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7218
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7220
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7228
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7230
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7238
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7240
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7248
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7250
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7258
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7260
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7268
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7270
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7278
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7280
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7288
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7290
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7298
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72a0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72a8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72b0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72c0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72c8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72d0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72d8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72e0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72e8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72f0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7300
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7308
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7310
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7318
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7320
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7328
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7330
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7338
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7340
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7348
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7350
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7358
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7360
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7368
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7370
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7378
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7380
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7388
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7390
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7398
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7400
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7408
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7410
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7418
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7420
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7428
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7430
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7438
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7440
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7448
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7450
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7458
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7460
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7468
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7470
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7478
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7480
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7488
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7490
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7498
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74a0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74a8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74b0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74c0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74c8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74d0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74d8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74e0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74e8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74f0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7500
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7508
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7510
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7518
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7520
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7528
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7530
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7538
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7540
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7548
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7550
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7558
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7560
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7568
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7570
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7578
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7580
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7588
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7590
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7598
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7600
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7608
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7610
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7618
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7620
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7628
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7630
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7638
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7640
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7648
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7650
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7658
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7660
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7668
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7670
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7678
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7680
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7688
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7690
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7698
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76a0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76a8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76b0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76c0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76c8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76d0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76d8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76e0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76e8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76f0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7700
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7708
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7710
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7718
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7720
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7728
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7730
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7738
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7740
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7748
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7750
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7758
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7760
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7768
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7770
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7778
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7780
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7788
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7790
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7798
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7800
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7808
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7810
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7818
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7820
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7828
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7830
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7838
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7840
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7848
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7850
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7858
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7860
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7868
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7870
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7878
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7880
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7888
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7890
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7898
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78a0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78a8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78b0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78c0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78c8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78d0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78d8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78e0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78e8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78f0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7900
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7908
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7910
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7918
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7920
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7928
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7930
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7938
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7940
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7948
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7950
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7958
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7960
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7968
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7970
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7978
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7980
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7988
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7990
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7998
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a00
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a08
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a10
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a18
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a20
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a28
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a30
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a38
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a40
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a48
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a50
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a58
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a60
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a68
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a70
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a78
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a80
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a88
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a90
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a98
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7aa0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7aa8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ab0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ab8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ac0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ac8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ad0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ad8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ae0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ae8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7af0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7af8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b88
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b90
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7ba0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7ba8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bb0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7be0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7be8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bf8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c00
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c08
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c10
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c18
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c20
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c28
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c30
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c38
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c40
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c48
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c50
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c58
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c60
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c68
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c70
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c78
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c80
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c88
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c90
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c98
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ca0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ca8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cb0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cb8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cc0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cc8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cd0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cd8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ce0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ce8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cf0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cf8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d88
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d90
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7da0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7da8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7db0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7dc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7dc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7dd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7dd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7de0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7de8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7df0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7df8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e00
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e08
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e10
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e18
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e20
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e28
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e30
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e38
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e40
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e48
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e50
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e58
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e60
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e68
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e70
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e78
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e80
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e88
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e90
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e98
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ea0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ea8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7eb0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7eb8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ec0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ec8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ed0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ed8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ee0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ee8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ef0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ef8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f88
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f90
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fa0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fa8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fb0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fe0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fe8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7ff0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7ff8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8000
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8008
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8010
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8018
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8020
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8028
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8030
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op803d,Op803e,Op803f ;@ 8038
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8040
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8048
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8050
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f ;@ 8058
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067 ;@ 8060
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8068
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8070
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op807d,Op807e,Op807f ;@ 8078
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8080
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8088
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8090
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f ;@ 8098
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7 ;@ 80a0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 80a8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 80b0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op80bd,Op80be,Op80bf ;@ 80b8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 80c0
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 80c8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 80d0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df ;@ 80d8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7 ;@ 80e0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 80e8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 80f0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 80f8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8100
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108 ;@ 8108
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8110
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8118
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8120
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8128
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8130
  .long Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____ ;@ 8138
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8140
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8148
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8150
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f ;@ 8158
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167 ;@ 8160
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8168
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8170
  .long Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____ ;@ 8178
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8180
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8188
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8190
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f ;@ 8198
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7 ;@ 81a0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 81a8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 81b0
  .long Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____ ;@ 81b8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 81c0
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 81c8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 81d0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df ;@ 81d8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7 ;@ 81e0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 81e8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 81f0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 81f8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8200
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8208
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8210
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8218
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8220
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8228
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8230
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op803d,Op803e,Op803f ;@ 8238
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8240
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8248
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8250
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f ;@ 8258
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067 ;@ 8260
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8268
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8270
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op807d,Op807e,Op807f ;@ 8278
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8280
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8288
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8290
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f ;@ 8298
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7 ;@ 82a0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 82a8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 82b0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op80bd,Op80be,Op80bf ;@ 82b8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 82c0
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 82c8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 82d0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df ;@ 82d8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7 ;@ 82e0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 82e8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 82f0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 82f8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8300
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108 ;@ 8308
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8310
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8318
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8320
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8328
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8330
  .long Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____ ;@ 8338
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8340
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8348
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8350
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f ;@ 8358
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167 ;@ 8360
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8368
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8370
  .long Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____ ;@ 8378
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8380
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8388
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8390
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f ;@ 8398
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7 ;@ 83a0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 83a8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 83b0
  .long Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____ ;@ 83b8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 83c0
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 83c8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 83d0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df ;@ 83d8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7 ;@ 83e0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 83e8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 83f0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 83f8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8400
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8408
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8410
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8418
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8420
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8428
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8430
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op803d,Op803e,Op803f ;@ 8438
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8440
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8448
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8450
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f ;@ 8458
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067 ;@ 8460
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8468
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8470
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op807d,Op807e,Op807f ;@ 8478
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8480
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8488
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8490
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f ;@ 8498
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7 ;@ 84a0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 84a8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 84b0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op80bd,Op80be,Op80bf ;@ 84b8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 84c0
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 84c8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 84d0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df ;@ 84d8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7 ;@ 84e0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 84e8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 84f0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 84f8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8500
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108 ;@ 8508
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8510
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8518
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8520
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8528
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8530
  .long Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____ ;@ 8538
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8540
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8548
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8550
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f ;@ 8558
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167 ;@ 8560
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8568
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8570
  .long Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____ ;@ 8578
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8580
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8588
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8590
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f ;@ 8598
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7 ;@ 85a0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 85a8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 85b0
  .long Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____ ;@ 85b8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 85c0
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 85c8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 85d0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df ;@ 85d8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7 ;@ 85e0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 85e8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 85f0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 85f8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8600
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8608
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8610
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8618
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8620
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8628
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8630
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op803d,Op803e,Op803f ;@ 8638
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8640
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8648
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8650
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f ;@ 8658
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067 ;@ 8660
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8668
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8670
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op807d,Op807e,Op807f ;@ 8678
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8680
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8688
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8690
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f ;@ 8698
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7 ;@ 86a0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 86a8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 86b0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op80bd,Op80be,Op80bf ;@ 86b8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 86c0
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 86c8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 86d0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df ;@ 86d8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7 ;@ 86e0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 86e8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 86f0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 86f8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8700
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108 ;@ 8708
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8710
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8718
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8720
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8728
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8730
  .long Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____ ;@ 8738
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8740
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8748
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8750
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f ;@ 8758
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167 ;@ 8760
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8768
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8770
  .long Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____ ;@ 8778
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8780
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8788
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8790
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f ;@ 8798
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7 ;@ 87a0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 87a8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 87b0
  .long Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____ ;@ 87b8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 87c0
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 87c8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 87d0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df ;@ 87d8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7 ;@ 87e0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 87e8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 87f0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 87f8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8800
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8808
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8810
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8818
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8820
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8828
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8830
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op803d,Op803e,Op803f ;@ 8838
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8840
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8848
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8850
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f ;@ 8858
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067 ;@ 8860
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8868
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8870
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op807d,Op807e,Op807f ;@ 8878
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8880
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8888
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8890
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f ;@ 8898
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7 ;@ 88a0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 88a8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 88b0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op80bd,Op80be,Op80bf ;@ 88b8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 88c0
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 88c8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 88d0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df ;@ 88d8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7 ;@ 88e0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 88e8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 88f0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 88f8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8900
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108 ;@ 8908
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8910
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8918
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8920
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8928
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8930
  .long Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____ ;@ 8938
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8940
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8948
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8950
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f ;@ 8958
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167 ;@ 8960
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8968
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8970
  .long Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____ ;@ 8978
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8980
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8988
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8990
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f ;@ 8998
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7 ;@ 89a0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 89a8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 89b0
  .long Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____ ;@ 89b8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 89c0
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 89c8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 89d0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df ;@ 89d8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7 ;@ 89e0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 89e8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 89f0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 89f8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8a00
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8a08
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8a10
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8a18
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8a20
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8a28
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8a30
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op803d,Op803e,Op803f ;@ 8a38
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8a40
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8a48
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8a50
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f ;@ 8a58
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067 ;@ 8a60
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8a68
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8a70
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op807d,Op807e,Op807f ;@ 8a78
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8a80
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8a88
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8a90
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f ;@ 8a98
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7 ;@ 8aa0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 8aa8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 8ab0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op80bd,Op80be,Op80bf ;@ 8ab8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 8ac0
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 8ac8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 8ad0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df ;@ 8ad8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7 ;@ 8ae0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 8ae8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 8af0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 8af8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8b00
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108 ;@ 8b08
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8b10
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8b18
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8b20
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8b28
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8b30
  .long Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____ ;@ 8b38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8b40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8b48
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8b50
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f ;@ 8b58
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167 ;@ 8b60
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8b68
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8b70
  .long Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____ ;@ 8b78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8b80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8b88
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8b90
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f ;@ 8b98
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7 ;@ 8ba0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 8ba8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 8bb0
  .long Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____ ;@ 8bb8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 8bc0
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 8bc8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 8bd0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df ;@ 8bd8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7 ;@ 8be0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 8be8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 8bf0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 8bf8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8c00
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8c08
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8c10
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8c18
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8c20
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8c28
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8c30
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op803d,Op803e,Op803f ;@ 8c38
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8c40
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8c48
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8c50
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f ;@ 8c58
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067 ;@ 8c60
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8c68
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8c70
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op807d,Op807e,Op807f ;@ 8c78
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8c80
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8c88
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8c90
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f ;@ 8c98
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7 ;@ 8ca0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 8ca8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 8cb0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op80bd,Op80be,Op80bf ;@ 8cb8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 8cc0
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 8cc8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 8cd0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df ;@ 8cd8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7 ;@ 8ce0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 8ce8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 8cf0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 8cf8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8d00
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108 ;@ 8d08
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8d10
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8d18
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8d20
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8d28
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8d30
  .long Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____ ;@ 8d38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8d40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8d48
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8d50
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f ;@ 8d58
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167 ;@ 8d60
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8d68
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8d70
  .long Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____ ;@ 8d78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8d80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8d88
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8d90
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f ;@ 8d98
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7 ;@ 8da0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 8da8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 8db0
  .long Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____ ;@ 8db8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 8dc0
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 8dc8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 8dd0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df ;@ 8dd8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7 ;@ 8de0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 8de8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 8df0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 8df8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8e00
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8e08
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8e10
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8e18
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8e20
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8e28
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8e30
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op803d,Op803e,Op803f ;@ 8e38
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8e40
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8e48
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8e50
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f ;@ 8e58
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067 ;@ 8e60
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8e68
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8e70
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op807d,Op807e,Op807f ;@ 8e78
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8e80
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8e88
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8e90
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f ;@ 8e98
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7 ;@ 8ea0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 8ea8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 8eb0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op80bd,Op80be,Op80bf ;@ 8eb8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 8ec0
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 8ec8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 8ed0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df ;@ 8ed8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7 ;@ 8ee0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 8ee8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 8ef0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 8ef8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8f00
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108 ;@ 8f08
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8f10
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8f18
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8f20
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8f28
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8f30
  .long Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____ ;@ 8f38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8f40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8f48
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8f50
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f ;@ 8f58
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167 ;@ 8f60
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8f68
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8f70
  .long Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____ ;@ 8f78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8f80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8f88
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8f90
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f ;@ 8f98
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7 ;@ 8fa0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 8fa8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 8fb0
  .long Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____ ;@ 8fb8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 8fc0
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 8fc8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 8fd0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df ;@ 8fd8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7 ;@ 8fe0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 8fe8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 8ff0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 8ff8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9000
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9008
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9010
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9018
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9020
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9028
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9030
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op903d,Op903e,Op903f ;@ 9038
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9040
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9048
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9050
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f ;@ 9058
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067 ;@ 9060
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9068
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9070
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op907d,Op907e,Op907f ;@ 9078
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9080
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9088
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9090
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f ;@ 9098
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7 ;@ 90a0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 90a8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 90b0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op90bd,Op90be,Op90bf ;@ 90b8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 90c0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 90c8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 90d0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df ;@ 90d8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7 ;@ 90e0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 90e8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 90f0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 90f8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9100
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9108
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9110
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9118
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9120
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9128
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9130
  .long Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____ ;@ 9138
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9140
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9148
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9150
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f ;@ 9158
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167 ;@ 9160
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9168
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9170
  .long Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____ ;@ 9178
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9180
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9188
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9190
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f ;@ 9198
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7 ;@ 91a0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 91a8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 91b0
  .long Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____ ;@ 91b8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 91c0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 91c8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 91d0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df ;@ 91d8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7 ;@ 91e0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 91e8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 91f0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 91f8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9200
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9208
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9210
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9218
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9220
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9228
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9230
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op903d,Op903e,Op903f ;@ 9238
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9240
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9248
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9250
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f ;@ 9258
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067 ;@ 9260
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9268
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9270
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op907d,Op907e,Op907f ;@ 9278
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9280
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9288
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9290
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f ;@ 9298
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7 ;@ 92a0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 92a8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 92b0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op90bd,Op90be,Op90bf ;@ 92b8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 92c0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 92c8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 92d0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df ;@ 92d8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7 ;@ 92e0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 92e8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 92f0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 92f8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9300
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9308
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9310
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9318
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9320
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9328
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9330
  .long Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____ ;@ 9338
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9340
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9348
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9350
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f ;@ 9358
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167 ;@ 9360
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9368
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9370
  .long Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____ ;@ 9378
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9380
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9388
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9390
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f ;@ 9398
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7 ;@ 93a0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 93a8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 93b0
  .long Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____ ;@ 93b8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 93c0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 93c8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 93d0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df ;@ 93d8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7 ;@ 93e0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 93e8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 93f0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 93f8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9400
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9408
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9410
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9418
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9420
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9428
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9430
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op903d,Op903e,Op903f ;@ 9438
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9440
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9448
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9450
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f ;@ 9458
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067 ;@ 9460
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9468
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9470
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op907d,Op907e,Op907f ;@ 9478
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9480
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9488
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9490
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f ;@ 9498
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7 ;@ 94a0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 94a8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 94b0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op90bd,Op90be,Op90bf ;@ 94b8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 94c0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 94c8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 94d0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df ;@ 94d8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7 ;@ 94e0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 94e8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 94f0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 94f8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9500
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9508
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9510
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9518
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9520
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9528
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9530
  .long Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____ ;@ 9538
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9540
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9548
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9550
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f ;@ 9558
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167 ;@ 9560
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9568
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9570
  .long Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____ ;@ 9578
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9580
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9588
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9590
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f ;@ 9598
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7 ;@ 95a0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 95a8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 95b0
  .long Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____ ;@ 95b8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 95c0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 95c8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 95d0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df ;@ 95d8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7 ;@ 95e0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 95e8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 95f0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 95f8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9600
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9608
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9610
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9618
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9620
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9628
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9630
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op903d,Op903e,Op903f ;@ 9638
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9640
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9648
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9650
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f ;@ 9658
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067 ;@ 9660
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9668
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9670
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op907d,Op907e,Op907f ;@ 9678
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9680
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9688
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9690
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f ;@ 9698
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7 ;@ 96a0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 96a8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 96b0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op90bd,Op90be,Op90bf ;@ 96b8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 96c0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 96c8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 96d0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df ;@ 96d8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7 ;@ 96e0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 96e8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 96f0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 96f8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9700
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9708
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9710
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9718
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9720
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9728
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9730
  .long Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____ ;@ 9738
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9740
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9748
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9750
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f ;@ 9758
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167 ;@ 9760
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9768
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9770
  .long Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____ ;@ 9778
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9780
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9788
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9790
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f ;@ 9798
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7 ;@ 97a0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 97a8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 97b0
  .long Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____ ;@ 97b8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 97c0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 97c8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 97d0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df ;@ 97d8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7 ;@ 97e0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 97e8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 97f0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 97f8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9800
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9808
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9810
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9818
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9820
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9828
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9830
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op903d,Op903e,Op903f ;@ 9838
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9840
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9848
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9850
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f ;@ 9858
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067 ;@ 9860
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9868
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9870
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op907d,Op907e,Op907f ;@ 9878
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9880
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9888
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9890
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f ;@ 9898
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7 ;@ 98a0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 98a8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 98b0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op90bd,Op90be,Op90bf ;@ 98b8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 98c0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 98c8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 98d0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df ;@ 98d8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7 ;@ 98e0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 98e8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 98f0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 98f8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9900
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9908
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9910
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9918
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9920
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9928
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9930
  .long Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____ ;@ 9938
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9940
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9948
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9950
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f ;@ 9958
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167 ;@ 9960
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9968
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9970
  .long Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____ ;@ 9978
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9980
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9988
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9990
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f ;@ 9998
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7 ;@ 99a0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 99a8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 99b0
  .long Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____ ;@ 99b8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 99c0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 99c8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 99d0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df ;@ 99d8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7 ;@ 99e0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 99e8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 99f0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 99f8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9a00
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9a08
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9a10
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9a18
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9a20
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9a28
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9a30
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op903d,Op903e,Op903f ;@ 9a38
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9a40
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9a48
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9a50
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f ;@ 9a58
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067 ;@ 9a60
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9a68
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9a70
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op907d,Op907e,Op907f ;@ 9a78
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9a80
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9a88
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9a90
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f ;@ 9a98
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7 ;@ 9aa0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 9aa8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 9ab0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op90bd,Op90be,Op90bf ;@ 9ab8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 9ac0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 9ac8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 9ad0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df ;@ 9ad8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7 ;@ 9ae0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 9ae8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 9af0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 9af8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9b00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9b08
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9b10
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9b18
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9b20
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9b28
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9b30
  .long Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____ ;@ 9b38
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9b40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9b48
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9b50
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f ;@ 9b58
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167 ;@ 9b60
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9b68
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9b70
  .long Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____ ;@ 9b78
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9b80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9b88
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9b90
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f ;@ 9b98
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7 ;@ 9ba0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 9ba8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 9bb0
  .long Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____ ;@ 9bb8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 9bc0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 9bc8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 9bd0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df ;@ 9bd8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7 ;@ 9be0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 9be8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 9bf0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 9bf8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9c00
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9c08
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9c10
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9c18
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9c20
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9c28
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9c30
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op903d,Op903e,Op903f ;@ 9c38
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9c40
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9c48
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9c50
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f ;@ 9c58
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067 ;@ 9c60
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9c68
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9c70
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op907d,Op907e,Op907f ;@ 9c78
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9c80
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9c88
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9c90
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f ;@ 9c98
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7 ;@ 9ca0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 9ca8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 9cb0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op90bd,Op90be,Op90bf ;@ 9cb8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 9cc0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 9cc8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 9cd0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df ;@ 9cd8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7 ;@ 9ce0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 9ce8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 9cf0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 9cf8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9d00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9d08
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9d10
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9d18
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9d20
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9d28
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9d30
  .long Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____ ;@ 9d38
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9d40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9d48
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9d50
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f ;@ 9d58
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167 ;@ 9d60
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9d68
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9d70
  .long Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____ ;@ 9d78
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9d80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9d88
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9d90
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f ;@ 9d98
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7 ;@ 9da0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 9da8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 9db0
  .long Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____ ;@ 9db8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 9dc0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 9dc8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 9dd0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df ;@ 9dd8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7 ;@ 9de0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 9de8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 9df0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 9df8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9e00
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9e08
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9e10
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9e18
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9e20
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9e28
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9e30
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op903d,Op903e,Op903f ;@ 9e38
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9e40
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9e48
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9e50
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f ;@ 9e58
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067 ;@ 9e60
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9e68
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9e70
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op907d,Op907e,Op907f ;@ 9e78
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9e80
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9e88
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9e90
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f ;@ 9e98
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7 ;@ 9ea0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 9ea8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 9eb0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op90bd,Op90be,Op90bf ;@ 9eb8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 9ec0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 9ec8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 9ed0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df ;@ 9ed8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7 ;@ 9ee0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 9ee8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 9ef0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 9ef8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9f00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9f08
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9f10
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9f18
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9f20
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9f28
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9f30
  .long Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____ ;@ 9f38
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9f40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9f48
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9f50
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f ;@ 9f58
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167 ;@ 9f60
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9f68
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9f70
  .long Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____ ;@ 9f78
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9f80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9f88
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9f90
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f ;@ 9f98
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7 ;@ 9fa0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 9fa8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 9fb0
  .long Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____ ;@ 9fb8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 9fc0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 9fc8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 9fd0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df ;@ 9fd8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7 ;@ 9fe0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 9fe8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 9ff0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 9ff8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a000
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a008
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a010
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a018
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a020
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a028
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a030
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a038
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a040
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a048
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a050
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a058
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a060
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a068
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a070
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a078
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a080
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a088
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a090
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a098
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a100
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a108
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a110
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a118
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a120
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a128
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a130
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a138
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a140
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a148
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a150
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a158
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a160
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a168
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a170
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a178
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a180
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a188
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a190
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a198
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a200
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a208
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a210
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a218
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a220
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a228
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a230
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a238
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a240
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a248
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a250
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a258
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a260
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a268
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a270
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a278
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a280
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a288
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a290
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a298
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a300
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a308
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a310
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a318
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a320
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a328
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a330
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a338
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a340
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a348
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a350
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a358
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a360
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a368
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a370
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a378
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a380
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a388
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a390
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a398
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a400
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a408
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a410
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a418
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a420
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a428
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a430
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a438
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a440
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a448
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a450
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a458
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a460
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a468
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a470
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a478
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a480
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a488
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a490
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a498
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a500
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a508
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a510
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a518
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a520
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a528
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a530
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a538
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a540
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a548
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a550
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a558
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a560
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a568
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a570
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a578
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a580
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a588
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a590
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a598
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a600
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a608
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a610
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a618
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a620
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a628
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a630
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a638
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a640
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a648
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a650
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a658
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a660
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a668
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a670
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a678
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a680
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a688
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a690
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a698
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a700
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a708
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a710
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a718
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a720
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a728
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a730
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a738
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a740
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a748
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a750
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a758
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a760
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a768
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a770
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a778
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a780
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a788
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a790
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a798
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a800
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a808
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a810
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a818
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a820
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a828
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a830
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a838
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a840
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a848
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a850
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a858
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a860
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a868
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a870
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a878
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a880
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a888
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a890
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a898
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a900
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a908
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a910
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a918
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a920
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a928
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a930
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a938
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a940
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a948
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a950
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a958
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a960
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a968
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a970
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a978
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a980
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a988
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a990
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a998
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa00
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa08
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa10
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa18
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa20
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa28
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa30
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa40
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa48
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa50
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa58
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa60
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa68
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa70
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa80
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa88
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa90
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa98
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aaa0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aaa8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aab0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aab8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aac0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aac8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aad0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aad8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aae0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aae8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aaf0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aaf8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab00
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab08
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab10
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab18
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab20
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab28
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab30
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab40
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab48
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab50
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab58
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab60
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab68
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab70
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab80
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab88
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab90
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab98
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aba0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aba8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abb0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abc0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abc8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abd0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abd8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abe0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abe8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abf0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abf8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac00
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac08
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac10
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac18
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac20
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac28
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac30
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac40
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac48
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac50
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac58
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac60
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac68
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac70
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac80
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac88
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac90
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac98
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aca0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aca8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acb0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acc0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acc8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acd0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acd8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ace0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ace8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acf0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acf8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad00
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad08
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad10
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad18
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad20
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad28
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad30
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad40
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad48
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad50
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad58
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad60
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad68
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad70
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad80
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad88
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad90
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad98
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ada0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ada8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adb0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adc0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adc8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ add0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ add8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ade0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ade8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adf0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adf8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae00
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae08
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae10
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae18
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae20
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae28
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae30
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae40
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae48
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae50
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae58
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae60
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae68
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae70
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae80
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae88
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae90
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae98
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aea0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aea8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aeb0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aeb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aec0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aec8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aed0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aed8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aee0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aee8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aef0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aef8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af00
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af08
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af10
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af18
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af20
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af28
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af30
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af40
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af48
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af50
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af58
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af60
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af68
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af70
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af80
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af88
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af90
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af98
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afa0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afa8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afb0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afc0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afc8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afd0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afd8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afe0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afe8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aff0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aff8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b000
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b008
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ b010
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ b018
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ b020
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ b028
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ b030
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ b038
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b040
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b048
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ b050
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f ;@ b058
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067 ;@ b060
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ b068
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ b070
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ b078
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b080
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b088
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ b090
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f ;@ b098
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7 ;@ b0a0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ b0a8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ b0b0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ b0b8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b0c0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b0c8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ b0d0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df ;@ b0d8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7 ;@ b0e0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ b0e8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ b0f0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ b0f8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ b100
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108 ;@ b108
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ b110
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ b118
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ b120
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ b128
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ b130
  .long Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____ ;@ b138
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ b140
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ b148
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ b150
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f ;@ b158
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167 ;@ b160
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ b168
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ b170
  .long Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____ ;@ b178
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ b180
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ b188
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ b190
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f ;@ b198
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7 ;@ b1a0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ b1a8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ b1b0
  .long Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____ ;@ b1b8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b1c0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b1c8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ b1d0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df ;@ b1d8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7 ;@ b1e0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ b1e8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ b1f0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ b1f8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b200
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b208
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ b210
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ b218
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ b220
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ b228
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ b230
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ b238
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b240
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b248
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ b250
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f ;@ b258
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067 ;@ b260
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ b268
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ b270
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ b278
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b280
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b288
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ b290
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f ;@ b298
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7 ;@ b2a0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ b2a8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ b2b0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ b2b8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b2c0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b2c8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ b2d0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df ;@ b2d8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7 ;@ b2e0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ b2e8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ b2f0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ b2f8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ b300
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108 ;@ b308
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ b310
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ b318
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ b320
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ b328
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ b330
  .long Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____ ;@ b338
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ b340
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ b348
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ b350
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f ;@ b358
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167 ;@ b360
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ b368
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ b370
  .long Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____ ;@ b378
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ b380
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ b388
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ b390
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f ;@ b398
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7 ;@ b3a0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ b3a8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ b3b0
  .long Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____ ;@ b3b8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b3c0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b3c8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ b3d0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df ;@ b3d8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7 ;@ b3e0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ b3e8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ b3f0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ b3f8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b400
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b408
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ b410
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ b418
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ b420
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ b428
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ b430
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ b438
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b440
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b448
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ b450
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f ;@ b458
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067 ;@ b460
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ b468
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ b470
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ b478
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b480
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b488
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ b490
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f ;@ b498
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7 ;@ b4a0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ b4a8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ b4b0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ b4b8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b4c0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b4c8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ b4d0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df ;@ b4d8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7 ;@ b4e0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ b4e8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ b4f0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ b4f8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ b500
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108 ;@ b508
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ b510
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ b518
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ b520
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ b528
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ b530
  .long Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____ ;@ b538
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ b540
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ b548
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ b550
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f ;@ b558
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167 ;@ b560
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ b568
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ b570
  .long Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____ ;@ b578
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ b580
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ b588
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ b590
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f ;@ b598
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7 ;@ b5a0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ b5a8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ b5b0
  .long Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____ ;@ b5b8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b5c0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b5c8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ b5d0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df ;@ b5d8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7 ;@ b5e0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ b5e8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ b5f0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ b5f8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b600
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b608
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ b610
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ b618
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ b620
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ b628
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ b630
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ b638
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b640
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b648
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ b650
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f ;@ b658
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067 ;@ b660
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ b668
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ b670
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ b678
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b680
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b688
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ b690
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f ;@ b698
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7 ;@ b6a0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ b6a8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ b6b0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ b6b8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b6c0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b6c8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ b6d0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df ;@ b6d8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7 ;@ b6e0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ b6e8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ b6f0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ b6f8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ b700
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108 ;@ b708
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ b710
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ b718
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ b720
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ b728
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ b730
  .long Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____ ;@ b738
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ b740
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ b748
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ b750
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f ;@ b758
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167 ;@ b760
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ b768
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ b770
  .long Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____ ;@ b778
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ b780
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ b788
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ b790
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f ;@ b798
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7 ;@ b7a0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ b7a8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ b7b0
  .long Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____ ;@ b7b8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b7c0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b7c8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ b7d0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df ;@ b7d8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7 ;@ b7e0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ b7e8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ b7f0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ b7f8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b800
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b808
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ b810
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ b818
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ b820
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ b828
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ b830
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ b838
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b840
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b848
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ b850
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f ;@ b858
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067 ;@ b860
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ b868
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ b870
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ b878
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b880
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b888
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ b890
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f ;@ b898
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7 ;@ b8a0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ b8a8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ b8b0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ b8b8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b8c0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b8c8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ b8d0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df ;@ b8d8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7 ;@ b8e0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ b8e8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ b8f0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ b8f8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ b900
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108 ;@ b908
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ b910
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ b918
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ b920
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ b928
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ b930
  .long Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____ ;@ b938
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ b940
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ b948
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ b950
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f ;@ b958
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167 ;@ b960
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ b968
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ b970
  .long Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____ ;@ b978
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ b980
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ b988
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ b990
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f ;@ b998
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7 ;@ b9a0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ b9a8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ b9b0
  .long Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____ ;@ b9b8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b9c0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b9c8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ b9d0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df ;@ b9d8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7 ;@ b9e0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ b9e8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ b9f0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ b9f8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ ba00
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ ba08
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ ba10
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ ba18
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ ba20
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ ba28
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ ba30
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ ba38
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ ba40
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ ba48
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ ba50
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f ;@ ba58
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067 ;@ ba60
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ ba68
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ ba70
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ ba78
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ ba80
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ ba88
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ ba90
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f ;@ ba98
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7 ;@ baa0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ baa8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ bab0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ bab8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ bac0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ bac8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ bad0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df ;@ bad8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7 ;@ bae0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ bae8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ baf0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ baf8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ bb00
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108 ;@ bb08
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ bb10
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ bb18
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ bb20
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ bb28
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ bb30
  .long Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____ ;@ bb38
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ bb40
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ bb48
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ bb50
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f ;@ bb58
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167 ;@ bb60
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ bb68
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ bb70
  .long Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____ ;@ bb78
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ bb80
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ bb88
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ bb90
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f ;@ bb98
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7 ;@ bba0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ bba8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ bbb0
  .long Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____ ;@ bbb8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ bbc0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ bbc8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ bbd0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df ;@ bbd8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7 ;@ bbe0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ bbe8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ bbf0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ bbf8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ bc00
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ bc08
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ bc10
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ bc18
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ bc20
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ bc28
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ bc30
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ bc38
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ bc40
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ bc48
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ bc50
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f ;@ bc58
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067 ;@ bc60
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ bc68
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ bc70
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ bc78
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ bc80
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ bc88
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ bc90
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f ;@ bc98
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7 ;@ bca0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ bca8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ bcb0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ bcb8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ bcc0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ bcc8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ bcd0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df ;@ bcd8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7 ;@ bce0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ bce8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ bcf0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ bcf8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ bd00
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108 ;@ bd08
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ bd10
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ bd18
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ bd20
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ bd28
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ bd30
  .long Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____ ;@ bd38
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ bd40
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ bd48
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ bd50
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f ;@ bd58
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167 ;@ bd60
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ bd68
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ bd70
  .long Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____ ;@ bd78
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ bd80
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ bd88
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ bd90
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f ;@ bd98
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7 ;@ bda0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ bda8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ bdb0
  .long Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____ ;@ bdb8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ bdc0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ bdc8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ bdd0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df ;@ bdd8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7 ;@ bde0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ bde8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ bdf0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ bdf8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ be00
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ be08
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ be10
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ be18
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ be20
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ be28
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ be30
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ be38
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ be40
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ be48
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ be50
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f ;@ be58
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067 ;@ be60
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ be68
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ be70
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ be78
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ be80
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ be88
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ be90
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f ;@ be98
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7 ;@ bea0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ bea8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ beb0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ beb8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ bec0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ bec8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ bed0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df ;@ bed8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7 ;@ bee0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ bee8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ bef0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ bef8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ bf00
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108 ;@ bf08
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ bf10
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ bf18
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ bf20
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ bf28
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ bf30
  .long Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____ ;@ bf38
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ bf40
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ bf48
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ bf50
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f ;@ bf58
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167 ;@ bf60
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ bf68
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ bf70
  .long Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____ ;@ bf78
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ bf80
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ bf88
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ bf90
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f ;@ bf98
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7 ;@ bfa0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ bfa8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ bfb0
  .long Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____ ;@ bfb8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ bfc0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ bfc8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ bfd0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df ;@ bfd8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7 ;@ bfe0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ bfe8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ bff0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ bff8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c000
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c008
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ c010
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ c018
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ c020
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ c028
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ c030
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Opc03d,Opc03e,Opc03f ;@ c038
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c040
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c048
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ c050
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f ;@ c058
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067 ;@ c060
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ c068
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ c070
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Opc07d,Opc07e,Opc07f ;@ c078
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c080
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c088
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ c090
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f ;@ c098
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7 ;@ c0a0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ c0a8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ c0b0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Opc0bd,Opc0be,Opc0bf ;@ c0b8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c0c0
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c0c8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ c0d0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df ;@ c0d8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7 ;@ c0e0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ c0e8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ c0f0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ c0f8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ c100
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108 ;@ c108
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ c110
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ c118
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ c120
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ c128
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ c130
  .long Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____ ;@ c138
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ c140
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ c148
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ c150
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f ;@ c158
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167 ;@ c160
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ c168
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ c170
  .long Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____ ;@ c178
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c180
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ c188
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ c190
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f ;@ c198
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7 ;@ c1a0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ c1a8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ c1b0
  .long Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____ ;@ c1b8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c1c0
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c1c8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ c1d0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df ;@ c1d8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7 ;@ c1e0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ c1e8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ c1f0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ c1f8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c200
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c208
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ c210
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ c218
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ c220
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ c228
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ c230
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Opc03d,Opc03e,Opc03f ;@ c238
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c240
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c248
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ c250
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f ;@ c258
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067 ;@ c260
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ c268
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ c270
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Opc07d,Opc07e,Opc07f ;@ c278
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c280
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c288
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ c290
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f ;@ c298
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7 ;@ c2a0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ c2a8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ c2b0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Opc0bd,Opc0be,Opc0bf ;@ c2b8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c2c0
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c2c8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ c2d0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df ;@ c2d8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7 ;@ c2e0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ c2e8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ c2f0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ c2f8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ c300
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108 ;@ c308
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ c310
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ c318
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ c320
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ c328
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ c330
  .long Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____ ;@ c338
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ c340
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ c348
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ c350
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f ;@ c358
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167 ;@ c360
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ c368
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ c370
  .long Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____ ;@ c378
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c380
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ c388
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ c390
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f ;@ c398
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7 ;@ c3a0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ c3a8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ c3b0
  .long Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____ ;@ c3b8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c3c0
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c3c8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ c3d0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df ;@ c3d8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7 ;@ c3e0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ c3e8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ c3f0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ c3f8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c400
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c408
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ c410
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ c418
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ c420
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ c428
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ c430
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Opc03d,Opc03e,Opc03f ;@ c438
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c440
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c448
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ c450
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f ;@ c458
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067 ;@ c460
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ c468
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ c470
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Opc07d,Opc07e,Opc07f ;@ c478
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c480
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c488
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ c490
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f ;@ c498
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7 ;@ c4a0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ c4a8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ c4b0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Opc0bd,Opc0be,Opc0bf ;@ c4b8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c4c0
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c4c8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ c4d0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df ;@ c4d8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7 ;@ c4e0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ c4e8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ c4f0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ c4f8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ c500
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108 ;@ c508
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ c510
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ c518
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ c520
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ c528
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ c530
  .long Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____ ;@ c538
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ c540
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ c548
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ c550
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f ;@ c558
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167 ;@ c560
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ c568
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ c570
  .long Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____ ;@ c578
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c580
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ c588
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ c590
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f ;@ c598
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7 ;@ c5a0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ c5a8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ c5b0
  .long Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____ ;@ c5b8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c5c0
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c5c8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ c5d0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df ;@ c5d8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7 ;@ c5e0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ c5e8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ c5f0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ c5f8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c600
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c608
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ c610
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ c618
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ c620
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ c628
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ c630
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Opc03d,Opc03e,Opc03f ;@ c638
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c640
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c648
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ c650
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f ;@ c658
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067 ;@ c660
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ c668
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ c670
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Opc07d,Opc07e,Opc07f ;@ c678
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c680
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c688
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ c690
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f ;@ c698
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7 ;@ c6a0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ c6a8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ c6b0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Opc0bd,Opc0be,Opc0bf ;@ c6b8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c6c0
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c6c8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ c6d0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df ;@ c6d8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7 ;@ c6e0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ c6e8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ c6f0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ c6f8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ c700
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108 ;@ c708
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ c710
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ c718
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ c720
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ c728
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ c730
  .long Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____ ;@ c738
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ c740
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ c748
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ c750
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f ;@ c758
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167 ;@ c760
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ c768
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ c770
  .long Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____ ;@ c778
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c780
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ c788
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ c790
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f ;@ c798
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7 ;@ c7a0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ c7a8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ c7b0
  .long Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____ ;@ c7b8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c7c0
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c7c8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ c7d0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df ;@ c7d8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7 ;@ c7e0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ c7e8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ c7f0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ c7f8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c800
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c808
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ c810
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ c818
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ c820
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ c828
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ c830
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Opc03d,Opc03e,Opc03f ;@ c838
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c840
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c848
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ c850
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f ;@ c858
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067 ;@ c860
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ c868
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ c870
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Opc07d,Opc07e,Opc07f ;@ c878
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c880
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c888
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ c890
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f ;@ c898
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7 ;@ c8a0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ c8a8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ c8b0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Opc0bd,Opc0be,Opc0bf ;@ c8b8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c8c0
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c8c8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ c8d0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df ;@ c8d8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7 ;@ c8e0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ c8e8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ c8f0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ c8f8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ c900
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108 ;@ c908
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ c910
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ c918
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ c920
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ c928
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ c930
  .long Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____ ;@ c938
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ c940
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ c948
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ c950
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f ;@ c958
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167 ;@ c960
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ c968
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ c970
  .long Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____ ;@ c978
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c980
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ c988
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ c990
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f ;@ c998
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7 ;@ c9a0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ c9a8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ c9b0
  .long Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____ ;@ c9b8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c9c0
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c9c8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ c9d0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df ;@ c9d8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7 ;@ c9e0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ c9e8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ c9f0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ c9f8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ ca00
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ ca08
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ ca10
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ ca18
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ ca20
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ ca28
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ ca30
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Opc03d,Opc03e,Opc03f ;@ ca38
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ ca40
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ ca48
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ ca50
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f ;@ ca58
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067 ;@ ca60
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ ca68
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ ca70
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Opc07d,Opc07e,Opc07f ;@ ca78
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ ca80
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ ca88
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ ca90
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f ;@ ca98
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7 ;@ caa0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ caa8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ cab0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Opc0bd,Opc0be,Opc0bf ;@ cab8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ cac0
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ cac8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ cad0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df ;@ cad8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7 ;@ cae0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ cae8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ caf0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ caf8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ cb00
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108 ;@ cb08
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ cb10
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ cb18
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ cb20
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ cb28
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ cb30
  .long Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____ ;@ cb38
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ cb40
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ cb48
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ cb50
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f ;@ cb58
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167 ;@ cb60
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ cb68
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ cb70
  .long Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____ ;@ cb78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cb80
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ cb88
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ cb90
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f ;@ cb98
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7 ;@ cba0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ cba8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ cbb0
  .long Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____ ;@ cbb8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ cbc0
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ cbc8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ cbd0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df ;@ cbd8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7 ;@ cbe0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ cbe8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ cbf0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ cbf8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ cc00
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ cc08
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ cc10
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ cc18
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ cc20
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ cc28
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ cc30
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Opc03d,Opc03e,Opc03f ;@ cc38
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ cc40
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ cc48
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ cc50
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f ;@ cc58
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067 ;@ cc60
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ cc68
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ cc70
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Opc07d,Opc07e,Opc07f ;@ cc78
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ cc80
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ cc88
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ cc90
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f ;@ cc98
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7 ;@ cca0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ cca8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ ccb0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Opc0bd,Opc0be,Opc0bf ;@ ccb8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ ccc0
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ ccc8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ ccd0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df ;@ ccd8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7 ;@ cce0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ cce8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ ccf0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ ccf8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ cd00
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108 ;@ cd08
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ cd10
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ cd18
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ cd20
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ cd28
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ cd30
  .long Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____ ;@ cd38
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ cd40
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ cd48
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ cd50
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f ;@ cd58
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167 ;@ cd60
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ cd68
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ cd70
  .long Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____ ;@ cd78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cd80
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ cd88
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ cd90
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f ;@ cd98
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7 ;@ cda0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ cda8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ cdb0
  .long Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____ ;@ cdb8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ cdc0
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ cdc8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ cdd0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df ;@ cdd8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7 ;@ cde0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ cde8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ cdf0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ cdf8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ ce00
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ ce08
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ ce10
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ ce18
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ ce20
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ ce28
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ ce30
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Opc03d,Opc03e,Opc03f ;@ ce38
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ ce40
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ ce48
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ ce50
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f ;@ ce58
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067 ;@ ce60
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ ce68
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ ce70
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Opc07d,Opc07e,Opc07f ;@ ce78
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ ce80
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ ce88
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ ce90
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f ;@ ce98
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7 ;@ cea0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ cea8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ ceb0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Opc0bd,Opc0be,Opc0bf ;@ ceb8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ cec0
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ cec8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ ced0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df ;@ ced8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7 ;@ cee0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ cee8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ cef0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ cef8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ cf00
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108 ;@ cf08
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ cf10
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ cf18
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ cf20
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ cf28
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ cf30
  .long Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____ ;@ cf38
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ cf40
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ cf48
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ cf50
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f ;@ cf58
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167 ;@ cf60
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ cf68
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ cf70
  .long Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____ ;@ cf78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cf80
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ cf88
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ cf90
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f ;@ cf98
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7 ;@ cfa0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ cfa8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ cfb0
  .long Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____ ;@ cfb8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ cfc0
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ cfc8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ cfd0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df ;@ cfd8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7 ;@ cfe0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ cfe8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ cff0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ cff8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d000
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d008
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ d010
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ d018
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ d020
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ d028
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ d030
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Opd03d,Opd03e,Opd03f ;@ d038
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d040
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d048
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ d050
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f ;@ d058
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067 ;@ d060
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ d068
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ d070
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Opd07d,Opd07e,Opd07f ;@ d078
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d080
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d088
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ d090
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f ;@ d098
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7 ;@ d0a0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ d0a8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ d0b0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Opd0bd,Opd0be,Opd0bf ;@ d0b8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d0c0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d0c8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ d0d0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df ;@ d0d8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7 ;@ d0e0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ d0e8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ d0f0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ d0f8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ d100
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d108
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ d110
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ d118
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ d120
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ d128
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ d130
  .long Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____ ;@ d138
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ d140
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d148
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ d150
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f ;@ d158
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167 ;@ d160
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ d168
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ d170
  .long Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____ ;@ d178
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ d180
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d188
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ d190
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f ;@ d198
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7 ;@ d1a0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ d1a8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ d1b0
  .long Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____ ;@ d1b8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d1c0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d1c8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ d1d0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df ;@ d1d8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7 ;@ d1e0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ d1e8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ d1f0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ d1f8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d200
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d208
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ d210
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ d218
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ d220
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ d228
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ d230
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Opd03d,Opd03e,Opd03f ;@ d238
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d240
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d248
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ d250
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f ;@ d258
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067 ;@ d260
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ d268
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ d270
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Opd07d,Opd07e,Opd07f ;@ d278
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d280
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d288
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ d290
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f ;@ d298
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7 ;@ d2a0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ d2a8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ d2b0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Opd0bd,Opd0be,Opd0bf ;@ d2b8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d2c0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d2c8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ d2d0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df ;@ d2d8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7 ;@ d2e0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ d2e8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ d2f0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ d2f8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ d300
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d308
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ d310
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ d318
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ d320
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ d328
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ d330
  .long Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____ ;@ d338
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ d340
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d348
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ d350
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f ;@ d358
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167 ;@ d360
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ d368
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ d370
  .long Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____ ;@ d378
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ d380
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d388
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ d390
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f ;@ d398
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7 ;@ d3a0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ d3a8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ d3b0
  .long Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____ ;@ d3b8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d3c0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d3c8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ d3d0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df ;@ d3d8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7 ;@ d3e0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ d3e8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ d3f0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ d3f8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d400
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d408
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ d410
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ d418
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ d420
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ d428
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ d430
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Opd03d,Opd03e,Opd03f ;@ d438
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d440
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d448
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ d450
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f ;@ d458
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067 ;@ d460
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ d468
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ d470
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Opd07d,Opd07e,Opd07f ;@ d478
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d480
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d488
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ d490
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f ;@ d498
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7 ;@ d4a0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ d4a8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ d4b0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Opd0bd,Opd0be,Opd0bf ;@ d4b8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d4c0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d4c8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ d4d0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df ;@ d4d8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7 ;@ d4e0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ d4e8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ d4f0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ d4f8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ d500
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d508
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ d510
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ d518
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ d520
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ d528
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ d530
  .long Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____ ;@ d538
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ d540
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d548
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ d550
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f ;@ d558
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167 ;@ d560
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ d568
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ d570
  .long Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____ ;@ d578
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ d580
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d588
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ d590
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f ;@ d598
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7 ;@ d5a0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ d5a8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ d5b0
  .long Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____ ;@ d5b8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d5c0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d5c8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ d5d0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df ;@ d5d8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7 ;@ d5e0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ d5e8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ d5f0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ d5f8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d600
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d608
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ d610
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ d618
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ d620
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ d628
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ d630
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Opd03d,Opd03e,Opd03f ;@ d638
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d640
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d648
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ d650
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f ;@ d658
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067 ;@ d660
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ d668
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ d670
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Opd07d,Opd07e,Opd07f ;@ d678
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d680
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d688
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ d690
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f ;@ d698
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7 ;@ d6a0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ d6a8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ d6b0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Opd0bd,Opd0be,Opd0bf ;@ d6b8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d6c0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d6c8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ d6d0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df ;@ d6d8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7 ;@ d6e0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ d6e8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ d6f0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ d6f8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ d700
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d708
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ d710
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ d718
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ d720
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ d728
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ d730
  .long Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____ ;@ d738
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ d740
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d748
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ d750
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f ;@ d758
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167 ;@ d760
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ d768
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ d770
  .long Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____ ;@ d778
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ d780
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d788
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ d790
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f ;@ d798
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7 ;@ d7a0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ d7a8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ d7b0
  .long Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____ ;@ d7b8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d7c0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d7c8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ d7d0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df ;@ d7d8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7 ;@ d7e0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ d7e8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ d7f0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ d7f8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d800
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d808
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ d810
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ d818
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ d820
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ d828
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ d830
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Opd03d,Opd03e,Opd03f ;@ d838
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d840
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d848
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ d850
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f ;@ d858
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067 ;@ d860
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ d868
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ d870
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Opd07d,Opd07e,Opd07f ;@ d878
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d880
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d888
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ d890
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f ;@ d898
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7 ;@ d8a0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ d8a8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ d8b0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Opd0bd,Opd0be,Opd0bf ;@ d8b8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d8c0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d8c8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ d8d0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df ;@ d8d8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7 ;@ d8e0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ d8e8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ d8f0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ d8f8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ d900
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d908
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ d910
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ d918
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ d920
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ d928
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ d930
  .long Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____ ;@ d938
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ d940
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d948
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ d950
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f ;@ d958
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167 ;@ d960
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ d968
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ d970
  .long Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____ ;@ d978
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ d980
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d988
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ d990
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f ;@ d998
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7 ;@ d9a0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ d9a8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ d9b0
  .long Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____ ;@ d9b8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d9c0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d9c8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ d9d0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df ;@ d9d8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7 ;@ d9e0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ d9e8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ d9f0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ d9f8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ da00
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ da08
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ da10
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ da18
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ da20
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ da28
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ da30
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Opd03d,Opd03e,Opd03f ;@ da38
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ da40
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ da48
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ da50
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f ;@ da58
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067 ;@ da60
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ da68
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ da70
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Opd07d,Opd07e,Opd07f ;@ da78
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ da80
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ da88
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ da90
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f ;@ da98
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7 ;@ daa0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ daa8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ dab0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Opd0bd,Opd0be,Opd0bf ;@ dab8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ dac0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ dac8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ dad0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df ;@ dad8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7 ;@ dae0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ dae8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ daf0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ daf8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ db00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ db08
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ db10
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ db18
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ db20
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ db28
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ db30
  .long Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____ ;@ db38
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ db40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ db48
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ db50
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f ;@ db58
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167 ;@ db60
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ db68
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ db70
  .long Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____ ;@ db78
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ db80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ db88
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ db90
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f ;@ db98
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7 ;@ dba0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ dba8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ dbb0
  .long Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____ ;@ dbb8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ dbc0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ dbc8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ dbd0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df ;@ dbd8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7 ;@ dbe0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ dbe8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ dbf0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ dbf8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ dc00
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ dc08
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ dc10
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ dc18
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ dc20
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ dc28
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ dc30
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Opd03d,Opd03e,Opd03f ;@ dc38
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ dc40
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ dc48
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ dc50
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f ;@ dc58
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067 ;@ dc60
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ dc68
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ dc70
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Opd07d,Opd07e,Opd07f ;@ dc78
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ dc80
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ dc88
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ dc90
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f ;@ dc98
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7 ;@ dca0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ dca8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ dcb0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Opd0bd,Opd0be,Opd0bf ;@ dcb8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ dcc0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ dcc8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ dcd0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df ;@ dcd8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7 ;@ dce0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ dce8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ dcf0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ dcf8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ dd00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ dd08
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ dd10
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ dd18
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ dd20
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ dd28
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ dd30
  .long Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____ ;@ dd38
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ dd40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ dd48
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ dd50
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f ;@ dd58
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167 ;@ dd60
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ dd68
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ dd70
  .long Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____ ;@ dd78
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ dd80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ dd88
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ dd90
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f ;@ dd98
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7 ;@ dda0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ dda8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ ddb0
  .long Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____ ;@ ddb8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ ddc0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ ddc8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ ddd0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df ;@ ddd8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7 ;@ dde0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ dde8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ ddf0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ ddf8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ de00
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ de08
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ de10
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ de18
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ de20
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ de28
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ de30
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Opd03d,Opd03e,Opd03f ;@ de38
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ de40
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ de48
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ de50
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f ;@ de58
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067 ;@ de60
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ de68
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ de70
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Opd07d,Opd07e,Opd07f ;@ de78
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ de80
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ de88
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ de90
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f ;@ de98
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7 ;@ dea0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ dea8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ deb0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Opd0bd,Opd0be,Opd0bf ;@ deb8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ dec0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ dec8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ ded0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df ;@ ded8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7 ;@ dee0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ dee8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ def0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ def8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ df00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ df08
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ df10
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ df18
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ df20
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ df28
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ df30
  .long Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____ ;@ df38
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ df40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ df48
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ df50
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f ;@ df58
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167 ;@ df60
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ df68
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ df70
  .long Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____ ;@ df78
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ df80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ df88
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ df90
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f ;@ df98
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7 ;@ dfa0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ dfa8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ dfb0
  .long Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____ ;@ dfb8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ dfc0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ dfc8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ dfd0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df ;@ dfd8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7 ;@ dfe0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ dfe8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ dff0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ dff8
  .long Ope000,Ope000,Ope000,Ope000,Ope000,Ope000,Ope000,Ope000 ;@ e000
  .long Ope008,Ope008,Ope008,Ope008,Ope008,Ope008,Ope008,Ope008 ;@ e008
  .long Ope010,Ope010,Ope010,Ope010,Ope010,Ope010,Ope010,Ope010 ;@ e010
  .long Ope018,Ope018,Ope018,Ope018,Ope018,Ope018,Ope018,Ope018 ;@ e018
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ e020
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ e028
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ e030
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ e038
  .long Ope040,Ope040,Ope040,Ope040,Ope040,Ope040,Ope040,Ope040 ;@ e040
  .long Ope048,Ope048,Ope048,Ope048,Ope048,Ope048,Ope048,Ope048 ;@ e048
  .long Ope050,Ope050,Ope050,Ope050,Ope050,Ope050,Ope050,Ope050 ;@ e050
  .long Ope058,Ope058,Ope058,Ope058,Ope058,Ope058,Ope058,Ope058 ;@ e058
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ e060
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ e068
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ e070
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ e078
  .long Ope080,Ope080,Ope080,Ope080,Ope080,Ope080,Ope080,Ope080 ;@ e080
  .long Ope088,Ope088,Ope088,Ope088,Ope088,Ope088,Ope088,Ope088 ;@ e088
  .long Ope090,Ope090,Ope090,Ope090,Ope090,Ope090,Ope090,Ope090 ;@ e090
  .long Ope098,Ope098,Ope098,Ope098,Ope098,Ope098,Ope098,Ope098 ;@ e098
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ e0a0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ e0a8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ e0b0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ e0b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e0c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e0c8
  .long Ope0d0,Ope0d0,Ope0d0,Ope0d0,Ope0d0,Ope0d0,Ope0d0,Ope0d0 ;@ e0d0
  .long Ope0d8,Ope0d8,Ope0d8,Ope0d8,Ope0d8,Ope0d8,Ope0d8,Ope0df ;@ e0d8
  .long Ope0e0,Ope0e0,Ope0e0,Ope0e0,Ope0e0,Ope0e0,Ope0e0,Ope0e7 ;@ e0e0
  .long Ope0e8,Ope0e8,Ope0e8,Ope0e8,Ope0e8,Ope0e8,Ope0e8,Ope0e8 ;@ e0e8
  .long Ope0f0,Ope0f0,Ope0f0,Ope0f0,Ope0f0,Ope0f0,Ope0f0,Ope0f0 ;@ e0f0
  .long Ope0f8,Ope0f9,Ope0fa,Ope0fb,Op____,Op____,Op____,Op____ ;@ e0f8
  .long Ope100,Ope100,Ope100,Ope100,Ope100,Ope100,Ope100,Ope100 ;@ e100
  .long Ope108,Ope108,Ope108,Ope108,Ope108,Ope108,Ope108,Ope108 ;@ e108
  .long Ope110,Ope110,Ope110,Ope110,Ope110,Ope110,Ope110,Ope110 ;@ e110
  .long Ope118,Ope118,Ope118,Ope118,Ope118,Ope118,Ope118,Ope118 ;@ e118
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ e120
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ e128
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ e130
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ e138
  .long Ope140,Ope140,Ope140,Ope140,Ope140,Ope140,Ope140,Ope140 ;@ e140
  .long Ope148,Ope148,Ope148,Ope148,Ope148,Ope148,Ope148,Ope148 ;@ e148
  .long Ope150,Ope150,Ope150,Ope150,Ope150,Ope150,Ope150,Ope150 ;@ e150
  .long Ope158,Ope158,Ope158,Ope158,Ope158,Ope158,Ope158,Ope158 ;@ e158
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ e160
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ e168
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ e170
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ e178
  .long Ope180,Ope180,Ope180,Ope180,Ope180,Ope180,Ope180,Ope180 ;@ e180
  .long Ope188,Ope188,Ope188,Ope188,Ope188,Ope188,Ope188,Ope188 ;@ e188
  .long Ope190,Ope190,Ope190,Ope190,Ope190,Ope190,Ope190,Ope190 ;@ e190
  .long Ope198,Ope198,Ope198,Ope198,Ope198,Ope198,Ope198,Ope198 ;@ e198
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ e1a0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ e1a8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ e1b0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ e1b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e1c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e1c8
  .long Ope1d0,Ope1d0,Ope1d0,Ope1d0,Ope1d0,Ope1d0,Ope1d0,Ope1d0 ;@ e1d0
  .long Ope1d8,Ope1d8,Ope1d8,Ope1d8,Ope1d8,Ope1d8,Ope1d8,Ope1df ;@ e1d8
  .long Ope1e0,Ope1e0,Ope1e0,Ope1e0,Ope1e0,Ope1e0,Ope1e0,Ope1e7 ;@ e1e0
  .long Ope1e8,Ope1e8,Ope1e8,Ope1e8,Ope1e8,Ope1e8,Ope1e8,Ope1e8 ;@ e1e8
  .long Ope1f0,Ope1f0,Ope1f0,Ope1f0,Ope1f0,Ope1f0,Ope1f0,Ope1f0 ;@ e1f0
  .long Ope1f8,Ope1f9,Ope1fa,Ope1fb,Op____,Op____,Op____,Op____ ;@ e1f8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ e200
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ e208
  .long Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10 ;@ e210
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ e218
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ e220
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ e228
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ e230
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ e238
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ e240
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ e248
  .long Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50 ;@ e250
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ e258
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ e260
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ e268
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ e270
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ e278
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ e280
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ e288
  .long Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90 ;@ e290
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ e298
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ e2a0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ e2a8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ e2b0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ e2b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e2c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e2c8
  .long Ope2d0,Ope2d0,Ope2d0,Ope2d0,Ope2d0,Ope2d0,Ope2d0,Ope2d0 ;@ e2d0
  .long Ope2d8,Ope2d8,Ope2d8,Ope2d8,Ope2d8,Ope2d8,Ope2d8,Ope2df ;@ e2d8
  .long Ope2e0,Ope2e0,Ope2e0,Ope2e0,Ope2e0,Ope2e0,Ope2e0,Ope2e7 ;@ e2e0
  .long Ope2e8,Ope2e8,Ope2e8,Ope2e8,Ope2e8,Ope2e8,Ope2e8,Ope2e8 ;@ e2e8
  .long Ope2f0,Ope2f0,Ope2f0,Ope2f0,Ope2f0,Ope2f0,Ope2f0,Ope2f0 ;@ e2f0
  .long Ope2f8,Ope2f9,Ope2fa,Ope2fb,Op____,Op____,Op____,Op____ ;@ e2f8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ e300
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ e308
  .long Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10 ;@ e310
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ e318
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ e320
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ e328
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ e330
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ e338
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ e340
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ e348
  .long Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50 ;@ e350
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ e358
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ e360
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ e368
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ e370
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ e378
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ e380
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ e388
  .long Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90 ;@ e390
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ e398
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ e3a0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ e3a8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ e3b0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ e3b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e3c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e3c8
  .long Ope3d0,Ope3d0,Ope3d0,Ope3d0,Ope3d0,Ope3d0,Ope3d0,Ope3d0 ;@ e3d0
  .long Ope3d8,Ope3d8,Ope3d8,Ope3d8,Ope3d8,Ope3d8,Ope3d8,Ope3df ;@ e3d8
  .long Ope3e0,Ope3e0,Ope3e0,Ope3e0,Ope3e0,Ope3e0,Ope3e0,Ope3e7 ;@ e3e0
  .long Ope3e8,Ope3e8,Ope3e8,Ope3e8,Ope3e8,Ope3e8,Ope3e8,Ope3e8 ;@ e3e8
  .long Ope3f0,Ope3f0,Ope3f0,Ope3f0,Ope3f0,Ope3f0,Ope3f0,Ope3f0 ;@ e3f0
  .long Ope3f8,Ope3f9,Ope3fa,Ope3fb,Op____,Op____,Op____,Op____ ;@ e3f8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ e400
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ e408
  .long Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10 ;@ e410
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ e418
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ e420
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ e428
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ e430
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ e438
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ e440
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ e448
  .long Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50 ;@ e450
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ e458
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ e460
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ e468
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ e470
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ e478
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ e480
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ e488
  .long Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90 ;@ e490
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ e498
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ e4a0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ e4a8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ e4b0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ e4b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e4c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e4c8
  .long Ope4d0,Ope4d0,Ope4d0,Ope4d0,Ope4d0,Ope4d0,Ope4d0,Ope4d0 ;@ e4d0
  .long Ope4d8,Ope4d8,Ope4d8,Ope4d8,Ope4d8,Ope4d8,Ope4d8,Ope4df ;@ e4d8
  .long Ope4e0,Ope4e0,Ope4e0,Ope4e0,Ope4e0,Ope4e0,Ope4e0,Ope4e7 ;@ e4e0
  .long Ope4e8,Ope4e8,Ope4e8,Ope4e8,Ope4e8,Ope4e8,Ope4e8,Ope4e8 ;@ e4e8
  .long Ope4f0,Ope4f0,Ope4f0,Ope4f0,Ope4f0,Ope4f0,Ope4f0,Ope4f0 ;@ e4f0
  .long Ope4f8,Ope4f9,Ope4fa,Ope4fb,Op____,Op____,Op____,Op____ ;@ e4f8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ e500
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ e508
  .long Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10 ;@ e510
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ e518
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ e520
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ e528
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ e530
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ e538
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ e540
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ e548
  .long Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50 ;@ e550
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ e558
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ e560
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ e568
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ e570
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ e578
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ e580
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ e588
  .long Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90 ;@ e590
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ e598
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ e5a0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ e5a8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ e5b0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ e5b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e5c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e5c8
  .long Ope5d0,Ope5d0,Ope5d0,Ope5d0,Ope5d0,Ope5d0,Ope5d0,Ope5d0 ;@ e5d0
  .long Ope5d8,Ope5d8,Ope5d8,Ope5d8,Ope5d8,Ope5d8,Ope5d8,Ope5df ;@ e5d8
  .long Ope5e0,Ope5e0,Ope5e0,Ope5e0,Ope5e0,Ope5e0,Ope5e0,Ope5e7 ;@ e5e0
  .long Ope5e8,Ope5e8,Ope5e8,Ope5e8,Ope5e8,Ope5e8,Ope5e8,Ope5e8 ;@ e5e8
  .long Ope5f0,Ope5f0,Ope5f0,Ope5f0,Ope5f0,Ope5f0,Ope5f0,Ope5f0 ;@ e5f0
  .long Ope5f8,Ope5f9,Ope5fa,Ope5fb,Op____,Op____,Op____,Op____ ;@ e5f8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ e600
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ e608
  .long Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10 ;@ e610
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ e618
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ e620
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ e628
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ e630
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ e638
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ e640
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ e648
  .long Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50 ;@ e650
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ e658
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ e660
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ e668
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ e670
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ e678
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ e680
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ e688
  .long Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90 ;@ e690
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ e698
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ e6a0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ e6a8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ e6b0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ e6b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e6c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e6c8
  .long Ope6d0,Ope6d0,Ope6d0,Ope6d0,Ope6d0,Ope6d0,Ope6d0,Ope6d0 ;@ e6d0
  .long Ope6d8,Ope6d8,Ope6d8,Ope6d8,Ope6d8,Ope6d8,Ope6d8,Ope6df ;@ e6d8
  .long Ope6e0,Ope6e0,Ope6e0,Ope6e0,Ope6e0,Ope6e0,Ope6e0,Ope6e7 ;@ e6e0
  .long Ope6e8,Ope6e8,Ope6e8,Ope6e8,Ope6e8,Ope6e8,Ope6e8,Ope6e8 ;@ e6e8
  .long Ope6f0,Ope6f0,Ope6f0,Ope6f0,Ope6f0,Ope6f0,Ope6f0,Ope6f0 ;@ e6f0
  .long Ope6f8,Ope6f9,Ope6fa,Ope6fb,Op____,Op____,Op____,Op____ ;@ e6f8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ e700
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ e708
  .long Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10 ;@ e710
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ e718
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ e720
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ e728
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ e730
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ e738
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ e740
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ e748
  .long Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50 ;@ e750
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ e758
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ e760
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ e768
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ e770
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ e778
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ e780
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ e788
  .long Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90 ;@ e790
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ e798
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ e7a0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ e7a8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ e7b0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ e7b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e7c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e7c8
  .long Ope7d0,Ope7d0,Ope7d0,Ope7d0,Ope7d0,Ope7d0,Ope7d0,Ope7d0 ;@ e7d0
  .long Ope7d8,Ope7d8,Ope7d8,Ope7d8,Ope7d8,Ope7d8,Ope7d8,Ope7df ;@ e7d8
  .long Ope7e0,Ope7e0,Ope7e0,Ope7e0,Ope7e0,Ope7e0,Ope7e0,Ope7e7 ;@ e7e0
  .long Ope7e8,Ope7e8,Ope7e8,Ope7e8,Ope7e8,Ope7e8,Ope7e8,Ope7e8 ;@ e7e8
  .long Ope7f0,Ope7f0,Ope7f0,Ope7f0,Ope7f0,Ope7f0,Ope7f0,Ope7f0 ;@ e7f0
  .long Ope7f8,Ope7f9,Ope7fa,Ope7fb,Op____,Op____,Op____,Op____ ;@ e7f8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ e800
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ e808
  .long Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10 ;@ e810
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ e818
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ e820
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ e828
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ e830
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ e838
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ e840
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ e848
  .long Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50 ;@ e850
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ e858
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ e860
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ e868
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ e870
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ e878
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ e880
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ e888
  .long Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90 ;@ e890
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ e898
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ e8a0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ e8a8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ e8b0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ e8b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8f8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ e900
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ e908
  .long Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10 ;@ e910
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ e918
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ e920
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ e928
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ e930
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ e938
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ e940
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ e948
  .long Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50 ;@ e950
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ e958
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ e960
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ e968
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ e970
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ e978
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ e980
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ e988
  .long Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90 ;@ e990
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ e998
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ e9a0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ e9a8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ e9b0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ e9b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9f8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ ea00
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ ea08
  .long Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10 ;@ ea10
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ ea18
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ ea20
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ ea28
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ ea30
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ ea38
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ ea40
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ ea48
  .long Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50 ;@ ea50
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ ea58
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ ea60
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ ea68
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ ea70
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ ea78
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ ea80
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ ea88
  .long Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90 ;@ ea90
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ ea98
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ eaa0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ eaa8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ eab0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ eab8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eac0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eac8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ead0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ead8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eae0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eae8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eaf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eaf8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ eb00
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ eb08
  .long Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10 ;@ eb10
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ eb18
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ eb20
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ eb28
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ eb30
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ eb38
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ eb40
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ eb48
  .long Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50 ;@ eb50
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ eb58
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ eb60
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ eb68
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ eb70
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ eb78
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ eb80
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ eb88
  .long Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90 ;@ eb90
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ eb98
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ eba0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ eba8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ ebb0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ ebb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebe0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebe8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebf8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ ec00
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ ec08
  .long Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10 ;@ ec10
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ ec18
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ ec20
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ ec28
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ ec30
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ ec38
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ ec40
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ ec48
  .long Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50 ;@ ec50
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ ec58
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ ec60
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ ec68
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ ec70
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ ec78
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ ec80
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ ec88
  .long Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90 ;@ ec90
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ ec98
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ eca0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ eca8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ ecb0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ ecb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ecc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ecc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ecd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ecd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ece0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ece8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ecf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ecf8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ ed00
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ ed08
  .long Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10 ;@ ed10
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ ed18
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ ed20
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ ed28
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ ed30
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ ed38
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ ed40
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ ed48
  .long Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50 ;@ ed50
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ ed58
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ ed60
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ ed68
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ ed70
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ ed78
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ ed80
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ ed88
  .long Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90 ;@ ed90
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ ed98
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ eda0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ eda8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ edb0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ edb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ edc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ edc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ edd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ edd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ede0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ede8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ edf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ edf8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ ee00
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ ee08
  .long Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10 ;@ ee10
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ ee18
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ ee20
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ ee28
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ ee30
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ ee38
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ ee40
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ ee48
  .long Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50 ;@ ee50
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ ee58
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ ee60
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ ee68
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ ee70
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ ee78
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ ee80
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ ee88
  .long Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90 ;@ ee90
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ ee98
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ eea0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ eea8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ eeb0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ eeb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eec0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eec8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eed0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eed8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eee0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eee8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eef0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eef8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ ef00
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ ef08
  .long Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10 ;@ ef10
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ ef18
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ ef20
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ ef28
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ ef30
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ ef38
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ ef40
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ ef48
  .long Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50 ;@ ef50
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ ef58
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ ef60
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ ef68
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ ef70
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ ef78
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ ef80
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ ef88
  .long Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90 ;@ ef90
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ ef98
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ efa0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ efa8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ efb0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ efb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ efc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ efc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ efd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ efd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ efe0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ efe8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eff0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eff8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f000
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f008
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f010
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f018
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f020
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f028
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f030
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f038
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f040
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f048
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f050
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f058
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f060
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f068
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f070
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f078
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f080
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f088
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f090
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f098
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f100
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f108
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f110
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f118
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f120
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f128
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f130
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f138
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f140
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f148
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f150
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f158
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f160
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f168
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f170
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f178
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f180
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f188
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f190
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f198
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f200
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f208
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f210
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f218
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f220
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f228
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f230
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f238
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f240
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f248
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f250
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f258
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f260
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f268
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f270
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f278
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f280
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f288
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f290
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f298
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f300
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f308
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f310
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f318
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f320
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f328
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f330
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f338
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f340
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f348
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f350
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f358
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f360
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f368
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f370
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f378
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f380
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f388
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f390
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f398
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f400
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f408
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f410
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f418
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f420
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f428
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f430
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f438
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f440
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f448
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f450
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f458
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f460
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f468
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f470
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f478
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f480
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f488
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f490
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f498
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f500
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f508
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f510
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f518
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f520
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f528
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f530
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f538
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f540
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f548
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f550
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f558
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f560
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f568
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f570
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f578
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f580
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f588
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f590
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f598
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f600
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f608
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f610
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f618
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f620
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f628
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f630
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f638
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f640
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f648
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f650
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f658
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f660
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f668
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f670
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f678
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f680
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f688
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f690
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f698
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f700
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f708
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f710
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f718
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f720
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f728
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f730
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f738
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f740
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f748
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f750
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f758
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f760
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f768
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f770
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f778
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f780
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f788
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f790
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f798
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f800
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f808
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f810
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f818
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f820
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f828
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f830
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f838
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f840
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f848
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f850
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f858
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f860
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f868
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f870
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f878
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f880
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f888
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f890
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f898
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f900
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f908
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f910
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f918
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f920
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f928
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f930
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f938
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f940
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f948
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f950
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f958
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f960
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f968
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f970
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f978
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f980
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f988
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f990
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f998
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa00
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa08
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa10
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa18
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa20
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa28
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa30
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa40
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa48
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa50
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa58
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa60
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa68
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa70
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa80
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa88
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa90
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa98
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ faa0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ faa8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fab0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fab8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fac0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fac8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fad0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fad8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fae0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fae8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ faf0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ faf8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb00
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb08
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb10
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb18
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb20
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb28
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb30
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb40
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb48
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb50
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb58
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb60
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb68
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb70
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb80
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb88
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb90
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb98
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fba0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fba8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbb0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbc0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbc8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbd0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbd8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbe0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbe8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbf0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbf8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc00
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc08
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc10
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc18
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc20
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc28
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc30
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc40
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc48
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc50
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc58
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc60
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc68
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc70
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc80
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc88
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc90
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc98
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fca0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fca8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcb0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcc0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcc8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcd0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcd8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fce0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fce8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcf0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcf8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd00
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd08
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd10
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd18
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd20
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd28
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd30
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd40
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd48
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd50
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd58
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd60
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd68
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd70
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd80
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd88
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd90
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd98
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fda0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fda8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdb0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdc0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdc8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdd0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdd8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fde0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fde8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdf0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdf8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe00
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe08
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe10
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe18
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe20
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe28
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe30
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe40
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe48
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe50
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe58
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe60
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe68
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe70
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe80
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe88
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe90
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe98
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fea0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fea8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ feb0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ feb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fec0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fec8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fed0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fed8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fee0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fee8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fef0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fef8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff00
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff08
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff10
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff18
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff20
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff28
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff30
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff40
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff48
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff50
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff58
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff60
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff68
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff70
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff80
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff88
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff90
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff98
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffa0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffa8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffb0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffc0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffc8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffd0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffd8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffe0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffe8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fff0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl
;@ notaz: we don't want to crash if we run into those 2 missing opcodes
;@ so we leave this pattern to patch it later
  .long 0x78563412
  .long 0x56341290
